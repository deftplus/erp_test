
#Область ПрограммныйИнтерфейс

// Функция формирует кэш, содержащий типы реквизитов переданного объекта метаданных
//
// Параметры:
//  ОбъектМетаданных - 	ОбъектМетаданных - объект метаданных, реквизиты которого необходимо поместить в кэш
// 
// Возвращаемое значение:
//  ФиксированнаяСтруктура
//
Функция ТипыРеквизитовОбъекта(ОбъектМетаданных) Экспорт
	
	ТипыРеквизитов=Новый Соответствие;
	
	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
		
		Если Реквизит.Имя="ИсходныйДокумент" Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		Для Каждого Тип ИЗ Реквизит.Тип.Типы() Цикл
			
			ТипыРеквизитов.Вставить(Тип,Реквизит.Имя);
			
		КонецЦикла;
		
	КонецЦикла;

	Возврат Новый ФиксированноеСоответствие(ТипыРеквизитов);
	
КонецФункции

#Область КоллецииЗначений

// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		ТекстСообщения = НСтр("ru = 'Неверный тип универсальной коллекции для копирования %КоллекцияИсходная%'");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоллекцияИсходная%", Строка(КоллекцияИсходная));
		ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

Функция ПолучитьЭлементСтруктурыПоИндексу(Структура,Индекс) Экспорт
	
	ТекИндекс=0;
	
	Для Каждого КлючИЗначение ИЗ Структура Цикл
		
		Если ТекИндекс=Индекс Тогда
			
			Возврат КлючИЗначение;
			
		КонецЕсли;
		
		ТекИндекс=ТекИндекс+1;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // ПолучитьЭлементСтруктурыПоИндексу() 

// Функция сравнивает два массива строк, полученных из одной таблицы значений, на предмет идентичности
//
//
// Параметры
//  МассивСтрок1 - МассивСтрок для сравнения
//  МассивСтрок2 - МассивСтрок для сравнения
//  ТаблицаЗначений - содержит колонки исходной ТЗ.
//
// Возвращаемое значение:
//   Булево, идентичны или нет два массива
//
Функция СравнитьМассивыСтрокТаблицыЗначений(МассивСтрок1,МассивСтрок2, ТаблицаЗначений) Экспорт
	
	Если ТипЗнч(МассивСтрок1) <> Тип("Массив") ИЛИ ТипЗнч(МассивСтрок2) <> Тип("Массив") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если МассивСтрок1.Количество() <> МассивСтрок2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Для Индекс=0 По МассивСтрок1.Количество()-1 Цикл
		
		Стр1=МассивСтрок1[Индекс];
		Стр2=МассивСтрок2[Индекс];
		
		Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
			
			Попытка
				
				Если Стр1[Колонка.Имя] <> Стр2[Колонка.Имя] Тогда
					
					Возврат Ложь;
					
				КонецЕсли;
				
			Исключение
				
				Возврат Ложь;
				
			КонецПопытки;
			
		КонецЦикла; 
		
	КонецЦикла; 
	
	Возврат Истина;
	
КонецФункции // СравнитьТаблицыЗначений()

Процедура ПреобразоватьТаблицуЗначенийВДерево(ТаблицаЗначений) Экспорт
	
	Дерево=Новый ДеревоЗначений;
	
	ТаблицаЗначений.Сортировать("ИдентификаторРодителя Возр");
	
	Для Каждого Колонка ИЗ ТаблицаЗначений.Колонки Цикл
		
		Дерево.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения,Колонка.Заголовок,Колонка.Ширина);
		
	КонецЦикла;

//	Для Каждого Строка ИЗ ТаблицаЗначений Цикл
//		
//		Если ПустаяСтрока(Строка.ИдентификаторРодителя) Тогда
//			
//			НоваяСтрока=Дерево.Строки.Добавить();
//			
//		Иначе
//			
//			СтрокаРодитель=Дерево.Строки.Найти(Строка.ИдентификаторРодителя,"ИдентификаторСтроки",Истина);
//			
//			Если 
//			
//			НоваяСтрока=СтрокаРодитель.Строки.Добавить();
//			
//		КонецЕсли;

//			ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка)
	
	
	
КонецПроцедуры // ПреобразоватьТаблицуЗначенийВДерево(ТаблицаЗначений) 

Функция ПолучитьКолонкиКоллекцииТекстом(КоллекцияКолонок) Экспорт

	РезультатТекст = "";
	Для каждого ЭлементКолонка Из КоллекцияКолонок Цикл
		РезультатТекст = ?(РезультатТекст = "", ЭлементКолонка.Имя, РезультатТекст + "," + ЭлементКолонка.Имя);
	КонецЦикла;
	
	Возврат РезультатТекст;

КонецФункции

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	ОбщегоНазначения.УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов);
	
КонецПроцедуры

// Рекурсивно заполняет в дереве ДеревоОбработки колонку с именем ИмяПоляПриемникаВход значениями 
// из соответствия СоответствиеЗначенийВход по колонке с именем ИмяПоляИсточникаВход.
Процедура ВыполнитьЗаполнениеПолейИзСоответствия(ИмяПоляИсточникаВход, ИмяПоляПриемникаВход, СоответствиеЗначенийВход, ДеревоОбработки, ТолькоЛистьяВход = Ложь, ГлубинаРекурсииВход = 0)
	Если ГлубинаРекурсииВход > 10000 Тогда
		Возврат;
	КонецЕсли;
	Для Каждого ТекСтроки Из ДеревоОбработки.Строки Цикл
		ЕстьПодчиненные = (ТекСтроки.Строки.Количество() > 0);
		Если (НЕ ЕстьПодчиненные) ИЛИ (НЕ ТолькоЛистьяВход) Тогда
			ЗначениеИсточник = ТекСтроки[ИмяПоляИсточникаВход];
			НовоеЗначениеПриемник = СоответствиеЗначенийВход[ЗначениеИсточник];
			ТекСтроки[ИмяПоляПриемникаВход] = НовоеЗначениеПриемник;
		Иначе
			// НЕ доавляем группирующую строку для режима ТолькоЛистьяВход.
		КонецЕсли;
		ВыполнитьЗаполнениеПолейИзСоответствия(ИмяПоляИсточникаВход, ИмяПоляПриемникаВход, СоответствиеЗначенийВход, ТекСтроки, ТолькоЛистьяВход, ГлубинаРекурсииВход +1);
	КонецЦикла;
КонецПроцедуры		// ВыполнитьЗаполнениеПолейИзСоответствия()

// Заполняет в дереве ДеревоОбработки колонку с именем ИмяПоляПриемникаВход значениями 
// из соответствия СоответствиеЗначенийВход по колонке с именем ИмяПоляИсточникаВход.
Процедура ПроставитьЗначенияПолейИзСоответствия(ИмяПоляИсточникаВход, ИмяПоляПриемникаВход, СоответствиеЗначенийВход, ДеревоОбработки, ТолькоЛистьяВход  = Ложь) Экспорт
	КолонкиДерева = ДеревоОбработки.Колонки;
	КолонкаИсточник = КолонкиДерева.Найти(ИмяПоляИсточникаВход);
	КолонкаПриемник = КолонкиДерева.Найти(ИмяПоляПриемникаВход);
	Если (КолонкаИсточник <> Неопределено) И (КолонкаПриемник <> Неопределено) Тогда
		ВыполнитьЗаполнениеПолейИзСоответствия(ИмяПоляИсточникаВход, ИмяПоляПриемникаВход, СоответствиеЗначенийВход, ДеревоОбработки, ТолькоЛистьяВход);
	Иначе
		ТекстСообщения = НСтр("ru = 'Не найдены необходимые колонки в дереве. Заполнение отменено.'");
		ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
	КонецЕсли;
КонецПроцедуры		// ПроставитьЗначенияПолейИзСоответствия()

// Представляет любое значение в строку для отображения пользователю
//  в наглядном для человека представлении.
//
// Параметры:
//  Значение - Любое значение - значение для преобразования в строку.
//  Отступ	 - Строка - отступ для всех строк представления.
// 
// Возвращаемое значение:
//   - Строка - представление переданного значений. Может занимать
//				несколько строк.
//
Функция ЗначениеВСтроку(Знач Значение, Знач Отступ = "") Экспорт
	Перем Стр;
	
	Стр = "";
	ТипЗначения = ТипЗнч(Значение);
	
	Если ТипЗначения = Тип("СписокЗначений") Тогда
		Стр = СтрШаблон(Нстр("ru = '%1Список значений(%2): %3'"), Стр + Отступ, Значение.Количество(), 
		      	Символы.ПС);
		Для каждого Значение1 Из Значение Цикл
			Стр = Стр + Отступ + "	" + Значение1.Представление + " = " + ЗначениеВСтроку(Значение1.Значение, Отступ + "	") + Символы.ПС;
		КонецЦикла;
		Стр = Сред(Стр, 1, СтрДлина(Стр)-1);
	ИначеЕсли ТипЗначения = Тип("Массив") ИЛИ ТипЗначения = Тип("ФиксированныйМассив") Тогда
		Стр = Стр + Отступ + ?(ТипЗначения = Тип("Массив"), Нстр("ru = 'Массив('"), Нстр("ru = 'Фиксированный массив('")) + Значение.Количество() + "): " + Символы.ПС;
		Ном = 0;
		Для Ном = 0 По Значение.ВГраница() Цикл
			Стр = Стр + Отступ + "	[" + Ном + "] = " + ЗначениеВСтроку(Значение[Ном], Отступ + "	") + Символы.ПС;
		КонецЦикла;
		Стр = Сред(Стр, 1, СтрДлина(Стр)-1);
	ИначеЕсли ТипЗначения = Тип("Структура") 
				ИЛИ ТипЗначения = Тип("Соответствие")
				ИЛИ ТипЗначения = Тип("ФиксированнаяСтруктура") 
				ИЛИ ТипЗначения = Тип("ФиксированноеСоответствие") Тогда
		ИмяТипа = Строка(ТипЗначения) + ":";
		Стр = Стр + Отступ + ИмяТипа + Символы.ПС;
		Для каждого Значение1 Из Значение Цикл
			Стр = Стр + Отступ + "	" + Значение1.Ключ + " = " + ЗначениеВСтроку(Значение1.Значение, Отступ + "	") + Символы.ПС;
		КонецЦикла;
		Стр = Сред(Стр, 1, СтрДлина(Стр)-1);
	ИначеЕсли ТипЗначения = Тип("ТаблицаЗначений") Тогда
		Стр = СтрШаблон(Нстр("ru = '%1Таблица значений (строк %2, колонок %3): %4'"), Стр + Отступ, Значение.Количество(), 
		      	Значение.Колонки.Количество(), Символы.ПС);
		Ном = 1;
		Для каждого Значение1 Из Значение Цикл
			Стр = СтрШаблон(Нстр("ru = '%1	Строка №%2 = %3'"), Стр + Отступ, Ном, Символы.ПС);
			Ном = Ном + 1;
			Для каждого Колонка Из Значение.Колонки Цикл
				Стр = Стр + Отступ + "		" + Колонка.Имя + " = " + ЗначениеВСтроку(Значение1[Колонка.Имя], Отступ + "			") +Символы.ПС;
			КонецЦикла;
		КонецЦикла;
		Стр = Сред(Стр, 1, СтрДлина(Стр)-1);
	Иначе
		Стр = СтрШаблон(Нстр("ru = '%1(тип: %2)'"), Стр + Отступ + Строка(Значение), Строка(ТипЗначения));
	КонецЕсли;
	Возврат Стр;
КонецФункции

#КонецОбласти

#Область ДатыИПериодыОтчетов

//Функция добавляет "ЧислоДней" к "Дата"
//
Функция ДобавитьДень(Дата, ЧислоДней) Экспорт
	
	Возврат Дата + ЧислоДней * 86400; // 86400 = 24*60*60 - число секунд в дне;
	
КонецФункции // () 

// Устарела. см.ОбщегоНазначенияКлиентСерверУХ.РазностьДатВДнях
//Функция возвращает разность в днях между "ДатаУменьшаемое" и "ДатаВычитаемое"
//
Функция РазностьДатВДнях(ДатаУменьшаемое, ДатаВычитаемое) Экспорт
	Возврат ОбщегоНазначенияКлиентСерверУХ.РазностьДатВДнях(ДатаУменьшаемое, ДатаВычитаемое);  
КонецФункции 

// Возвращает количество периодов между указанными датами
//
// Параметры
//  ДатаНачала, ДатаКонца: Дата  – границы интервала
//  Периодичность (Перечисления.Периодичность): периодичность планирования
//
// Возвращаемое значение:
//   КоличествоПериодов   – количество периодов в переданном интервале
//
Функция РассчитатьКоличествоПериодов(ДатаНачала,ДатаКонца,Периодичность) Экспорт
	
	Если ДатаНачала<ДатаКонца Тогда
		
		ИсходнаяДата=ДатаНачала;
		КонечнаяДата=ДатаКонца;
		Коэффициент=1;
		
	ИначеЕсли  ДатаНачала>ДатаКонца Тогда
		
		ИсходнаяДата=ДатаКонца;
		КонечнаяДата=ДатаНачала;
		Коэффициент=-1;
		
	ИначеЕсли ДатаНачала=ДатаКонца Тогда
		
		Возврат 0;
		
	КонецЕсли;
	
	ТекущаяДата=ДобавитьИнтервал(ИсходнаяДата,Периодичность,1);
	
	Если КонецДня(ТекущаяДата)>КонецДня(КонечнаяДата) Тогда
		
		Возврат 1;
		
	КонецЕсли;
	
	КоличествоПериодов=1;
	
	Пока ДатаКонцаПериода(ТекущаяДата,Периодичность)<=КонецДня(КонечнаяДата) Цикл
		
		КоличествоПериодов=КоличествоПериодов+1;
		
		ТекущаяДата=ДобавитьИнтервал(ТекущаяДата,Периодичность,1);
		
	КонецЦикла;
	
	Возврат КоличествоПериодов*Коэффициент;
	
КонецФункции // РассчитатьКоличествоПериодов()

Функция НачалоДекады(ДатаНачала) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.НачалоДекады(ДатаНачала);
	
КонецФункции // НачалоДекады()

Функция КонецДекады(ДатаНачала) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.КонецДекады(ДатаНачала);
	
КонецФункции // КонецДекады() 

Функция НачалоНеделиПоМесяцу(ДатаНачала) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.НачалоНеделиПоМесяцу(ДатаНачала);
	
КонецФункции // НачалоНеделиПоМесяцу

Функция КонецНеделиПоМесяцу(ДатаНачала) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.КонецНеделиПоМесяцу(ДатаНачала);		
	
КонецФункции // КонецНеделиПоМесяцу() 

// Функция добавляет интервал к дате
//
// Параметры:
//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
//
// Возвращаемое значение:
//	Дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт
	
	Если Смещение = 0 Тогда
		НоваяДатаПериода = ДатаПериода;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		НоваяДатаПериода = НачалоДня(ДатаПериода + Смещение*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода = НачалоНеделиПоМесяцу(ДатаПериода + Смещение*7*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		НоваяДатаПериода = НачалоДекады(ДатаПериода + Смещение*11*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*3);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*6);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.ДевятьМесяцев Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*9);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*12);
		
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода) + Смещение*24*3600;
		
	КонецЕсли;
	
	Возврат НоваяДатаПериода;
	
КонецФункции // ДобавитьИнтервал()

// Функция возвращает ближайшую дату начала периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаНачалаПериода		– ближайшая дата начала периода планирования
//
Функция ДатаНачалаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ДатаНачалаПериода(ДатаВПериоде, Периодичность);
	
КонецФункции // ДатаНачалаПериода()

// Функция возвращает ближайшую дату окончания периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаКонцаПериода	– ближайшая дата окончания периода планирования
//
Функция ДатаКонцаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ДатаКонцаПериода(ДатаВПериоде,Периодичность);
	
КонецФункции // ДатаКонцаПериода()

Процедура ОпределитьГраницыИнтервала(ДатаНачала,ДатаОкончания,Периодичность) Экспорт
	
	Если (Не ЗначениеЗаполнено(Периодичность)) 
		ИЛИ (Не (ЗначениеЗаполнено(ДатаНачала) ИЛИ ЗначениеЗаполнено(ДатаОкончания))) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Если ((НЕ ЗначениеЗаполнено(ДатаОкончания)) ИЛИ ДатаОкончания<ДатаНачала) Тогда
		
		ДатаОкончания=ДатаКонцаПериода(ДатаНачала,Периодичность);
		
	ИначеЕсли ((НЕ ЗначениеЗаполнено(ДатаНачала)) ИЛИ ДатаНачала>ДатаОкончания) Тогда
		
		ДатаНачала=ДатаНачалаПериода(ДатаОкончания,Периодичность);
		
	Иначе
		
		ДатаНачала=ДатаНачалаПериода(ДатаНачала,Периодичность);
		ДатаОкончания=ДатаКонцаПериода(ДатаНачала,Периодичность);
		
	КонецЕсли;
	
КонецПроцедуры // ОпределитьГраницыИнтервала()

Функция ОпределитьСписокПодчиненныхПериодов(Периодичность,СписокПериодов=Неопределено) Экспорт
	
	Если СписокПериодов=Неопределено Тогда
		СписокПериодов=Новый СписокЗначений;
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.Год Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.Полугодие);
		ОпределитьСписокПодчиненныхПериодов(Перечисления.Периодичность.Полугодие,СписокПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Полугодие Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.Квартал);
		ОпределитьСписокПодчиненныхПериодов(Перечисления.Периодичность.Квартал,СписокПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.Месяц);
		ОпределитьСписокПодчиненныхПериодов(Перечисления.Периодичность.Месяц,СписокПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.Неделя);
		СписокПериодов.Добавить(Перечисления.Периодичность.Декада);
		СписокПериодов.Добавить(Перечисления.Периодичность.День);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя 
		ИЛИ Периодичность=Перечисления.Периодичность.Декада
		ИЛИ Периодичность=Перечисления.Периодичность.День Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.День);
		
	КонецЕсли;
	
	Возврат СписокПериодов;
	
КонецФункции // ОпределитьСписокПодчиненныхПериодов

Функция ОпределитьМассивВышестоящихПериодов(Периодичность,МассивПериодов=Неопределено) Экспорт
	
	Если МассивПериодов=Неопределено Тогда
		МассивПериодов=Новый Массив;
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Декада);
		МассивПериодов.Добавить(Перечисления.Периодичность.Неделя);
		ОпределитьМассивВышестоящихПериодов(Перечисления.Периодичность.Неделя,МассивПериодов);
		
	ИначеЕсли (Периодичность=Перечисления.Периодичность.Неделя ИЛИ Периодичность=Перечисления.Периодичность.Декада) Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Месяц);
		ОпределитьМассивВышестоящихПериодов(Перечисления.Периодичность.Месяц,МассивПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Квартал);
		ОпределитьМассивВышестоящихПериодов(Перечисления.Периодичность.Квартал,МассивПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Полугодие);
		ОпределитьМассивВышестоящихПериодов(Перечисления.Периодичность.Полугодие,МассивПериодов);
		
	ИначеЕсли (Периодичность=Перечисления.Периодичность.Полугодие ИЛИ Периодичность=Перечисления.Периодичность.Год)  Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Год);
		
	КонецЕсли;
	
	Возврат МассивПериодов;
	
КонецФункции // ОпределитьСписокВышестоящихПериодов()

Функция ТекстНачалаКонцаПериода(Периодичность,ДатаВПериоде=Неопределено) Экспорт
	
	ТекстПериод = "";
	
	СтруктураТекст = Новый Структура;
	
	Если ДатаВПериоде <> Неопределено Тогда
		
		ТекущийПериод = ПолучитьПериодПоДате(ДатаВПериоде, Периодичность);
		Если ЗначениеЗаполнено(ТекущийПериод) Тогда
			ТекстПериод = ТекстПериод + ": " + ТекущийПериод.Наименование;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.Неделя Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода",	НСтр("ru = 'Начало недели'") 	+ ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода",НСтр("ru = 'Конец недели'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод",НСтр("ru = 'Предыдущая неделя'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод",	НСтр("ru = 'Следующая неделя'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод",	НСтр("ru = 'Текущая неделя'")		+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Декада Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода",	НСтр("ru = 'Начало декады'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода",НСтр("ru = 'Конец декады'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод",НСтр("ru = 'Предыдущая декада'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод",	НСтр("ru = 'Следующая декада'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод",	НСтр("ru = 'Текущая декада'")		+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода",	НСтр("ru = 'Начало месяца'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода",НСтр("ru = 'Конец месяца'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод",НСтр("ru = 'Предыдущий месяц'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод",	НСтр("ru = 'Следующий месяц'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод",	НСтр("ru = 'Текущий месяц'")		+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода",	НСтр("ru = 'Начало квартала'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода",НСтр("ru = 'Конец квартала'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод",НСтр("ru = 'Предыдущий квартал'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод",	НСтр("ru = 'Следующий квартал'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод",	НСтр("ru = 'Текущий квартал'")	+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Полугодие Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода",	НСтр("ru = 'Начало полугодия'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода",НСтр("ru = 'Конец полугодия'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод",НСтр("ru = 'Предыдущее полугодие'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод",	НСтр("ru = 'Следующее полугодие'")	+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод",	НСтр("ru = 'Текущее полугодие'")		+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода",	НСтр("ru = 'Начало года'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода",НСтр("ru = 'Конец года'")			+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод",НСтр("ru = 'Предыдущий год'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод",	НСтр("ru = 'Следующий год'")		+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод",	НСтр("ru = 'Текущий год'")		+ТекстПериод);
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат СтруктураТекст;
	
КонецФункции // ТекстНачалаКонцаПериода() 

// Получет ссылку на справочник Периоды по заданным датам начала и окончания периода
//
// Параметры:
//  ДатаНачала  - <Дата> - дата начала периода
//  ДатаОкончания - <Дата> - дата окончания периода
//
// Возвращаемое значение:
//   <СправочникСсылка.Периоды>   - Найденое значение если существует. Пустую ссылку если период с заданными параметрами отсутствует
//
Функция ПолучитьПроизвольныйПериод(ДатаНачала, ДатаОкончания) Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	Периоды.Ссылка КАК Ссылка
	               |ИЗ
	               |	Справочник.Периоды КАК Периоды
	               |ГДЕ
	               |	Периоды.ДатаНачала = &ДатаНачала
	               |	И Периоды.ДатаОкончания = &ДатаОкончания";
	
	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачала);
	Запрос.УстановитьПараметр("ДатаОкончания", ДатаОкончания);
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Справочники.Периоды.ПустаяСсылка(); 
	Иначе	
		Возврат РезультатЗапроса.Выгрузить()[0].Ссылка;
	КонецЕсли;	

КонецФункции

// Получет ссылку на справочник Периоды по заданной дате и периодичности
//
// Параметры:
//  ДатаВПериоде  - <Дата> - дата которая попадает в период
//  Периодичность  - <ПеречислениеСсылка.Периодичность> - необходимая периодичность
//
// Возвращаемое значение:
//   <СправочникСсылка.Периоды>   - Найденое значение если существует. Пустую ссылку если период с заданными параметрами отсутствует
//
Функция ПолучитьПериодПоДате(ДатаВПериоде, Периодичность) Экспорт
		
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	Периоды.Ссылка КАК Ссылка,
		|	Периоды.Наименование КАК Наименование,
		|	РАЗНОСТЬДАТ(Периоды.ДатаНачала, Периоды.ДатаОкончания, ДЕНЬ) КАК ДнейВПериоде
		|ИЗ
		|	Справочник.Периоды КАК Периоды
		|ГДЕ
		|	Периоды.ДатаНачала <= &ДатаВПериоде
		|	И Периоды.ДатаОкончания >= &ДатаВПериоде
		|	И Периоды.Периодичность = &ТекПериодичность
		|	И НЕ Периоды.Произвольный
		|	И НЕ Периоды.ПометкаУдаления
		|
		|УПОРЯДОЧИТЬ ПО
		|	ДнейВПериоде УБЫВ";
	
	Запрос.УстановитьПараметр("ДатаВПериоде", НачалоДня(ДатаВПериоде));
	Запрос.УстановитьПараметр("ТекПериодичность", Периодичность);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		Возврат ВыборкаДетальныеЗаписи.Ссылка;
	Иначе
		Возврат Справочники.Периоды.ПустаяСсылка();
	КонецЕсли;
	
КонецФункции // ПолучитьПериодПоДате()

// Устарела. Использовать Функцию ПолучитьПериодПоДате(ДатаВПериоде, Периодичность)
//
Функция ОпределитьПериодПоДате(ДатаВПериоде, Периодичность) Экспорт
		
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ ПЕРВЫЕ 1
	|	Периоды.Ссылка КАК Ссылка,
	|	Периоды.Наименование КАК Наименование,
	|	РАЗНОСТЬДАТ(Периоды.ДатаНачала, Периоды.ДатаОкончания, ДЕНЬ) КАК ДнейВПериоде
	|ИЗ
	|	Справочник.Периоды КАК Периоды
	|ГДЕ
	|	Периоды.ДатаНачала <= &ДатаВПериоде
	|	И Периоды.ДатаОкончания >= &ДатаВПериоде
	|	И Периоды.Периодичность = &ТекПериодичность
	|	И НЕ Периоды.Произвольный
	|	И НЕ Периоды.ПометкаУдаления
	|
	|УПОРЯДОЧИТЬ ПО
	|	ДнейВПериоде";
	
	Запрос.УстановитьПараметр("ТекПериодичность",Периодичность);
	Запрос.УстановитьПараметр("ДатаВПериоде", НачалоДня(ДатаВПериоде));
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Если Результат.Следующий() Тогда
		
		Возврат Результат.Ссылка;
		
	Иначе
		
		Возврат глОтносительныйПериодПоДате(ДатаНачалаПериода(ДатаВПериоде, Периодичность), Периодичность, 0, Истина);
				
	КонецЕсли;
	
КонецФункции // ОпределитьПериодПоДате()

Функция ПолучитьПериодСтрокой(ДатаВПериоде, Периодичность) Экспорт
   
    Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ='гггг ""г.""'";
		
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ='к"" квартал"" гггг ""г.""'";
		
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ='ММММ гггг ""г.""'";
		
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ='""Неделя (""дд.ММ.гггг'";
		
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ='дд.ММ.гггг ""г.""'";
		
	Иначе
		ФорматДаты = "";
		
	КонецЕсли;
   
    СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
    Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
        СтрокаПериод = СтрШаблон(Нстр("ru = '%1-ая %2%3'"), НеделяГода(ДатаВПериоде), СтрокаПериод, Формат(КонецНедели(ДатаВПериоде), "ДФ='"" - ""дд.ММ.гггг)'"));
    КонецЕсли;
   
    Возврат СтрокаПериод;
   
КонецФункции // ПолучитьПериодСтрокой() 

Функция МинимальнаяПериодичность(Периодичность1,Периодичность2) Экспорт
	
	Если ДатаКонцаПериода(ТекущаяДата(),Периодичность1)>=ДатаКонцаПериода(ТекущаяДата(),Периодичность2)
		И ДатаНачалаПериода(ТекущаяДата(),Периодичность1)<=ДатаНачалаПериода(ТекущаяДата(),Периодичность2) Тогда
		
		Возврат Периодичность2;
		
	Иначе
		
		Возврат Периодичность1;
		
	КонецЕсли;
	
КонецФункции // МинимальнаяПериодичность()

Функция МаксимальнаяПериодичность(Периодичность1,Периодичность2) Экспорт
	
	Если ДатаКонцаПериода(ТекущаяДата(),Периодичность1)<=ДатаКонцаПериода(ТекущаяДата(),Периодичность2)
		И ДатаНачалаПериода(ТекущаяДата(),Периодичность1)>=ДатаНачалаПериода(ТекущаяДата(),Периодичность2)Тогда
		
		Возврат Периодичность2;
		
	Иначе
		
		Возврат Периодичность1;
		
	КонецЕсли;
	
КонецФункции // МаксимальнаяПериодичность()

Функция ПолучитьВышестоящийПериод(ПериодОтчета,Периодичность) Экспорт
	
	Если МаксимальнаяПериодичность(ПериодОтчета.Периодичность,Периодичность)=ПериодОтчета.Периодичность Тогда
		
		Возврат ПериодОтчета;
		
	Иначе
		
		Возврат глОтносительныйПериодПоДате(ПериодОтчета.ДатаНачала,Периодичность,0);
		
	КонецЕсли; 	
	
КонецФункции

Функция ВернутьОтносительнуюДату(ДатаНачала, Периодичность, Смещение) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ВернутьОтносительнуюДату(ДатаНачала, Периодичность, Смещение);
	
КонецФункции

Функция глОтносительныйПериодПоДате(ДатаНачала, Периодичность, Смещение, ТихийРежим = Ложь, Реструктурировать = Истина) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.глОтносительныйПериодПоДате(ДатаНачала, Периодичность, Смещение, ТихийРежим, Реструктурировать);
	
КонецФункции

Функция глОтносительныйПериод(локПериодОтчета, Смещение, ТихийРежим = Ложь, Реструктурировать = Истина) Экспорт
	
	Если Смещение=0 Тогда
		
		Возврат локПериодОтчета;
		
	КонецЕсли; 
	
	Если НЕ ЗначениеЗаполнено(локПериодОтчета) Тогда
		Если НЕ ТихийРежим Тогда
			СообщитьОбОшибке(СтрШаблон(НСтр("ru = 'Невозможно определить аналогичный период года (смещение = %1): исходный период не задан! '"), Смещение), , ,СтатусСообщения.Важное);
		КонецЕсли;
		Возврат Справочники.Периоды.ПустаяСсылка();
	КонецЕсли;
	
	Возврат глОтносительныйПериодПоДате(локПериодОтчета.ДатаНачала, локПериодОтчета.Периодичность, Смещение, ТихийРежим, Реструктурировать);
	
КонецФункции

Функция глАналогичныйПериод(локПериодОтчета, Смещение) Экспорт
	
	Если НЕ ЗначениеЗаполнено(локПериодОтчета) Тогда
		СообщитьОбОшибке(СтрШаблон(НСтр("ru = 'Невозможно определить аналогичный период года (смещение = %1): исходный период не задан! '"), Смещение), , , СтатусСообщения.Важное);
		Возврат Справочники.Периоды.ПустаяСсылка();
	КонецЕсли;
	
	Если локПериодОтчета.Периодичность = Перечисления.Периодичность.Декада Тогда
		
		// анализируем
		ГодДатыНачала						= Год(локПериодОтчета.ДатаНачала);
		МесяцДатыНачала						= Месяц(локПериодОтчета.ДатаНачала);
		ДеньДатыНачала						= День(локПериодОтчета.ДатаНачала);
		ДекадаДатыНачала					= Цел((ДеньДатыНачала - 1) / 10) + 1;
		ДекадаДатыНачала					= ?(ДекадаДатыНачала = 4, 3, ДекадаДатыНачала);
		НомерДекадыНЭ						= ГодДатыНачала * 36 + (МесяцДатыНачала - 1) * 3 + (ДекадаДатыНачала - 1);
		
		// изменяем
		НомерДекадыНЭ						= НомерДекадыНЭ + Смещение;
		
		// синтезируем
		ГодДатыНачалаОтнПериода				= Цел((НомерДекадыНЭ)/ 36);
		ДекадаВГоду							= НомерДекадыНЭ % 36;
		МесяцВГодуДатыНачалаОтнПериода		= Цел(ДекадаВГоду / 3) + 1;
		ДекадаВМесяце						= ДекадаВГоду % 3;
		ДеньВМесяцеДатыНачалаОтнПериода		= ДекадаВМесяце * 10 + 1;
		
		ДатаНачалаОтносительногоПериода		= Дата(ГодДатыНачалаОтнПериода+Смещение, МесяцВГодуДатыНачалаОтнПериода, ДеньВМесяцеДатыНачалаОтнПериода);
		
	Иначе
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(локПериодОтчета.ДатаНачала, 12 * Смещение);
	КонецЕсли;
	
	ДатаНачалаОтносительногоПериода = НачалоДня(ДатаНачалаОтносительногоПериода);
	
	Запрос = Новый Запрос("ВЫБРАТЬ ПЕРВЫЕ 1
	|	Периоды.Ссылка
	|ИЗ
	|	Справочник.Периоды КАК Периоды
	|ГДЕ
	|	Периоды.ДатаНачала = &ДатаНачала
	|	И Периоды.Периодичность = &Периодичность");
	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачалаОтносительногоПериода);
	Запрос.УстановитьПараметр("Периодичность", локПериодОтчета.Периодичность);
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		СообщитьОбОшибке(СтрШаблон(НСтр("ru = 'Невозможно определить аналогичный период (смещение = %1): не существует искомый период в справочнике ""Периоды""! '"), Смещение), , , СтатусСообщения.Важное);
		Возврат Справочники.Периоды.ПустаяСсылка();
	Иначе
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Получить(0);
	КонецЕсли;
		
КонецФункции

Функция ПолучитьКонецПериодаОтчета(ПериодОтчета = Неопределено) Экспорт

	Если ЗначениеЗаполнено(ПериодОтчета) Тогда	
		Возврат КонецДня(ОбщегоНазначенияУХ.ПолучитьЗначениеРеквизита(ПериодОтчета, "ДатаОкончания"));
	Иначе 
		Возврат Дата(1, 1, 1);
	КонецЕсли;

КонецФункции

#КонецОбласти

#Область ПерсональныеНастройки

// Функция возвращает значение по умолчанию для передаваемого пользователя и настройки.
//
// Параметры:
//  Настройка    - Строка - вид настройки, значение по умолчанию которой необходимо получить
//  Пользователь - СправочникСсылка.Пользователи - пользователь программы, настройка которого
//				   запрашивается, если параметр не передается настройка возвращается для текущего пользователя
//
// Возвращаемое значение:
//  Значение по умолчанию для настройки.
//
Функция ПолучитьЗначениеПоУмолчанию(Настройка, Пользователь = Неопределено) Экспорт
	
	НастройкаВРег = ВРег(Настройка);
	
	Если НастройкаВРег = ВРег("ОсновнойЦФО") Тогда
		Возврат ЦФОПоУмолчанию(Пользователь);
	ИначеЕсли НастройкаВРег = ВРег("ОсновнойПроект") Тогда
		Возврат ПроектПоУмолчанию(Пользователь);
	ИначеЕсли НастройкаВРег = ВРег("ОсновнойЯзык") Тогда
		Возврат ЯзыкПоУмолчанию(Пользователь);
	Иначе
		Возврат БухгалтерскийУчетПереопределяемый.ПолучитьЗначениеПоУмолчанию(Настройка, Пользователь);
	КонецЕсли;

КонецФункции

// Процедура записывает значение по умолчанию для передаваемого пользователя и настройки.
//
// Параметры:
//  Настройка    - Строка - вид настройки
//  Значение     - значение настройки
//  Пользователь - СправочникСсылка.Пользователи - текущий пользователь программы, для которого устанавливается настройка
//
// Возвращаемое значение:
//  Нет
//
Процедура УстановитьЗначениеПоУмолчанию(Настройка, Значение, Пользователь = Неопределено) Экспорт
	
	Если ВРег(Настройка) = ВРег("ОсновнойЦФО")
		ИЛИ ВРег(Настройка) = ВРег("ОсновнойПроект")
		ИЛИ ВРег(Настройка) = ВРег("ОсновнойЯзык") Тогда
		
		ХранилищеОбщихНастроек.Сохранить(ВРег(Настройка),, Значение,, Пользователь);
		
		Если ВРег(Настройка) = ВРег("ОсновнойЯзык")  Тогда
			
			УстановитьПривилегированныйРежим(Истина);
			ПараметрыСеанса.ЯзыкОтчетности = Значение;
			УстановитьПривилегированныйРежим(Ложь);
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ЦФОПоУмолчанию(Пользователь) Экспорт
	
	ЗначениеПоУмолчанию = Справочники.Организации.ПустаяСсылка();
	
	ОсновнойЦФО = ХранилищеОбщихНастроек.Загрузить("ОсновнойЦФО",,, Пользователь);
	
	Если ТипЗнч(ОсновнойЦФО) = Тип("СправочникСсылка.Организации") Тогда
		// Проверка наличия ссылки и прав доступа
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ОсновнойЦФО", ОсновнойЦФО);
		Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		|	Организации.Ссылка КАК ЦФО
		|ИЗ
		|	Справочник.Организации КАК Организации
		|ГДЕ
		|	Организации.Ссылка = &ОсновнойЦФО";
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			ЗначениеПоУмолчанию = Выборка.ЦФО;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеПоУмолчанию;
	
КонецФункции

Функция ЯзыкПоУмолчанию(Пользователь) Экспорт
	
	ЗначениеПоУмолчанию = 0;
	
	ОсновнойЯзык= ХранилищеОбщихНастроек.Загрузить("ОсновнойЯзык",,, Пользователь);
	
	Если ЗначениеЗаполнено(ОсновнойЯзык) Тогда
		
		ЗначениеПоУмолчанию=ОсновнойЯзык;
		
	Иначе
		
		ЗначениеПоУмолчанию=ПолучитьНомерЯзыка(ПользователиИнформационнойБазы.ТекущийПользователь().Язык);
		
	КонецЕсли;	
		
	Возврат ЗначениеПоУмолчанию;
	
КонецФункции

Функция ПолучитьНомерЯзыка(Язык) Экспорт
	
	НомерЯзыка=0;
	
	Если Язык=Неопределено ИЛИ Язык=Метаданные.ОсновнойЯзык Тогда 
		
		Возврат НомерЯзыка;
		
	Иначе
		
		КодЯзыка=Язык.КодЯзыка;
		
	КонецЕсли;
	
	ТаблицаЯзыков=Константы.ДополнительныеЯзыкиВыводаОтчета.Получить().Получить();
	
	Если НЕ ТипЗнч(ТаблицаЯзыков)=Тип("ТаблицаЗначений") Тогда
		
		ТаблицаЯзыков=Новый ТаблицаЗначений;
		ТаблицаЯзыков.Колонки.Добавить("ПорядковыйНомер",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10));
		ТаблицаЯзыков.Колонки.Добавить("КодЯзыка",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(2));
		ТаблицаЯзыков.Колонки.Добавить("НаименованиеЯзыка",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(150));
		
		НоваяСтрока=ТаблицаЯзыков.Добавить();
		НоваяСтрока.КодЯзыка=Язык.КодЯзыка;
		НоваяСтрока.НаименованиеЯзыка=Язык.Синоним;
		НоваяСтрока.ПорядковыйНомер=1;
		
		Константы.ДополнительныеЯзыкиВыводаОтчета.Установить(Новый ХранилищеЗначения(ТаблицаЯзыков));
		Константы.ИспользоватьДополнительныеЯзыкиПредставления.Установить(Истина);
		
		Возврат 1;
		
	КонецЕсли;

	Для Каждого Строка ИЗ ТаблицаЯзыков Цикл
		
		Если ВРег(Строка.КодЯзыка)=ВРег(КодЯзыка) Тогда
			
			НомерЯзыка=Строка.ПорядковыйНомер;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
			
	Возврат НомерЯзыка;
	
КонецФункции // ПолучитьНомерЯзыка()

Функция ПроектПоУмолчанию(Пользователь) Экспорт
	
	ЗначениеПоУмолчанию = Справочники.Проекты.ПустаяСсылка();
	
	ОсновнойПроект = ХранилищеОбщихНастроек.Загрузить("ОсновнойПроект",,, Пользователь);
	
	Если ТипЗнч(ОсновнойПроект) = Тип("СправочникСсылка.Проекты") Тогда
		// Проверка наличия ссылки и прав доступа
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ОсновнойПроект", ОсновнойПроект);
		Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		|	Проекты.Ссылка КАК Проект
		|ИЗ
		|	Справочник.Проекты КАК Проекты
		|ГДЕ
		|	Проекты.Ссылка = &ОсновнойПроект";
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			ЗначениеПоУмолчанию = Выборка.Проект;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеПоУмолчанию;
	
КонецФункции

#КонецОбласти

#Область ОписанияТипов

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	ИначеЕсли (ЗаданныйТип = Неопределено) ИЛИ (ЗаданныйТип = Тип("Неопределено")) Тогда	
		Возврат Неопределено;
	Иначе
		
		Попытка
			Возврат Новый (ЗаданныйТип);
		Исключение
			Возврат Неопределено;
		КонецПопытки;
		
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

Функция ПолучитьОписаниеТипаПоТипуПоказателя(ТипЗначенияПоказателя) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОписаниеТипаПоТипуПоказателя(ТипЗначенияПоказателя);
	
КонецФункции // ПолучитьОписаниеТипаПоТипуПоказателя() 

Функция ПолучитьПустоеЗначениеПоТипуПоказателя(ТипЗначенияПоказателя) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьПустоеЗначениеПоТипуПоказателя(ТипЗначенияПоказателя);
	
КонецФункции // ПолучитьОписаниеТипаПоТипуПоказателя()

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОписаниеТиповСтроки(ДлинаСтроки);
	
КонецФункции // ПолучитьОписаниеТиповСтроки()	 

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Знач Разрядность, Знач РазрядностьДробнойЧасти=0, Знач ДопустимыйЗнакЧисла = Неопределено) Экспорт
	
	Возврат ОбщегоНазначения.ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти, ДопустимыйЗнакЧисла);
	
КонецФункции	// ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов ссылочного значения
// по переданному строковому описанию
// 
// Параметры:
//  ТекстОписание 			- строка
// Возвращаемое значение:
//  Объект "ОписаниеТипов" описанного ссылочного объекта метаданных.
//
Функция ПолучитьОписаниеТиповСсылка(ТекстОписание) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОписаниеТиповСсылка(ТекстОписание);
	
КонецФункции	// ПолучитьОписаниеТиповЧисла()

Функция ПолучитьОписаниеТиповПоОбъекту(Объект) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(ТипЗнч(Объект));
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции	// ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов булево.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" булева типа.
//
Функция ПолучитьОписаниеТиповБулево() Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОписаниеТиповБулево();
	
КонецФункции // ПолучитьОписаниеТиповБулево() 

// Служебная функция, предназначенная для получения описания типов таблица значений.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" булева типа.
//
Функция ПолучитьОписаниеТиповТЗ() Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОписаниеТиповТЗ();
	
КонецФункции // ПолучитьОписаниеТиповБулево()

// Служебная функция, предназначенная для получения описания типов список значений.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" булева типа.
//
Функция ПолучитьОписаниеТиповСписокЗначений() Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОписаниеТиповСписокЗначений();
	
КонецФункции // ПолучитьОписаниеТиповБулево()

// Служебная функция, предназначенная для получения описания типов структура.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" типа Структура
//
Функция ПолучитьОписаниеТиповСтруктура() Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОписаниеТиповСтруктура();
	
КонецФункции // ПолучитьОписаниеТиповСтруктура()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));
	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);
	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);
	
КонецФункции	// ПолучитьОписаниеТиповДаты()

// Служебная функция, определяющая примитивность переданного типа
//
Функция ПримитивныйТип(Тип) Экспорт
	
	Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.ПримитивныйТип(Тип);	
	
КонецФункции

// Служебная функция, определяющая примитивность переданного типа
//
Функция ПримитивныйТипСтрока(СтрокаТип) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПримитивныйТипСтрока(СтрокаТип);
	
КонецФункции

Функция ПолучитьТипЗначенияПоказателяПоСтроке(СтрокаТип) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьТипЗначенияПоказателяПоСтроке(СтрокаТип);
	
КонецФункции

Функция ПолучитьТипЗначенияПоказателяПоТипу(Тип) Экспорт
	
	Если Тип=Тип("Строка") Тогда
		Возврат Перечисления.ТипыЗначенийПоказателейОтчетов.Строка;
	ИначеЕсли Тип=Тип("Дата") Тогда
		Возврат Перечисления.ТипыЗначенийПоказателейОтчетов.Дата;
	ИначеЕсли Тип=Тип("Булево") Тогда
		Возврат Перечисления.ТипыЗначенийПоказателейОтчетов.Булево;
	Иначе
		Возврат Перечисления.ТипыЗначенийПоказателейОтчетов.Число;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьПолноеИмяПоТипу(Тип) Экспорт
	Возврат Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
КонецФункции

Функция ПолучитьОбъектМетаданныхПоТаблицеАналитики(ТаблицаАналитики) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОбъектМетаданныхПоТаблицеАналитики(ТаблицаАналитики);
	
КонецФункции // ПолучитьОбъектМетаданныхПоТаблице() 

Функция ПолучитьОписаниеПримитивногоТипаИзСтроки(МассивТиповВИБ) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОписаниеПримитивногоТипаИзСтроки(МассивТиповВИБ);
	
КонецФункции

Функция ПолучитьОписаниеПримитивногоТипаИзТипаЗначения(ТипЗначения) Экспорт
	
	МассивТипов=Новый Массив;
	
	Для Каждого СтрТип Из ТипЗначения.Типы() Цикл
		
		Если СтрТип=Тип("Строка") ИЛИ СтрТип = Тип("Число") ИЛИ СтрТип = Тип("Дата") ИЛИ СтрТип = Тип("Булево") Тогда
			
			МассивТипов.Добавить(СтрТип)
			
		КонецЕсли;	
		
	КонецЦикла;
	
	Если МассивТипов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТК_Числа = Новый КвалификаторыЧисла(18, 5, ДопустимыйЗнак.Любой);	
	ТК_Строки = Новый КвалификаторыСтроки(150, ДопустимаяДлина.Переменная);
	ТК_Даты   = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
	
	Возврат Новый ОписаниеТипов(МассивТипов, ТК_Числа, ТК_Строки, ТК_Даты);
	
КонецФункции

Функция ПолучитьДанныеТипа(СтрокаТип) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьДанныеТипа(СтрокаТип);
	
КонецФункции // ПолучитьДанныеТипа()

Функция ПреобразоватьТипИзСтроки(Тип,ВозвращатьТип=Истина,ТолькоПримитивные=Истина) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПреобразоватьТипИзСтроки(Тип,ВозвращатьТип,ТолькоПримитивные);
	
КонецФункции // ПреобразоватьТипИзСтроки()

Функция ПолучитьОписаниеТиповИзСтрокиТипов(СтрокаТипов) Экспорт
	
	Возврат КэшируемыеПроцедурыУХ.ПолучитьОписаниеТиповИзСтрокиТипов(СтрокаТипов);
		
КонецФункции // ПолучитьОписаниеТиповИзСтрокиТипов() 

Функция ПолучитьВидСубконтоУХПоТипу(ИсходныйТип) Экспорт
	
	ТекВидыСубконто=ПланыВидовХарактеристик.ВидыСубконтоКорпоративные.Выбрать();
	
	Пока ТекВидыСубконто.Следующий() Цикл
		
		Если ТекВидыСубконто.ТипЗначения.СодержитТип(ИсходныйТип) Тогда
			
			Возврат ТекВидыСубконто.Ссылка;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
		
КонецФункции // ПолучитьВидСубконтоПоТипу()

Функция ПолучитьСписокИзТипа(ИсходныйТип) Экспорт
	
	СписокТипов=Новый СписокЗначений;
	
	Если ТипЗнч(ИсходныйТип)=Тип("Строка") Тогда
		
		РабочийТип=Тип(ИсходныйТип);
		СписокТипов.Добавить(РабочийТип);
		
	Иначе
		
		СписокТипов.Добавить(ИсходныйТип);
		
	КонецЕсли;
	
	Возврат СписокТипов;
	
КонецФункции // ПолучитьСписокИзТипа() 

Функция ПреобразоватьТИПизВИБ(База, Тип,ВозвращатьТип=Истина)
	
	Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.ПреобразоватьТИПизВИБ(База, Тип,ВозвращатьТип);
		
КонецФункции // ПреобразоватьТИПизВИБ()

Функция ВыполнитьПреобразованиеТипов(Значение,ИсходныйТип,РезультирующийТип) Экспорт
	
	Если ИсходныйТип="Строка" и РезультирующийТип="Дата" Тогда
		
		Если Не ЗначениеЗаполнено(ИсходныйТип) Тогда
			
			Возврат '00010101';
			
		КонецЕсли;
		
		МассивДата=РазложитьСтрокуВМассивПодстрок(Значение," ");
		
		ДанныеДня=МассивДата[0];
		
		Если СтрНайти(ДанныеДня,".")>0 Тогда
			
			ЧастиДня=ОбщегоНазначенияУХ.РазложитьСтрокуВМассивПодстрок(ДанныеДня,".");
			
		ИначеЕсли СтрНайти(ДанныеДня,"/")>0 Тогда
			
			ЧастиДня=ОбщегоНазначенияУХ.РазложитьСтрокуВМассивПодстрок(ДанныеДня,"/");
			
		Иначе // Используется неизвестный разделитель
			
			Возврат Неопределено;
			
		КонецЕсли;
		
		Если ЧастиДня.Количество()=1 Тогда // Не удалось разобрать литерал
			
			Возврат Неопределено;
			
		КонецЕсли;
		
		День=Число(?(СтрДлина(ЧастиДня[0])=1,"0"+ЧастиДня[0],ЧастиДня[0]));
		Месяц=Число(?(СтрДлина(ЧастиДня[1])=1,"0"+ЧастиДня[1],ЧастиДня[1]));
		
		Если ЧастиДня.Количество()=2 Тогда
			
			Год=Год(ТекущаяУниверсальнаяДата());
			
		Иначе
			
			Год=Число(?(СтрДлина(ЧастиДня[2])=2,"20"+ЧастиДня[2],ЧастиДня[2]));
			
		КонецЕсли;
		
		Возврат Дата(Год,Месяц,День);
		
	ИначеЕсли ИсходныйТип="Строка" и РезультирующийТип="Число" Тогда
		
		Если Не ЗначениеЗаполнено(Значение) Тогда
			
			Возврат 0;
			
		Иначе
			
			Попытка
				
				Возврат Число(СтрЗаменить(Значение," ",""));
				
			Исключение
				
				Возврат Неопределено;
				
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЕсли;	
	
КонецФункции // ВыполнитьПреобразованиеТипов() 
	
#КонецОбласти

#Область ИменаМетаданных

Функция ИмяТипаРегистрыСведений() Экспорт
	
	Возврат "РегистрыСведений";
	
КонецФункции

Функция ИмяТипаРегистрыНакопления() Экспорт
	
	Возврат "РегистрыНакопления";
	
КонецФункции

Функция ИмяТипаРегистрыБухгалтерии() Экспорт
	
	Возврат "РегистрыБухгалтерии";
	
КонецФункции

Функция ИмяТипаРегистрыРасчета() Экспорт
	
	Возврат "РегистрыРасчета";
	
КонецФункции

Функция ИмяТипаДокументы() Экспорт
	
	Возврат "Документы";
	
КонецФункции

Функция ИмяТипаСправочники() Экспорт
	
	Возврат "Справочники";
	
КонецФункции

Функция ИмяТипаПланыОбмена() Экспорт
	
	Возврат "ПланыОбмена";
	
КонецФункции

Функция ИмяТипаПланыВидовХарактеристик() Экспорт
	
	Возврат "ПланыВидовХарактеристик";
	
КонецФункции

Функция ИмяТипаБизнесПроцессы() Экспорт
	
	Возврат "БизнесПроцессы";
	
КонецФункции

Функция ИмяТипаЗадачи() Экспорт
	
	Возврат "Задачи";
	
КонецФункции

Функция ИмяТипаПланыСчетов() Экспорт
	
	Возврат "ПланыСчетов";
	
КонецФункции

Функция ИмяТипаПланыВидовРасчета() Экспорт
	
	Возврат "ПланыВидовРасчета";
	
КонецФункции
	
#КонецОбласти

#Область Мультиязычность

Процедура ПодготовитьПолеВыбораЯзыка(ПолеВыбораЯзыка, ЗначениеЯзык) Экспорт

	ТабЯзыки = ОбщегоНазначенияУХ.ПолучитьЗначениеПеременной("глТаблицаЯзыков");
	
	ПолеВыбораЯзыка.СписокВыбора.Очистить();
	Если ТабЯзыки.Количество() = 0 Тогда
		
		ЗначениеЯзык = 0;
		ПолеВыбораЯзыка.Видимость = Ложь;
		
	Иначе	
		
		Для каждого СтрЯзык Из ТабЯзыки Цикл
			ПолеВыбораЯзыка.СписокВыбора.Добавить(СтрЯзык.ПорядковыйНомер, СтрЯзык.КодЯзыка);
		КонецЦикла;
		
	КонецЕсли;		

КонецПроцедуры

#КонецОбласти

#Область ДвиженияДокумента

// Функция возвращает список регистров, движения по которым нужно удалять в привилегированном модуле
//
// Параметры
//  ДокументСсылка - ссылка на документ
//
// Возвращаемое значение:
//   Структура - содержит список регистров
//
Функция ОпределитьСписокРегистровСБезусловнымУдалениемДвижений(ДокументСсылка)
	РегистрыКБезусловномуУдалению = Новый Структура();
	
	РегистрыКБезусловномуУдалению.Вставить("БракВПроизводстве");
	РегистрыКБезусловномуУдалению.Вставить("Затраты");
	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНаСтроительствоОбъектовОсновныхСредств");
	РегистрыКБезусловномуУдалению.Вставить("НезавершенноеПроизводство");
	РегистрыКБезусловномуУдалению.Вставить("ОССписанныеНаЗатраты");
	РегистрыКБезусловномуУдалению.Вставить("ПартииМатериаловВЭксплуатации");
	РегистрыКБезусловномуУдалению.Вставить("ПартииТоваровНаСкладах");
	РегистрыКБезусловномуУдалению.Вставить("ПартииТоваровПереданные");
	РегистрыКБезусловномуУдалению.Вставить("ПродажиСебестоимость");
	РегистрыКБезусловномуУдалению.Вставить("РеализованныеТовары");
	РегистрыКБезусловномуУдалению.Вставить("СтоимостьОС");
	РегистрыКБезусловномуУдалению.Вставить("СтроительствоОбъектовОсновныхСредств");
	РегистрыКБезусловномуУдалению.Вставить("БракВПроизводствеБухгалтерскийУчет");
	РегистрыКБезусловномуУдалению.Вставить("БракВПроизводствеНалоговыйУчет");
	РегистрыКБезусловномуУдалению.Вставить("ЗатратыБухгалтерскийУчет");
	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНалоговыйУчет");
	РегистрыКБезусловномуУдалению.Вставить("НДСВключенныйВСтоимость");
	РегистрыКБезусловномуУдалению.Вставить("НДСКосвенныеРасходы");
	РегистрыКБезусловномуУдалению.Вставить("НДСНачисленный");
	РегистрыКБезусловномуУдалению.Вставить("НДСНезавершенноеПроизводство");
	РегистрыКБезусловномуУдалению.Вставить("НДСПартииТоваров");	
	РегистрыКБезусловномуУдалению.Вставить("НДСПредъявленный");
	РегистрыКБезусловномуУдалению.Вставить("НДСПредъявленныйРеализация0");
	РегистрыКБезусловномуУдалению.Вставить("НДСРасчетыСПокупателями");
	РегистрыКБезусловномуУдалению.Вставить("НДСРеализация0");
	РегистрыКБезусловномуУдалению.Вставить("НезавершенноеПроизводствоБухгалтерскийУчет");
	РегистрыКБезусловномуУдалению.Вставить("НезавершенноеПроизводствоНалоговыйУчет");
	РегистрыКБезусловномуУдалению.Вставить("ОССписанныеНаЗатратыОрганизаций");
	РегистрыКБезусловномуУдалению.Вставить("ПартииМатериаловВЭксплуатацииБухгалтерскийУчет");
	РегистрыКБезусловномуУдалению.Вставить("ПартииМатериаловВЭксплуатацииНалоговыйУчет");
	РегистрыКБезусловномуУдалению.Вставить("ПартииТоваровНаСкладахБухгалтерскийУчет");
	РегистрыКБезусловномуУдалению.Вставить("ПартииТоваровНаСкладахНалоговыйУчет");
	РегистрыКБезусловномуУдалению.Вставить("ПартииТоваровПереданныеБухгалтерскийУчет");
	РегистрыКБезусловномуУдалению.Вставить("ПартииТоваровПереданныеНалоговыйУчет");
	РегистрыКБезусловномуУдалению.Вставить("СтоимостьОСБухгалтерскийУчет");
	РегистрыКБезусловномуУдалению.Вставить("СвободныеОстатки");
	
	РегистрыКБезусловномуУдалению.Вставить("УчетЗатрат");
	РегистрыКБезусловномуУдалению.Вставить("УчетЗатратРегл");
	
	ТипДокумента = ТипЗНЧ(ДокументСсылка);
	//Если ТипДокумента = Тип("ДокументСсылка.АктОбОказанииПроизводственныхУслуг")
	// ИЛИ ТипДокумента = Тип("ДокументСсылка.ОтчетПроизводстваЗаСмену")
	// ИЛИ ТипДокумента = Тип("ДокументСсылка.ПоступлениеТоваровИзПереработки")
	// ИЛИ ТипДокумента = Тип("ДокументСсылка.КомплектацияНоменклатуры")
	//Тогда
	//	РегистрыКБезусловномуУдалению.Вставить("ВыпускПродукции");
	//	РегистрыКБезусловномуУдалению.Вставить("ВыпускПродукцииБухгалтерскийУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("ВыпускПродукцииНалоговыйУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНаВыпускПродукции");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНаВыпускПродукцииБухгалтерскийУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНаВыпускПродукцииНалоговыйУчет");
	//	
	//	РегистрыКБезусловномуУдалению.Вставить("ВыпускПродукцииНаработка");
	//	РегистрыКБезусловномуУдалению.Вставить("ВыпускПродукцииНаработкаБухгалтерскийУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("ВыпускПродукцииНаработкаНалоговыйУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНаВыпускПродукцииНаработка");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНаВыпускПродукцииНаработкаБухгалтерскийУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНаВыпускПродукцииНаработкаНалоговыйУчет");
	//	
	//	РегистрыКБезусловномуУдалению.Вставить("ПродажиСебестоимость");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНаСтроительствоОбъектовОсновныхСредств");
	//	РегистрыКБезусловномуУдалению.Вставить("ТоварыНаСкладах");
	//	РегистрыКБезусловномуУдалению.Вставить("ТоварыОрганизаций");
	//	РегистрыКБезусловномуУдалению.Вставить("ТоварыВРезервеНаСкладах");
	//	
	//	РегистрыКБезусловномуУдалению.Вставить("НезавершенноеПроизводство");
	//	РегистрыКБезусловномуУдалению.Вставить("НезавершенноеПроизводствоБухгалтерскийУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("НезавершенноеПроизводствоНалоговыйУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("МатериалыВПроизводстве");
	//	
	//	РегистрыКБезусловномуУдалению.Вставить("Затраты");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗатратыБухгалтерскийУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗатратыНалоговыйУчет");
	//	
	//	РегистрыКБезусловномуУдалению.Вставить("БракВПроизводстве");
	//	РегистрыКБезусловномуУдалению.Вставить("БракВПроизводствеБухгалтерскийУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("БракВПроизводствеНалоговыйУчет");
	//	
	//	РегистрыКБезусловномуУдалению.Вставить("ПартииТоваровНаСкладах");
	//	РегистрыКБезусловномуУдалению.Вставить("ПартииТоваровНаСкладахБухгалтерскийУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("ПартииТоваровНаСкладахНалоговыйУчет");
	//	РегистрыКБезусловномуУдалению.Вставить("НДСПартииТоваров");
	//	РегистрыКБезусловномуУдалению.Вставить("СтроительствоОбъектовОсновныхСредств");
	//	РегистрыКБезусловномуУдалению.Вставить("ЗаказыНаОбслуживаниеОС");
	//	
	//КонецЕсли;
	
	Если РегистрыКБезусловномуУдалению.Количество() = 0 Тогда
		Возврат Неопределено;
	Иначе	
		Возврат	РегистрыКБезусловномуУдалению;
	КонецЕсли;	
КонецФункции

// Получает массив регистров, по которым можно не очищать движения
Функция ПолучитьСписокРегистровДляОчисткиДвижений(ТекущийРежимПроведенияДокумента)
	СписокРегистров = новый Структура();
	СписокРегистров.Вставить("ДвиженияДенежныхСредств");
	СписокРегистров.Вставить("Закупки");
	СписокРегистров.Вставить("ЗатратыОбороты");
	СписокРегистров.Вставить("Продажи");
	
	Если ТекущийРежимПроведенияДокумента = РежимПроведенияДокумента.Неоперативный Тогда
		СписокРегистров.Вставить("ВзаиморасчетыСКонтрагентами");
		СписокРегистров.Вставить("ДенежныеСредства");
		СписокРегистров.Вставить("ЗаказыПоставщикам");
		СписокРегистров.Вставить("РазмещениеЗаказовПокупателей");
		СписокРегистров.Вставить("РасчетыСКонтрагентами");
		СписокРегистров.Вставить("ТоварыВНТТ");
		СписокРегистров.Вставить("ТоварыВРезервеНаСкладах");
		СписокРегистров.Вставить("ТоварыВРознице");
		СписокРегистров.Вставить("ТоварыКПередачеОрганизаций");
		СписокРегистров.Вставить("ТоварыКПередачеСоСкладов");
		СписокРегистров.Вставить("ТоварыКПеремещениюВНТТ");
		СписокРегистров.Вставить("ТоварыКПолучениюНаСклады");
		СписокРегистров.Вставить("ТоварыНаСкладах");
		СписокРегистров.Вставить("ТоварыОрганизаций");
		СписокРегистров.Вставить("ТоварыПереданные");
		СписокРегистров.Вставить("ТоварыПолученные");
	КонецЕсли;
	Возврат СписокРегистров;
КонецФункции

Функция ПолучитьСписокРегистровНеОчищатьКОллекцию(ТекущийРежимПроведенияДокумента)
	СписокРегистров = новый Структура();
	
	СписокРегистров.Вставить("ВыпускПродукции");
	СписокРегистров.Вставить("ВыпускПродукцииБухгалтерскийУчет");
	СписокРегистров.Вставить("ВыпускПродукцииМеждународныйУчет");
	СписокРегистров.Вставить("ВыпускПродукцииНалоговыйУчет");
	СписокРегистров.Вставить("ЗатратыМеждународныйУчет");
	СписокРегистров.Вставить("ЗатратыНаВыпускПродукции");
	СписокРегистров.Вставить("ЗатратыНаВыпускПродукцииБухгалтерскийУчет");
	СписокРегистров.Вставить("ЗатратыНаВыпускПродукцииМеждународныйУчет");
	СписокРегистров.Вставить("ЗатратыНаВыпускПродукцииНалоговыйУчет");
	СписокРегистров.Вставить("ЗатратыНаВыпускПродукцииНаработка");
	СписокРегистров.Вставить("ЗатратыНаВыпускПродукцииНаработкаБухгалтерскийУчет");
	СписокРегистров.Вставить("ЗатратыНаВыпускПродукцииНаработкаНалоговыйУчет");
	СписокРегистров.Вставить("НезавершенноеПроизводствоМеждународныйУчет");
	
	Если ТекущийРежимПроведенияДокумента = РежимПроведенияДокумента.Неоперативный Тогда
		СписокРегистров.Вставить("ВыпускПродукцииНаработка");
		СписокРегистров.Вставить("ВыпускПродукцииНаработкаБухгалтерскийУчет");
		СписокРегистров.Вставить("ВыпускПродукцииНаработкаНалоговыйУчет");
		СписокРегистров.Вставить("МатериалыВПроизводстве");
		СписокРегистров.Вставить("СвободныеОстатки");
		
	КонецЕсли;
	Возврат СписокРегистров;
	
КонецФункции


// Процедура удаления существующих движений документа при перепроведении (отмене проведения)
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, СтруктураВидовУчета = Неопределено, ВыборочноОчищатьРегистры = Ложь, РежимПроведенияДокумента=неопределено) Экспорт
	БыстроеПерепроведениеДокументов = ложь;
	
	МассивОбрабатываемыхСтрокТаблицыДвижений = Новый Массив();
	
	// получение списка регистров, по которым существуют движения
	ТаблицаДвижений = ПолныеПраваУХ.ОпределитьНаличиеДвиженийПоРегистратору(ДокументОбъект.Ссылка);
	
	РегистрыДляОчисткиДвижений = новый Структура();
	РегистрыДляОчисткиДвижений_НеОчищатьКоллекцию = новый Структура;
	Если БыстроеПерепроведениеДокументов И ТаблицаДвижений.Количество()>0 Тогда
		РегистрыДляОчисткиДвижений 						= ПолучитьСписокРегистровДляОчисткиДвижений(РежимПроведенияДокумента);
		РегистрыДляОчисткиДвижений_НеОчищатьКоллекцию 	= ПолучитьСписокРегистровНеОчищатьКОллекцию(РежимПроведенияДокумента);
	КонецЕсли;
	
	РегистрыКБезусловномуУдалению = ОпределитьСписокРегистровСБезусловнымУдалениемДвижений(ДокументОбъект.Ссылка);
	
	ТаблицаДвижений.Колонки.Добавить("НаборЗаписей");
	ТаблицаДвижений.Колонки.Добавить("БезусловноеУдаление", 	Новый ОписаниеТипов("Булево"));
	ТаблицаДвижений.Колонки.Добавить("БыстроеПерепроведение", 	Новый ОписаниеТипов("Булево"));
	ТаблицаДвижений.Колонки.Добавить("НеОчищатьКоллекцию", 		Новый ОписаниеТипов("Булево"));
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		// имя регистра передается как значение, полученное с помощью
		// функции ПолноеИмя() метаданных регистра
		ПозицияТочки = СтрНайти(СтрокаДвижения.Имя, ".");
		ТипРегистра = Лев(СтрокаДвижения.Имя, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(СтрокаДвижения.Имя, ПозицияТочки + 1));
		
		// необходимо очищать только те регистры, которые относятся к видам учета по которым перепроводиться документ
		
		МассивОбрабатываемыхСтрокТаблицыДвижений.Добавить(СтрокаДвижения);
		
		Если (НЕ РегистрыКБезусловномуУдалению = Неопределено) И РегистрыКБезусловномуУдалению.Свойство(ИмяРегистра) Тогда
			СтрокаДвижения.БезусловноеУдаление = Истина;
			Набор = ИмяРегистра;
		Иначе
			//проверка доступа к таблице регистра
			Если ТипРегистра = "РегистрНакопления" Тогда
				МетаданныеНабора 	= Метаданные.РегистрыНакопления[ИмяРегистра];
				МенеджерНабора 		= РегистрыНакопления[ИмяРегистра];
			ИначеЕсли ТипРегистра = "РегистрБухгалтерии" Тогда
				МетаданныеНабора 	= Метаданные.РегистрыБухгалтерии[ИмяРегистра];
				МенеджерНабора 		= РегистрыБухгалтерии[ИмяРегистра];
			ИначеЕсли ТипРегистра = "РегистрСведений" Тогда
				МетаданныеНабора 	= Метаданные.РегистрыСведений[ИмяРегистра];
				МенеджерНабора 		= РегистрыСведений[ИмяРегистра];
			ИначеЕсли ТипРегистра = "РегистрРасчета" Тогда
				МетаданныеНабора 	= Метаданные.РегистрыРасчета[ИмяРегистра];
				МенеджерНабора 		= РегистрыРасчета[ИмяРегистра];
			КонецЕсли;
			Если НЕ ПравоДоступа("Изменение", МетаданныеНабора) Тогда
				// отсутствуют права на всю таблицу регистра
				СообщитьОбОшибке(Нстр("ru = 'Нарушение прав доступа'"), Отказ, СтрокаДвижения.Имя);
				Возврат;
			КонецЕсли;
			
			Если БыстроеПерепроведениеДокументов И РегистрыДляОчисткиДвижений.Свойство(ИмяРегистра) Тогда
				СтрокаДвижения.БыстроеПерепроведение = Истина;
				Набор = ИмяРегистра;
			ИначеЕсли БыстроеПерепроведениеДокументов И РегистрыДляОчисткиДвижений_НеОчищатьКоллекцию.Свойство(ИмяРегистра) Тогда
				СтрокаДвижения.НеОчищатьКоллекцию = Истина;
				Набор = ИмяРегистра;
			Иначе 
				Набор = МенеджерНабора.СоздатьНаборЗаписей();	
				Набор.Отбор.Регистратор.Установить(ДокументОбъект.Ссылка);			
			КонецЕсли;
		КонецЕсли;
		
		
		// набор не записывается сразу, чтобы не откатывать транзакцию, если впоследствии
		// выяснится, что на один из регистров не хватает прав.		
		СтрокаДвижения.НаборЗаписей = Набор;		
		
	КонецЦикла;	
	
	Для Каждого СтрокаДвижения ИЗ МассивОбрабатываемыхСтрокТаблицыДвижений Цикл
		Если СтрокаДвижения.БезусловноеУдаление Тогда
			ЗаписатьНаборЗаписейНаСервере(СтрокаДвижения.НаборЗаписей, ДокументОбъект.Ссылка);
		ИначеЕсли СтрокаДвижения.НеОчищатьКоллекцию Тогда
			//ничего не делаем	
		ИначеЕсли СтрокаДвижения.БыстроеПерепроведение Тогда
			ДокументОбъект.Движения[СтрокаДвижения.НаборЗаписей].Очистить();
		Иначе
			Попытка
				СтрокаДвижения.НаборЗаписей.Записать();
			Исключение
				// возможно «сработал» RLS или механизм даты запрета изменения
				СообщитьОбОшибке(ОписаниеОшибки(), Отказ, СтрокаДвижения.Имя);
				ВызватьИсключение Нстр("ru = 'Операция не выполнена'");
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
	//Если требуется очищать регистры, то нужно проверять количество записей в наборе перед очисткой
	ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
	
	
КонецПроцедуры

// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	ПустыеКолонкиСоставногоТипа = Неопределено) Экспорт
	
	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	//
	КолонкиТаблицы = ТаблицаДвижений.Колонки;
	
	//
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	ИзмеренияСостТипаСтр = "";
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
			И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаИзм.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаИзм.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
			И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРек.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРек.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРек.Имя;
			КонецЕсли; 
			
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
			И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРес.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРес.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРес.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	
	Если ИзмеренияСостТипаСтр <> "" Тогда
		ИзмеренияСостТипаСтр = Сред(ИзмеренияСостТипаСтр, 3);
	КонецЕсли;
	
	ТипЧисло = Тип("Число");
	ТипСтрока = Тип("Строка");
	ТипДата = Тип("Дата");
	
	ЕстьПериод = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;
	
	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		Движение = НаборДвижений.Добавить();
		ЗаполнитьЗначенияСвойств(Движение, СтрокаДвижения, ,ИзмеренияСостТипаСтр);
		
		Если ВидДвижения <> Неопределено Тогда
			Движение.ВидДвижения = ВидДвижения;
		КонецЕсли;
		
		Если ЕстьПериод И НЕ СтрокаДвижения.Период = '00010101000000' Тогда
			Движение.Период = СтрокаДвижения.Период;
		ИначеЕсли НаборДвижений.мПериод <> Неопределено Тогда
			Движение.Период = НаборДвижений.мПериод;
		КонецЕсли; 
		Движение.Активность = Истина;
		
		Для Каждого КлючИЗначение ИЗ ИзмеренияСостТипа Цикл
			ЗначениеВКолонке = СтрокаДвижения[КлючИЗначение.Ключ];
			
			Если ЗначениеВКолонке = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗначенияВКолонке = ТипЗнч(ЗначениеВКолонке);
			
			Если ТипЗначенияВКолонке = ТипЧисло Тогда
				Если ЗначениеВКолонке = 0 Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипСтрока Тогда
				Если ЗначениеВКолонке = "" Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипДата Тогда
				Если ЗначениеВКолонке = '00010101000000' Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ЗначениеВКолонке.Пустая() Тогда
				Продолжить;
			КонецЕсли;
			
			Движение[КлючИЗначение.Ключ] = ЗначениеВКолонке;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

Процедура ЗаписатьНаборЗаписейНаСервере(ИмяРегистра, Регистратор, ТаблицаДвижений = Неопределено) Экспорт	
	
	Набор = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
	Набор.Отбор.Регистратор.Установить(Регистратор);
	Если ТаблицаДвижений <> Неопределено Тогда
		Набор.мТаблицаДвижений = ТаблицаДвижений;
		ВыполнитьДвижениеПоРегистру(Набор);
	КонецЕсли;
	Набор.Записать();
	
КонецПроцедуры

// Процедура очищает коллекцию движений документа
//
Процедура ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект)
	
	Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
		Если Движение.Количество() > 0 Тогда
			Движение.Очистить();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры
	
#КонецОбласти

#Область СтатистическиеФункции

Функция МинимальноеЗначение(МассивЗначений) Экспорт
	
	Если МассивЗначений.Количество()=0 Тогда
		Возврат 0;
	КонецЕсли;
	
	ТекМинимум=МассивЗначений[0];
	
	Для Каждого Значение ИЗ МассивЗначений Цикл
		
		Если Значение<ТекМинимум Тогда
			
			ТекМинимум=Значение;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекМинимум;
	
КонецФункции // МинимальноеЗначение()

Функция МаксимальноеЗначение(МассивЗначений) Экспорт
	
	Если МассивЗначений.Количество()=0 Тогда
		Возврат 0;
	КонецЕсли;
	
	ТекМаксимум=МассивЗначений[0];
	
	Для Каждого Значение ИЗ МассивЗначений Цикл
		
		Если Значение>ТекМаксимум Тогда
			
			ТекМаксимум=Значение;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекМаксимум;
	
КонецФункции // МаксимальноеЗначение()

// Вычисляет среднеарифметическое значение всех элементов в числовом 
// массиве МассивЗначений. Когда массив пустой - возвращает 0.
Функция СреднеАрифметическоеЗначение(МассивЗначений) Экспорт
	
	Если МассивЗначений.Количество()=0 Тогда
		Возврат 0;
	КонецЕсли;
	СуммаЗначений = 0;
	КоличествоЗначений = 0;
	Для Каждого Значение ИЗ МассивЗначений Цикл
		СуммаЗначений = СуммаЗначений + Значение;
		КоличествоЗначений = КоличествоЗначений + 1;
	КонецЦикла;
	Если КоличествоЗначений = 0 Тогда
		Возврат 0;
	Иначе		
		Возврат СуммаЗначений / КоличествоЗначений;
	КонецЕсли;
	
КонецФункции // СреднеАрифметическоеЗначение()

// Вычисляет произведение значений всех элементов в числовом 
// массиве МассивЗначений. Когда массив пустой - возвращает 0.
Функция ПроизведениеЗначений(МассивЗначений) Экспорт
	Если МассивЗначений.Количество() = 0 Тогда
		Возврат 0;
	КонецЕсли;
	ПроизведениеИтог = 1;
	Для Каждого Значение ИЗ МассивЗначений Цикл
		ПроизведениеИтог = ПроизведениеИтог * Значение;
	КонецЦикла;
	Возврат ПроизведениеИтог;
КонецФункции // ПроизведениеЗначений()

Функция ВернутьМассивВероятностей(МассивЗначений) Экспорт
	
	Если МассивЗначений.Количество()=0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТабРасчета=Новый ТаблицаЗначений;
	ТабРасчета.Колонки.Добавить("ЗначениеВыборки");
	ТабРасчета.Колонки.Добавить("ВероятностьЗначения");
	
	// Округлим значения по погрешности выборки
	РазмахВыборки=МаксимальноеЗначение(МассивЗначений)-МинимальноеЗначение(МассивЗначений);
	
	Если РазмахВыборки=0 Тогда
		
		Погрешностьвыборки=0;
		РазрядностьПогрешности=0;
		
	Иначе
		
		ПогрешностьВыборки=?(РазмахВыборки<0,РазмахВыборки*-1,РазмахВыборки)/2;	
		
		Лог10Погрешности=Log10(ПогрешностьВыборки);
		
		РазрядностьПогрешности=Цел(Лог10Погрешности)-?(Лог10Погрешности<0,1,0);
		
	КонецЕсли;
	
	Для Каждого Значение ИЗ МассивЗначений Цикл
		
		НоваяСтрока=ТабРасчета.Добавить();
		НоваяСтрока.ЗначениеВыборки=Окр(Значение/Pow(10,РазрядностьПогрешности),0)*Pow(10,РазрядностьПогрешности);
		
	КонецЦикла;
	
	Для Индекс=0 По ТабРасчета.Количество()-1 Цикл
		
		ТекСтрока=ТабРасчета[Индекс];
		
		Если Не ЗначениеЗаполнено(ТекСтрока.ВероятностьЗначения) Тогда
			
			СтрокиЗначения=ТабРасчета.НайтиСтроки(Новый Структура("ЗначениеВыборки",ТекСтрока.ЗначениеВыборки));
			
			ВероятностьЗначения=СтрокиЗначения.Количество()/ТабРасчета.Количество();
			
			Для Каждого Строка ИЗ СтрокиЗначения Цикл
				
				Строка.ВероятностьЗначения=ВероятностьЗначения;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТабРасчета.ВыгрузитьКолонку("ВероятностьЗначения");	
	
КонецФункции // ВернутьМассивВероятностей()

Функция СтатистикаВыборки(МассивЗначений) Экспорт
	
	Если МассивЗначений.Количество()=0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураХарактеристик=Новый Структура;
	
	МассивВероятностей=ВернутьМассивВероятностей(МассивЗначений);
	
	Если МассивВероятностей=Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Определим математическое ожидание выборки
	
	МО=0;
	
	Для Индекс=0 По МассивВероятностей.Количество()-1 Цикл
		
		МО=МО+МассивЗначений[Индекс]*МассивВероятностей[Индекс];
		
	КонецЦикла;
	
	СтруктураХарактеристик.Вставить("МатематическоеОжидание",МО);
	
	// Определим дисперсию выборки
	
	Дисперсия=0;
	
	Для Индекс=0 По МассивВероятностей.Количество()-1 Цикл
		
		Дисперсия=Дисперсия+Pow((МассивЗначений[Индекс]-МО),2)*МассивВероятностей[Индекс];
		
	КонецЦикла;
	
	СтруктураХарактеристик.Вставить("Дисперсия",Дисперсия);
	
	СтруктураХарактеристик.Вставить("СКО",?(Дисперсия=0,0,Sqrt(Дисперсия)));
	
	Возврат СтруктураХарактеристик;	
	
КонецФункции // МатематическоеОжидание()

Функция ПолучитьСтатистикуПоПоказателю(СценарийБаза,ЭкземплярОтчета,Показатель,ГлубинаАнализа) Экспорт
	
	Запрос=Новый Запрос;
	
	АналитикВидаОтчета=ОбщегоНазначенияУХ.ВернутьКоличествоАналитикНаУровнеОтчета(Показатель.Владелец);
	
	Запрос.Текст="ВЫБРАТЬ
	|	СУММА(ЗначенияПоказателейОтчетов.Значение) КАК ЗначениеЧисло,
	|	ВерсииЗначенийПоказателей.ПериодОтчета
	|ИЗ
	|	РегистрСведений."+УправлениеОтчетамиУХ.ВернутьИмяТаблицыСинтетики(АналитикВидаОтчета)+" КАК ЗначенияПоказателейОтчетов
	|ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ВерсииЗначенийПоказателей КАК ВерсииЗначенийПоказателей
	|ПО ЗначенияПоказателейОтчетов.Версия=ВерсииЗначенийПоказателей.Ссылка
	|ГДЕ
	|	ВерсииЗначенийПоказателей.Организация = &Организация
	|	И ВерсииЗначенийПоказателей.Проект = &Проект
	|	И ВерсииЗначенийПоказателей.Сценарий = &Сценарий
	|	И ЗначенияПоказателейОтчетов.Показатель = &Показатель
	|	И ВерсииЗначенийПоказателей.Валюта = &Валюта
	|	И ВерсииЗначенийПоказателей.ПериодОтчета.Периодичность = &Периодичность
	|	И ВерсииЗначенийПоказателей.ПериодОтчета.ДатаНачала >= &ДатаНачала
	|
	|СГРУППИРОВАТЬ ПО
	|	ВерсииЗначенийПоказателей.ПериодОтчета";
	
	Запрос.УстановитьПараметр("Сценарий",СценарийБаза);
	Запрос.УстановитьПараметр("Организация",ЭкземплярОтчета.Организация);
	Запрос.УстановитьПараметр("Проект",ЭкземплярОтчета.Проект);
	Запрос.УстановитьПараметр("Показатель",Показатель);
	Запрос.УстановитьПараметр("Валюта",ЭкземплярОтчета.ОсновнаяВалюта);
	Запрос.УстановитьПараметр("Периодичность",ЭкземплярОтчета.ПериодОтчета.Периодичность);
	Запрос.УстановитьПараметр("ДатаНачала",ОбщегоНазначенияУХ.ДобавитьИнтервал(ЭкземплярОтчета.ПериодОтчета.ДатаНачала,ЭкземплярОтчета.ПериодОтчета.Периодичность,ГлубинаАнализа*-1));
	
	Возврат СтатистикаВыборки(Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ЗначениеЧисло"));
	
КонецФункции // ПолучитьСтатистикуПоПоказателю() 
	
#КонецОбласти

#Область ПорядокЭлементов
	
// Вспомогательная функция для определнения условий запроса в механизме
// изменения порядка следования элементов. Ставит условия на родителя и владельца
//
// Параметры
//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
//  Запрос - Запрос, в который дописываем условия
// 
//  Возвращаемое значение:
//   Строка - условие запроса
// 
Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)
	
	ТекстЗапроса = "";
	
	Если Элемент.Метаданные().Иерархический = Истина Тогда
		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
		Если НЕ БезПервогоИ Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";
	КонецЕсли; 
	
	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";
	КонецЕсли; 
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает значение порядка для нового элемента справочника.
//
// Параметры
//  ЭлементОбъект - СправочникОбъект - новый объект
//
// Возвращаемое значение:
//   Число - новый порядок
//
Функция НазначитьНовыйПорядок(ЭлементОбъект)
	
	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
	
	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
	
	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";
	КонецЕсли; 
	
	Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат (Выборка.Порядок + 1)
	КонецЕсли; 
	
КонецФункции

// Процедура вызывается перед записью объекта, для которого необходимо
// контролировать порядок элементов.
// 
// Параметры
//  Отказ - Булево, отказ от записи объекта
//  ЭтотОбъект - СправочникОбъект
//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
//
Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт
	
	Если ЭтотОбъект.ЭтоНовый() Тогда
		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
	Иначе
		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
		КонецЕсли;
	КонецЕсли;
	
	Если КонтролироватьПорядок Тогда
		
		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";
		
		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
			Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Отказ = Истина;
			#Если Клиент Тогда
				ТекстСообщения = НСтр("ru = 'Не уникальный порядок элемента справочника.'");
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
			#КонецЕсли
		КонецЕсли;
		
	КонецЕсли; 
	
КонецПроцедуры

// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
// порядком следования.
// 
// Параметры:
//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
Процедура ИзменитьПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина) Экспорт
	
	ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
	
	Если ЭлементЗамены = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
	НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
	
	Если НаправлениеПорядка = "Вверх" Тогда
		Если НовыйПорядокЗамены < НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены + 1;
		КонецЕсли; 
	Иначе
		Если НовыйПорядокЗамены > НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены - 1;
		КонецЕсли;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	ФиксироватьТранзакцию = Истина;
	
	Если НовыйПорядокЗамены <> ЭлементЗамены.Порядок Тогда
		ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
		ОбъектЗамены.Порядок = НовыйПорядокЗамены;
		ОбъектЗамены.КонтролироватьПорядок = Ложь;
		Попытка
			ОбъектЗамены.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли; 
	
	Если ФиксироватьТранзакцию Тогда
		ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
		ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
		Попытка
			ОбъектЭлемента.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если ФиксироватьТранзакцию Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли; 
	
КонецПроцедуры

// Функция определяет элемент справочника, с которым необходимо
// произвести "рокировку" текущего элемента
//
// Параметры
//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
// Возвращаемое значение:
//   СправочникСсылка
//
Функция ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг)
	
	ТекущийПорядок = ЭлементСсылка.Порядок;
	
	ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
		
	ИначеЕсли ЦиклическийСдвиг Тогда
		// Текущий элемент или первый (при движении вверх)
		// или последний (при движении вниз)
		// или вообще единственный
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Ссылка
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", ">", "<") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
		|УПОРЯДОЧИТЬ ПО
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
		|";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Неопределено;
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Возврат Выборка.Ссылка;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область УправляемыеФормы

// Функция представляет собой обертку над ОбщегоНазначенияБП.СостояниеДокумента
// для облегчения замены учетного ядра.
Функция СостояниеДокумента(Объект) Экспорт
	Возврат ОбщегоНазначенияБП.СостояниеДокумента(Объект);
КонецФункции

// Установка пиктограммы состояния документа в "стандартном" случае,
// когда на форме есть числовой реквизит СостояниеДокумента.
Процедура УстановитьСостояниеДокумента(Форма) Экспорт
	
	Объект = Форма.Объект;
	Форма.СостояниеДокумента = СостояниеДокумента(Объект);
	
КонецПроцедуры

#КонецОбласти

#Область ОбщегоНазначения

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "", Знач Статус = Неопределено, ИдентификаторФормы = Неопределено, ОбъектДанных = Неопределено) Экспорт
	
	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Заголовок_ = Заголовок;
			ТекстСообщения_ = ТекстСообщения;
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
		Иначе
			Заголовок_ = ТекстСообщения;
			ТекстСообщения_ = "";
		КонецЕсли;
		
		Если Статус=СтатусСообщения.Важное ИЛИ Статус=СтатусСообщения.ОченьВажное Тогда
			ПротоколируемыеСобытияУХ.ДобавитьЗаписьОшибка("ОбщийМодуль.ОбщегоНазначенияУХ.СообщитьОбОшибке",,, Заголовок_, ТекстСообщения_);
		Иначе		
			ПротоколируемыеСобытияУХ.ДобавитьЗаписьПримечание("ОбщийМодуль.ОбщегоНазначенияУХ.СообщитьОбОшибке",,, Заголовок_, ТекстСообщения_);
		КонецЕсли;
			
		ВызватьИсключение (ТекстСообщения);
		
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Текст = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок_ = Заголовок;
			ТекстСообщения_ = ТекстСообщения;
		Иначе
			Текст = ТекстСообщения;
			Заголовок_ = ТекстСообщения;
			ТекстСообщения_ = "";
		КонецЕсли;
		
		СообщениеПользователю = Новый СообщениеПользователю;
		СообщениеПользователю.Текст = Текст;
		Если ИдентификаторФормы <> Неопределено Тогда
			СообщениеПользователю.ИдентификаторНазначения = ИдентификаторФормы;
		КонецЕсли;
		Если ОбъектДанных <> неопределено Тогда
			СообщениеПользователю.КлючДанных = ОбъектДанных;
		КонецЕсли;
		СообщениеПользователю.Сообщить();
		
		#Если Сервер Тогда
			
			Если Статус=СтатусСообщения.Важное ИЛИ Статус=СтатусСообщения.ОченьВажное Тогда
				
				ПротоколируемыеСобытияУХ.ДобавитьЗаписьОшибка("ОбщийМодуль.ОбщегоНазначенияУХ.СообщитьОбОшибке",,, Заголовок_, ТекстСообщения_);
				
			Иначе		
				
				ПротоколируемыеСобытияУХ.ДобавитьЗаписьПримечание("ОбщийМодуль.ОбщегоНазначенияУХ.СообщитьОбОшибке",,, Заголовок_, ТекстСообщения_);
				
			КонецЕсли;
			
		#КонецЕсли
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты, ВыбратьРазрешенные = Ложь, КодЯзыка = Неопределено) Экспорт
	
	Возврат ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты, ВыбратьРазрешенные, КодЯзыка);
	
КонецФункции

Функция ЗначениеРеквизитаОбъекта(Ссылка, Знач Реквизит, ВыбратьРазрешенные = Ложь, КодЯзыка = Неопределено) Экспорт
	
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, Реквизит, ВыбратьРазрешенные, КодЯзыка);
	
КонецФункции

#КонецОбласти

#Область ПрочиеПроцедурыФункции

// Возвращает состав периметра организаций по заданным периоду, сценарию с учетом дополнительных отборов.
//
// Параметры:
//	локСценарий - сценарий, для котороого требуется получить периметр, СправочникСсылка.Сценарии;
//	локПериодОтчета - для котороого требуется получить периметр, СправочникСсылка.Периоды;
//	локОрганизация - организация консолидирующая организация, СправочникСсылка.Организации;
//	локМетодКонсолидации - метод консолидации, ПеречислениеСсылка.МетодыКонсолидации;
//	локМинПолнаяДоляВладения - максимальная полная доля владения, число;
//	локМаксПолнаяДоляВладения - минимальная полная доля владения, число;
//	локТипыОрганизаций - типы организаций, для которых требуется получить периметр.
//
// Возвращаемое значение:
//	Массив элементов типа СпарвочникСсылка.Организация.
//
Функция глСоставПериметра(КонтекстОтчета, локСценарий = Неопределено, локПериодОтчета = Неопределено, локОрганизация = Неопределено, локМетодКонсолидации = Неопределено, локМинПолнаяДоляВладения = 0, локМаксПолнаяДоляВладения = 100, локТипыОрганизаций = Неопределено, ВладелецПериметра = Неопределено) Экспорт
	
	Возврат УправлениеРабочимиПроцессамиУХ.ПолучитьСоставПериметраКонсолидации(?(локСценарий = Неопределено, КонтекстОтчета.Сценарий, локСценарий),
	?(локПериодОтчета		= Неопределено, КонтекстОтчета.ПериодОтчета,локПериодОтчета),
	?(локОрганизация		= Неопределено, КонтекстОтчета.Организация,локОрганизация),
	локМетодКонсолидации,
	локМинПолнаяДоляВладения,
	локМаксПолнаяДоляВладения,
	локТипыОрганизаций,
	ВладелецПериметра).ВыгрузитьКолонку("ИндивидуальнаяОрганизация");
	
КонецФункции

#КонецОбласти

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С ГЛОБАЛЬНЫМИ ПЕРЕМЕННЫМИ

Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	// Значение в КЭШе не нашли, получим значение из БД
	Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
		НайденноеЗначение = Пользователи.АвторизованныйПользователь();
				
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глИерархияОрганизацийОтчета") Тогда
		НайденноеЗначение = Новый Соответствие;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глТаблицаЯзыков") Тогда
		
		глТаблицаЯзыков = Константы.ДополнительныеЯзыкиВыводаОтчета.Получить().Получить();
		Если глТаблицаЯзыков = Неопределено Тогда
			глТаблицаЯзыков = Новый ТаблицаЗначений;
			глТаблицаЯзыков.Колонки.Добавить("ПорядковыйНомер", ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(1));
			глТаблицаЯзыков.Колонки.Добавить("КодЯзыка", ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(2));
			глТаблицаЯзыков.Колонки.Добавить("НаименованиеЯзыка", ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(150));
		КонецЕсли;
		НайденноеЗначение = глТаблицаЯзыков;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глОсновнойЯзык") Тогда
		
		НайденноеЗначение = ОбщегоНазначенияПовтИспУХ.ПолучитьОсновнойЯзыкПользователя();
		
	Иначе
		СтрокаИсключения = СтрШаблон(Нстр("ru = 'Невозможно обработать параметр ""%1"" для получения значения'"), 
		                   	ИмяПараметра);
		ВызватьИсключение СтрокаИсключения;
	КонецЕсли;
	
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	//Если ПараметрыСеанса.ИспользованиеРИБ Тогда
	//Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	//КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ УПРАВЛЕНИЯ НОМЕРАМИ ДОКУМЕНТОВ

Процедура ПриУстановкеНовогоНомераДокумента(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	ОбщегоНазначенияУХ.ДобавитьПрефиксУзла(Префикс);	
	
Конецпроцедуры

Процедура ПриУстановкеНовогоКодаСправочника(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	ОбщегоНазначенияУХ.ДобавитьПрефиксУзла(Префикс);
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////

// Функция - Свернуть Таблицу значений по измерениям(если не указаны КолонкиГруппировок, то используются все колонки, исключая КолонкиСуммирования)
//
// Параметры:
//  Коллекция			 - 	 - 
//  КолонкиГруппировок	 - 	 - 
//  КолонкиСуммирования	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция СвернутьПоИзмерениям(Коллекция, Знач КолонкиГруппировок = Неопределено, КолонкиСуммирования = Неопределено) Экспорт

	Если КолонкиГруппировок = Неопределено Тогда
		
		КолонкиГруппировок = Новый Массив;		
		Для каждого ТекущаяКолонка Из Коллекция.Колонки Цикл		
			КолонкиГруппировок.Добавить(ТекущаяКолонка.Имя);		
		КонецЦикла;
		
		ОбщегоНазначения.УдалитьНепроверяемыеРеквизитыИзМассива(КолонкиГруппировок, СтрРазделить(КолонкиСуммирования, " ,", Ложь));
		КолонкиГруппировок = СтрСоединить(КолонкиГруппировок, ",");
		
	КонецЕсли;	
	
	Коллекция.Свернуть(КолонкиГруппировок, КолонкиСуммирования);
	
	Возврат Коллекция;

КонецФункции

Функция ШестнадцатиричноеВДесятичное(Источник) Экспорт
	
	Результат = 0;
	
	Для Поз = 1 По СтрДлина(Источник) Цикл
		ТекКод = КодСимвола(Источник, Поз);
		
		Если ТекКод >= КодСимвола("0") И ТекКод <= КодСимвола("9") Тогда
			ТекКод = ТекКод - КодСимвола("0");
		ИначеЕсли ТекКод >= КодСимвола("a") И ТекКод <= КодСимвола("f") Тогда
			ТекКод = ТекКод +10 - КодСимвола("a");
		ИначеЕсли ТекКод >= КодСимвола("A") И ТекКод <= КодСимвола("F") Тогда
			ТекКод = ТекКод +10 - КодСимвола("A");
		КонецЕсли;
		
		Результат = Результат * 16 + ТекКод;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВтройСимвол		= Источник % 16;
	
	Возврат Сред(ШеснадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШеснадцатиричныеСимволы, ВтройСимвол, 1);
	
КонецФункции

Функция ЧетноеЧисло(Число) Экспорт
	
	Возврат Цел(Число/2) = Число/2;
	
КонецФункции

// Анализирует строку Стр на наличие в ней символов - не цифр.
// Возвращает Истина, если в строке присутствуют символы, не являющиеся цифрами.
// В противном случае возвращает Ложь.
//
Функция ЕстьНеЦифрыВСтроке(Стр) Экспорт
	
	КодСимвола0 = КодСимвола("0");
	КодСимвола9 = КодСимвола("9");
	
	Для Инд = 1 По СтрДлина(Стр) Цикл
		Если НЕ (КодСимвола(Стр, Инд) >= КодСимвола0 И КодСимвола(Стр, Инд) <= КодСимвола9) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 
	
	Возврат Истина;
	
КонецФункции

// функция из исходной строки формирует строку для поиска данных в запросе
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Процедура переносит строку из запроса в Структуру
Процедура ПеренестиСтрокуВыборкиВСтруктуру(РезультатЗапроса, СтрокаВыборки, СтруктураЭлемента) Экспорт
	
	Если СтруктураЭлемента = Неопределено 
		ИЛИ РезультатЗапроса = Неопределено 
		ИЛИ СтрокаВыборки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураЭлемента.Очистить();
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		СтруктураЭлемента.Вставить(Колонка.Имя, СтрокаВыборки[Колонка.Имя]);
	КонецЦикла;
	
КонецПроцедуры

// Процедура переносит строку из таблицы в Структуру
Функция ПеренестиСтрокуТаблицыВСтруктуру(Таблица, СтрокаТаблицы, СтруктураЭлемента)Экспорт 
	
	Если СтруктураЭлемента = Неопределено Тогда
		СтруктураЭлемента = Новый Структура();
	Иначе	
		СтруктураЭлемента.Очистить();
	КонецЕсли; 
	
	Если 	СтрокаТаблицы 	= Неопределено 
		ИЛИ Таблица 		= Неопределено Тогда
		Возврат СтруктураЭлемента;
	КонецЕсли;
	
	Для Каждого Колонка Из Таблица.Колонки Цикл
		СтруктураЭлемента.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
	КонецЦикла;
	
	Возврат СтруктураЭлемента;
	
КонецФункции

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.ВернутьИндексВМассиве(МассивДанные, Элемент);
	
КонецФункции

Функция ПолучитьШапкуОшибки(ЗНАЧ ОбъектРасчета) Экспорт
	
	Если ТипЗнч(ОбъектРасчета)=Тип("ДокументОбъект.НастраиваемыйОтчет") Тогда
		
		ОбъектРасчета=ОбъектРасчета.ПодготовитьСтруктуруПеременныхДляРасчета();
		
	КонецЕсли;
	
	ТекстОшибки=СтрШаблон(Нстр("ru = 'Вид отчета:%1; Сценарий: %2; Организация: %3; Период отчета: %4'"), 
	            	ОбъектРасчета.ВидОтчета, ОбъектРасчета.Сценарий, ОбъектРасчета.Организация, ОбъектРасчета.ПериодОтчета);
	
	Если ОбъектРасчета.Свойство("Проект") И ЗначениеЗаполнено(ОбъектРасчета.Проект) Тогда
		
		ТекстОшибки=СтрШаблон(Нстр("ru = '%1; Проект: %2'"), ТекстОшибки, ОбъектРасчета.Проект);
		
	КонецЕсли;
	
	Для Индекс=1 По ПараметрыСеанса.ЧислоДопАналитик Цикл
		
		Если ОбъектРасчета.Свойство("Аналитика"+Индекс) И ЗначениеЗаполнено(ОбъектРасчета["Аналитика"+Индекс]) Тогда
			
			ТекстОшибки=СтрШаблон(Нстр("ru = '%1; Аналитика%2: %3'"), ТекстОшибки, Индекс, ОбъектРасчета["Аналитика"+Индекс]);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если ОбъектРасчета.Свойство("ПравилоОбработки") Тогда
		
		ТекстОшибки=СтрШаблон(Нстр("ru = '%1; Правило расчета: %2'"), ТекстОшибки, ОбъектРасчета.ПравилоОбработки);
		
	КонецЕсли;
	
	Если ОбъектРасчета.Свойство("ИспользуемаяИБ") И ЗначениеЗаполнено(ОбъектРасчета.ИспользуемаяИБ) Тогда
		
		ТекстОшибки=СтрШаблон(Нстр("ru = '%1; Используемая ИБ: %2'"), ТекстОшибки, ОбъектРасчета.ИспользуемаяИБ);
		
	КонецЕсли;
	
	Если ОбъектРасчета.Свойство("ПоказательОтчета") Тогда
		
		ТекстОшибки=СтрШаблон(Нстр("ru = '%1; Показатель: %2'"), ТекстОшибки, ОбъектРасчета.ПоказательОтчета);
		
	КонецЕсли;
			
	Возврат ТекстОшибки;
	
КонецФункции // ПолучитьШапкуОшибки()

// Функция убирает из текста сообщения служебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт
	
	НачалоСлужебногоСообщения    = СтрНайти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = СтрНайти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
		
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);
	
КонецФункции // ()

// Процедура проверяет переданный параметр, если он пустой, 
// то заполняет его указанным значением.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура ЗаполнитьПустоеЗначение(Параметр, Значение) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Параметр) И Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт
	
	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Предназначена для получения ссылки на элемент перечисления по его имени.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьЗначениеПеречисленияПоИмени(ИмяОбъекта,ИмяПеречисления,НастройкаСоответствия=Неопределено) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ИмяПеречисления) Тогда
		
		Возврат ПолучитьПустуюСсылкуПеречисление(ИмяОбъекта);
				
	Иначе
		
		Если ТипЗнч(ИмяПеречисления)=Тип("Строка") Тогда
			
			Попытка
				
				Возврат Перечисления[ИмяОбъекта][ИмяПеречисления];
				
			Исключение // Возможно, передан синоним
				
				Попытка
				
					Для Каждого СтрПеречисление ИЗ Метаданные.Перечисления[ИмяОбъекта].ЗначенияПеречисления Цикл
						
						Если СтрПеречисление.Синоним=СокрЛП(ИмяПеречисления) Тогда
							
							Возврат Перечисления[ИмяОбъекта][СтрПеречисление.Имя];
							
						КонецЕсли;
						
					КонецЦикла;
									
					Возврат ?(НастройкаСоответствия=Неопределено,ПолучитьПустуюСсылкуПеречисление(ИмяОбъекта),ПолучитьЗначениеПеречисленияПоНастройке(ИмяОбъекта,ИмяПеречисления,НастройкаСоответствия));
					
				Исключение
					
					Возврат ?(НастройкаСоответствия=Неопределено,ПолучитьПустуюСсылкуПеречисление(ИмяОбъекта),ПолучитьЗначениеПеречисленияПоНастройке(ИмяОбъекта,ИмяПеречисления,НастройкаСоответствия));
					
				КонецПопытки;
				
			КонецПопытки
			
		Иначе
			
			Возврат ИмяПеречисления;
			
		КонецЕсли;
		
	КонецЕсли;
		
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

Функция ПолучитьПустуюСсылкуПеречисление(ИмяОбъекта) Экспорт
	
	Попытка
		Возврат Перечисления[ИмяОбъекта].ПустаяСсылка();
	Исключение
		Возврат Неопределено;
	КонецПопытки
	
КонецФункции // ПолучитьПустуюСсылкуПеречисление() 

Функция ПолучитьЗначениеПеречисленияПоНастройке(ИмяОбъекта,ИмяПеречисления,НастройкаСоответствия)
	
	СтрокаСоответствия=НастройкаСоответствия.СоответствиеЗначенийПеречислений.Найти(ИмяПеречисления,"ЗначениеВнешнейИБ");
	
	Если СтрокаСоответствия=Неопределено Тогда
		
		СтрокаСоответствия=НастройкаСоответствия.СоответствиеЗначенийПеречислений.Найти(ИмяПеречисления,"ПредставлениеВнешнейИБ");
		
	КонецЕсли;
	
	Если СтрокаСоответствия=Неопределено Тогда
		
		Возврат ПолучитьПустуюСсылкуПеречисление(ИмяОбъекта);
		
	Иначе
		
		Попытка
			
			Возврат Перечисления[ИмяОбъекта][СтрокаСоответствия.ЗначениеТекущейИБ];
			
		Исключение
			
			Возврат ПолучитьПустуюСсылкуПеречисление(ИмяОбъекта);
			
		КонецПопытки;
		
	КонецЕсли;
		
	
КонецФункции // ПолучитьЗначениеПеречисленияПоНастройке()
	
Функция ПолучитьРеквизитОбъекта(МетаданныеОбъекта,ИмяРеквизита) Экспорт
	
	Попытка
		
		Для Каждого Реквизит ИЗ МетаданныеОбъекта.СтандартныеРеквизиты Цикл
			
			Если Реквизит.Имя=ИмяРеквизита Тогда
				
				Возврат Реквизит;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Исключение
		
	КонецПопытки;
	
	Попытка

		Для Каждого Реквизит ИЗ МетаданныеОбъекта.Реквизиты Цикл
			
			Если Реквизит.Имя=ИмяРеквизита Тогда
				
				Возврат Реквизит;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Исключение
		
	КонецПопытки;
	
	Возврат Неопределено;
	
КонецФункции // ПолучитьРеквизитОбъекта()

// Формирует строку заданной длины, дополняя
// переданную строку пробелами.
// Параметры:
//	НачСтрока - исходная строка
//  ЗаданнаяДлина - необходимая длина строки
//
Функция ДополнитьДоЗаданнойДлины(НачСтрока,ЗаданнаяДлина) Экспорт
	
	ЧислоПробелов=ЗаданнаяДлина-СтрДлина(НачСтрока);
	ТекущаяСтрока=НачСтрока;
	
	Если ЧислоПробелов<0 Тогда
		Возврат Лев(НачСтрока,ЗаданнаяДлина);
	Иначе
		
		Для Индекс=1 По ЧислоПробелов Цикл
			
			ТекущаяСтрока=ТекущаяСтрока+" ";
			
		КонецЦикла;
		
		Возврат ТекущаяСтрока;
		
	КонецЕсли;
	
КонецФункции // ДополнитьДоЗаданнойДлины()

//////////////////////////////

Функция ПолучитьСписокОрганизацийКорректировки(Сценарий, ПериодОтчета, Организация) Экспорт
	
	СписокОрганизаций = Новый СписокЗначений;
	
	СтруктураКонтекст=Новый Структура("Сценарий,ПериодОтчета,Организация",Сценарий, ПериодОтчета, Организация);
	
	ТаблицаПериметр = УправлениеРабочимиПроцессамиУХ.ПолучитьДанныеРегламентаОтчета(СтруктураКонтекст);
		
	СписокОрганизаций.ЗагрузитьЗначения(ТаблицаПериметр.ВыгрузитьКолонку("ИндивидуальнаяОрганизация"));
	
	Если СписокОрганизаций.НайтиПоЗначению(Организация) = Неопределено Тогда
		СписокОрганизаций.Добавить(Организация);
	КонецЕсли;
	
	Возврат СписокОрганизаций;
	
КонецФункции

// Функция возвращает модуль значения.
Функция ЗначениеПоМодулю(Значение) Экспорт;
	
	Возврат ?(Значение<0,Значение*-1,Значение);
	
КонецФункции // Модуль() 

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт

	Если СтрДлина(Разделитель)=1 Тогда
		
		Возврат СтрРазделить(Стр,Разделитель);
		
	Иначе
		
		Возврат СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Стр, Разделитель,Ложь);
		
	КонецЕсли;
	
КонецФункции // глРазложить

Функция ЗаменитьСимволыПути(Строка,СтрокаЗамены) Экспорт
	
	Если СтрНайти(Строка,"vzv")>0 Тогда
		
		Возврат СтрЗаменить(Строка,"vzv",СтрокаЗамены);
		
	Иначе
		
		Возврат СтрЗаменить(Строка,"_",СтрокаЗамены);
		
	КонецЕсли;
			
КонецФункции // ЗаменитьСимволыПути()

Функция ПолучитьМассивПутей(СтрокаПуть) Экспорт
	
	Если СтрНайти(СтрокаПуть,"vzv")>0 Тогда
		
		Возврат РазложитьСтрокуВМассивПодстрок(СтрокаПуть,"vzv");
		
	Иначе
		
		Возврат РазложитьСтрокуВМассивПодстрок(СтрокаПуть,"_");
		
	КонецЕсли;
	
КонецФункции // ПолучитьМассивПутей() 

Функция РазложитьСтрокуПоЗаглавнымБуквам(Знач Стр) Экспорт
	
	РезультирующаяСтрока=Сред(Стр,1,1);
	
	Для Инд=2 По СтрДлина(Стр) Цикл
		
		ТекСимвол=Сред(Стр,Инд,1);
		
		Если ТекСимвол=ВРЕГ(ТекСимвол) Тогда
			
			РезультирующаяСтрока=РезультирующаяСтрока+" "+НРЕГ(ТекСимвол);
			
		Иначе
			
			РезультирующаяСтрока=РезультирующаяСтрока+ТекСимвол;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат РезультирующаяСтрока;
	
КонецФункции // РазложитьСтрокуПоЗаглавнымБуквам()

// Процедура устанавливает доступность элементов управления отбором списка.
//
// Параметры:
//  ТабличноеПоле      - табличное поле списка.
//  ОбязательныеОтборы - список имен обязательных отборов, у которых доступность отключается.
//
Процедура УстановитьДоступностьОтбора(ТабличноеПоле, Знач ОбязательныеОтборы = "") Экспорт
	
	ОбязательныеОтборы = Врег(ОбязательныеОтборы) + ", ";
	
	Для каждого ЭлементУправленияОтбором Из ТабличноеПоле.НастройкаОтбора Цикл
		ОбязательныйОтбор = СтрНайти(ОбязательныеОтборы, Врег(ЭлементУправленияОтбором.Имя)) > 0;
		
		ЭлементУправленияОтбором.Доступность = НЕ ОбязательныйОтбор;
	КонецЦикла;
	
КонецПроцедуры

// Процедура устанавливает доступность всех элементов управления порядком списка.
//
// Параметры:
//  ТабличноеПоле - табличное поле списка.
//
Процедура УстановитьДоступностьПорядка(ТабличноеПоле, Доступность = Истина) Экспорт
	
	Для каждого ЭлементУправленияПорядком Из ТабличноеПоле.НастройкаПорядка Цикл
		ЭлементУправленияПорядком.Доступность = Доступность;
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл
		
		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
		
	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Добавляет в таблицу значений отсутствующие строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
// Проверка осуществляется по равенству колонок "ИменаКолонокДляСравнения".
// Использовать только для таблиц небольшого (до 200 строк) размера.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//	ИменаКолонокДляСравнения - Строка, имена колонок разделенные
//		запятыми для поиска строк в таблице приемнике.
//
Процедура ЗагрузитьВТаблицуЗначенийОтсутствующие(ТаблицаИсточник, ТаблицаПриемник, ИменаКолонокДляСравнения) Экспорт
	мДобавляемыхСтрок = Новый Массив;
	Отбор = Новый Структура(ИменаКолонокДляСравнения);
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл
		ЗаполнитьЗначенияСвойств(Отбор, СтрокаТаблицыИсточника);
		мНайденныхСтрок = ТаблицаПриемник.НайтиСтроки(Отбор);
		Если мНайденныхСтрок.Количество() = 0 Тогда
			мДобавляемыхСтрок.Добавить(СтрокаТаблицыИсточника);
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ДобавляемаяСтрока Из мДобавляемыхСтрок Цикл
		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, ДобавляемаяСтрока);
	КонецЦикла;
КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Добавляет значения из переданного массива в переданный список значений
//
Процедура ДобавитьМассивВСписокЗначений(СписокЗначений, Массив) Экспорт
	
	Для Каждого Значение ИЗ Массив Цикл
		
		СписокЗначений.Add(Значение);
		
	КонецЦикла;
	
КонецПроцедуры // ДобавитьМассивВСписокЗначений()

// Сворачивает переданную таблицу значений с нечисловыми показателями
//
Функция СвернутьНечисловыеЗначения(РабочаяТаблица,СтрСверткаИзмерения,СтрСверткаЗначения) Экспорт
	
	// Получим необходимые комбинации измерений
	
	ТабИзмерения=РабочаяТаблица.Скопировать();
	ТабИзмерения.Свернуть(СтрСверткаИзмерения);
	
	МассивИзмерения=РазложитьСтрокуВМассивПодстрок(СтрСверткаИзмерения);
	
	// Получим имена колонок, по которым будем накапливать значения
	
	МассивЗначения=РазложитьСтрокуВМассивПодстрок(СтрСверткаЗначения);
	
	Для Каждого КолонкаЗначение ИЗ МассивЗначения Цикл
		
		ТабИзмерения.Колонки.Добавить(КолонкаЗначение);
		
	КонецЦикла;
	
	// Заполним таблицу итогами
	
	Для Каждого СтрИтог ИЗ ТабИзмерения Цикл
		
		// Подготовим структуру для накопления итога по строке
		
		СтруктураЗначения=Новый Структура;
		
		Для Каждого КолонкаЗначение ИЗ МассивЗначения Цикл
			
			СтруктураЗначения.Вставить(КолонкаЗначение);
			
		КонецЦикла;
		
		// Найдем в исходной таблице строки, относящиеся к данной комбинации измерений после свертки
		СтруктураПоиска=Новый Структура;
		Для Каждого КолонкаИзмерение ИЗ МассивИзмерения Цикл
			СтруктураПоиска.Вставить(КолонкаИзмерение,СтрИтог[КолонкаИзмерение]);
		КонецЦикла;
		
		МассивСтрок=РабочаяТаблица.НайтиСтроки(СтруктураПоиска);
		
		Для Каждого СтрЗначение ИЗ МассивСтрок Цикл
			
			Для Каждого КлючИЗначение Из СтруктураЗначения Цикл
				
				Если ЗначениеЗаполнено(СтрЗначение[КлючИЗначение.Ключ]) Тогда
					
					Если НЕ ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
						
						КлючИЗначение.Значение=СтрЗначение[КлючИЗначение.Ключ];
						
					Иначе
						
						// Накапливаем итоги по показателям
						
						Если ТипЗнч(КлючИЗначение.Значение)=Тип("Число")
							ИЛИ ТипЗнч(КлючИЗначение.Значение)=Тип("Строка") Тогда
							
							КлючИЗначение.Значение=КлючИЗначение.Значение+СтрЗначение[КлючИЗначение.Ключ];
							
						ИначеЕсли ТипЗнч(КлючИЗначение.Значение)=Тип("Булево") Тогда
							
							КлючИЗначение.Значение=КлючИЗначение.Значение И СтрЗначение[КлючИЗначение.Ключ];
							
						Иначе
							
							КлючИЗначение.Значение=СтрЗначение[КлючИЗначение.Ключ];
							
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
		ЗаполнитьЗначенияСвойств(СтрИтог,СтруктураЗначения);
		
	КонецЦикла;
	
	Возврат ТабИзмерения; 
	
КонецФункции // СвернутьНечисловыеЗначения()

Функция ВернутьСтруктуруИтога(ВидИтога,ТипЗначения=Неопределено) Экспорт
	
	СтруктураИтога=Неопределено;
	
	Если ВидИтога=Перечисления.ВидыИтоговПоказателя.НеРассчитывается Тогда
		
		Возврат СтруктураИтога;
			
	ИначеЕсли ТипЗначения=Перечисления.ТипыЗначенийПоказателейОтчетов.Булево Тогда
		
		Если ВидИтога=Перечисления.ВидыИтоговПоказателя.Минимум Тогда
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","МИНИМУМ","БУЛЕВО");
			
		ИначеЕсли ВидИтога=Перечисления.ВидыИтоговПоказателя.Максимум Тогда
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","МАКСИМУМ","БУЛЕВО");
			
		Иначе
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","МИНИМУМ","БУЛЕВО");
	
		КонецЕсли;
		
	ИначеЕсли ТипЗначения=Перечисления.ТипыЗначенийПоказателейОтчетов.Число Тогда
		
		Если ВидИтога=Перечисления.ВидыИтоговПоказателя.Минимум Тогда
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","МИНИМУМ","ЧИСЛО(18,5)");
			
		ИначеЕсли ВидИтога=Перечисления.ВидыИтоговПоказателя.Максимум Тогда
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","МАКСИМУМ","ЧИСЛО(18,5)");
			
		ИначеЕсли ВидИтога=Перечисления.ВидыИтоговПоказателя.Среднее Тогда
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","СРЕДНЕЕ","ЧИСЛО(18,5)");
			
		ИначеЕсли ВидИтога=Перечисления.ВидыИтоговПоказателя.Сумма
			ИЛИ ВидИтога=Перечисления.ВидыИтоговПоказателя.ПустаяСсылка() Тогда
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","СУММА","ЧИСЛО(18,5)");
			
		КонецЕсли;
		
	ИначеЕсли ТипЗначения=Перечисления.ТипыЗначенийПоказателейОтчетов.Дата Тогда
		
		Если ВидИтога=Перечисления.ВидыИтоговПоказателя.Минимум Тогда
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","МИНИМУМ","ДАТА");
			
		ИначеЕсли ВидИтога=Перечисления.ВидыИтоговПоказателя.Максимум Тогда
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","МАКСИМУМ","ДАТА");
			
		Иначе
			
			СтруктураИтога=Новый Структура("ТекстИтога,ТипЗначения","МАКСИМУМ","ДАТА");
			
		КонецЕсли;
				
	КонецЕсли;
	
	Возврат СтруктураИтога;
	
КонецФункции // ВернутьТекстИтога()

// Возвращает итоговое значение из переданной таблицы значений,
// свернутой по необходимым аналитикам
// Параметры:
//	ТаблицаЗначений - исходная таблица значений;
//  СтрАналитики - строка с именами колонок аналитики для свертки
//  КолонкаИтог - имя колонки, по которой ищется итоговое значение
//  ВидИтога - значение перечисления ВидыИтоговПоказателя
//
Функция ТЗИтог(ТаблицаЗначений, СтрАналитики, КолонкаИтог, ВидИтога,ТипЗначения=Неопределено,СтруктураОтбора=Неопределено) Экспорт
	
	Если НЕ СтруктураОтбора=Неопределено Тогда
		
		РабочаяТаблица=ТаблицаЗначений.Скопировать(СтруктураОтбора);
		
	Иначе
		
		РабочаяТаблица=ТаблицаЗначений.Скопировать();
		
	КонецЕсли;
	
	Если (НЕ ПустаяСтрока(СтрАналитики)) И (ТипЗначения=Неопределено ИЛИ ТипЗначения=Перечисления.ТипыЗначенийПоказателейОтчетов.Число)  Тогда
		РабочаяТаблица.Свернуть(СтрАналитики,КолонкаИтог);
	КонецЕсли;
	
	Если РабочаяТаблица.Количество()=0 Тогда
		
		
		Возврат ПолучитьПустоеЗначение(ТипЗначения);
		
	ИначеЕсли РабочаяТаблица.Количество()=1 Тогда
		
		Возврат РабочаяТаблица[0][КолонкаИтог];
		
	ИначеЕсли ВидИтога=Перечисления.ВидыИтоговПоказателя.Минимум Тогда 
		
		РабочаяТаблица.Сортировать(КолонкаИтог+" Возр");
		Возврат РабочаяТаблица[0][КолонкаИтог];
		
	ИначеЕсли ВидИтога=Перечисления.ВидыИтоговПоказателя.Максимум Тогда
		
		РабочаяТаблица.Сортировать(КолонкаИтог+" Убыв");
		Возврат РабочаяТаблица[0][КолонкаИтог];
		
	ИначеЕсли ВидИтога=Перечисления.ВидыИтоговПоказателя.Среднее Тогда
		
		Возврат РабочаяТаблица.Итог(КолонкаИтог)/РабочаяТаблица.Количество();
		
	ИначеЕсли ВидИтога=Перечисления.ВидыИтоговПоказателя.Сумма ИЛИ 
		ВидИтога=Перечисления.ВидыИтоговПоказателя.ПустаяСсылка() Тогда // По умолчанию также возвращаем сумму
		
		Если ТипЗначения=Перечисления.ТипыЗначенийПоказателейОтчетов.Булево Тогда
			
			Если РабочаяТаблица.Количество()=0 Тогда
				Возврат Ложь;
			Иначе
				
				ТекЗначение=РабочаяТаблица[0][КолонкаИтог];
				
				РабочаяТаблица.Сортировать(КолонкаИтог+" Возр");
				Возврат РабочаяТаблица[0][КолонкаИтог];
				
			КонецЕсли;
			
		ИначеЕсли ТипЗначения=Перечисления.ТипыЗначенийПоказателейОтчетов.Строка Тогда
			
			ТекЗначение=""+РабочаяТаблица[0][КолонкаИтог];
			
			Для Индекс=1 по РабочаяТаблица.Количество()-1 Цикл
				
				ТекЗначение=ТекЗначение+РабочаяТаблица[Индекс][КолонкаИтог];
				
			КонецЦикла;
			
			Возврат ТекЗначение;
			
		ИначеЕсли ТипЗначения=Перечисления.ТипыЗначенийПоказателейОтчетов.Дата Тогда
			
			РабочаяТаблица.Сортировать(КолонкаИтог+" Убыв");
			Возврат РабочаяТаблица[0][КолонкаИтог];
			
		Иначе
			
			Возврат РабочаяТаблица.Итог(КолонкаИтог);
			
		КонецЕсли;
		
	Иначе // Свертка не используется. Возвращаем пустое значение
		
		Возврат ПолучитьПустоеЗначение(ТипЗначения);
				
	КонецЕсли;
	
КонецФункции // ТЗМинимум()

Функция ПолучитьПустоеЗначение(ТипЗначения) Экспорт
	
	Если ((НЕ ЗначениеЗаполнено(ТипЗначения)) ИЛИ ТипЗначения = Перечисления.ТипыЗначенийПоказателейОтчетов.Число) Тогда
		Возврат ОбщегоНазначенияУХ.ПустоеЗначениеТипа(Тип("Число"));
	ИначеЕсли ТипЗначения = Перечисления.ТипыЗначенийПоказателейОтчетов.Булево Тогда
		Возврат ОбщегоНазначенияУХ.ПустоеЗначениеТипа(Тип("Булево"));
	ИначеЕсли ТипЗначения = Перечисления.ТипыЗначенийПоказателейОтчетов.Дата Тогда
		Возврат ОбщегоНазначенияУХ.ПустоеЗначениеТипа(Тип("Дата"));
	ИначеЕсли ТипЗначения = Перечисления.ТипыЗначенийПоказателейОтчетов.Строка Тогда
		Возврат ОбщегоНазначенияУХ.ПустоеЗначениеТипа(Тип("Строка"));
	КонецЕсли;
	
КонецФункции // ПолучитьПустоеЗначение() 

// Добавляет к строке дерева значений полную коллекцию строк другого дерева значений
//
Процедура ДобавитьКоллекциюВСтрокуДереваЗначений(СтрокаДерева,КоллекцияСтрок) Экспорт
	
	Для Каждого Строка ИЗ КоллекцияСтрок Цикл
		
		НоваяСтрока=СтрокаДерева.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка);
		
		Если Строка.Строки.Количество()>0 Тогда
			
			ДобавитьКоллекциюВСтрокуДереваЗначений(НоваяСтрока,Строка.Строки);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат;
	
КонецПроцедуры

Функция СравнитьСтруктурыЗначений(Структура1, Структура2) Экспорт
	
	Если НЕ Структура1.Количество()=Структура2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ТипЗнч(Структура1)=ТипЗнч(Структура2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Элемент ИЗ Структура1 Цикл
		
		Если Не Структура2.Свойство(Элемент.Ключ) Тогда
			Возврат Ложь;
		ИначеЕсли НЕ ТипЗнч(Элемент.Значение)=ТипЗнч(Структура2[Элемент.Ключ]) Тогда
			Возврат Ложь;
		ИначеЕсли ТипЗнч(Элемент.Значение)=Тип("Структура") Тогда
			Если НЕ СравнитьСтруктурыЗначений(Элемент.Значение,Структура2[Элемент.Ключ]) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Элемент.Значение)=Тип("СписокЗначений") Тогда
			Если НЕ СравнитьСпискиЗначений(Элемент.Значение,Структура2[Элемент.Ключ]) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Элемент.Значение)=Тип("Массив") Тогда
			Если НЕ СравнитьМассивыЗначений(Элемент.Значение,Структура2[Элемент.Ключ]) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Элемент.Значение)=Тип("ТаблицаЗначений") Тогда
			Если НЕ СравнитьТаблицыЗначений(Элемент.Значение,Структура2[Элемент.Ключ]) Тогда
				Возврат Ложь;
			КонецЕсли;	
		ИначеЕсли НЕ Элемент.Значение=Структура2[Элемент.Ключ] Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции //  СравнитьСтруктурыЗначений()

Функция СравнитьСпискиЗначений(Список1,Список2) Экспорт
	
	Если НЕ Список1.Количество()=Список2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ТипЗнч(Список1)=ТипЗнч(Список2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Индекс=0 По Список1.Количество()-1 Цикл
		
		Значение1=Список1[Индекс].Значение;
		Значение2=Список2[Индекс].Значение;
		
		Если НЕ ТипЗнч(Значение1)=ТипЗнч(Значение2) Тогда
			Возврат Ложь;
		ИначеЕсли ТипЗнч(Значение1)=Тип("Структура") Тогда 
			Если НЕ СравнитьСтруктурыЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Значение1)=Тип("СписокЗначений") Тогда
			Если НЕ СравнитьСпискиЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Значение1)=Тип("Массив") Тогда
			Если НЕ СравнитьМассивыЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли НЕ Значение1=Значение2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;	
	
КонецФункции // СравнитьСписокыЗначений()

Функция СравнитьМассивыЗначений(Массив1,Массив2)
	
	Если НЕ Массив1.Количество()=Массив2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ТипЗнч(Массив1)=ТипЗнч(Массив2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Индекс=0 По Массив1.Количество()-1 Цикл
		
		Значение1=Массив1[Индекс];
		Значение2=Массив2[Индекс];
		
		Если НЕ ТипЗнч(Значение1)=ТипЗнч(Значение2) Тогда
			Возврат Ложь;
		ИначеЕсли ТипЗнч(Значение1)=Тип("Структура") Тогда 
			Если НЕ СравнитьСтруктурыЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Значение1)=Тип("СписокЗначений") Тогда
			Если НЕ СравнитьСпискиЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Значение1)=Тип("Массив") Тогда 
			Если НЕ СравнитьМассивыЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли НЕ Значение1=Значение2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;	
	
КонецФункции // СравнитьМассивыЗначений() 

// Удаляет неиспользуемые способы вычисления параметров из таблиц их вычисления
//
Процедура УдалитьНеиспользуемыеПараметры(ТабВычисления)
	
	МассивНеиспользуемых=ТабВычисления.НайтиСтроки(Новый Структура("СпособВычисленияПараметра",Перечисления.СпособыВычисленияПараметровОперандов.НеИспользуется));
	
	Для Каждого Строка Из МассивНеиспользуемых Цикл
		
		ТабВычисления.Удалить(Строка);
		
	КонецЦикла;
	
КонецПроцедуры // УдалитьНеиспользуемыеПараметры()


// Функция сравнивает две таблицы вычисления параметров операндов
//
// Параметры
//  ТаблицаВычисления1 - ТаблицаЗначений для сравнения
//  ТаблицаВычисления2 - ТаблицаЗначений для сравнения
//
// Возвращаемое значение:
//   Булево, идентичны или нет две таблицы
//
Функция СравнитьТаблицыВычисленияПараметров(РабочаяТаблица1, РабочаяТаблица2) Экспорт
	
	ТаблицаВычисления1=РабочаяТаблица1.Скопировать();
	ТаблицаВычисления2=РабочаяТаблица2.Скопировать();
	
	УдалитьНеиспользуемыеПараметры(ТаблицаВычисления1);
	УдалитьНеиспользуемыеПараметры(ТаблицаВычисления2);
	
	Если ТаблицаВычисления1.Количество() <> ТаблицаВычисления2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	ТаблицаВычисления1.Сортировать("ПолеБД");
	ТаблицаВычисления2.Сортировать("ПолеБД");
	
	МассивКолонок=Новый Массив;
	МассивКолонок.Добавить("ПолеБД");
	МассивКолонок.Добавить("СпособВычисленияПараметра");
	МассивКолонок.Добавить("УточнениеСпособаОпределения");
	МассивКолонок.Добавить("ТекстМодуля");
	
	Для Индекс=0 По ТаблицаВычисления1.Количество()-1 Цикл
		
		Для Каждого Колонка ИЗ МассивКолонок Цикл
			
			Если Колонка="УточнениеСпособаОпределения" Тогда
				
				ЗначениеДляПроверки1=ТаблицаВычисления1[Индекс].УточнениеСпособаОпределения;
				ЗначениеДляПроверки2=ТаблицаВычисления2[Индекс].УточнениеСпособаОпределения;
				
				Если НЕ ТипЗнч(ЗначениеДляПроверки1)=ТипЗнч(ЗначениеДляПроверки2) Тогда
					
					Возврат Ложь;
				
				ИначеЕсли ТипЗнч(ЗначениеДляПроверки1)=Тип("Структура") Тогда
					
					Если Не СравнитьСтруктурыЗначений(ЗначениеДляПроверки1,ЗначениеДляПроверки2) Тогда
						
						Возврат Ложь;
						
					КонецЕсли;
					
				ИначеЕсли ТипЗнч(ЗначениеДляПроверки1)=Тип("СписокЗначений") Тогда
					
					Если НЕ СравнитьСпискиЗначений(ЗначениеДляПроверки1,ЗначениеДляПроверки2) Тогда
						
						Возврат Ложь;
						
					КонецЕсли;
					
				ИначеЕсли ТипЗнч(ЗначениеДляПроверки1)=Тип("Массив") Тогда 
					
					Если НЕ СравнитьМассивыЗначений(ЗначениеДляПроверки1,ЗначениеДляПроверки2)Тогда
						
						Возврат Ложь;
						
					КонецЕсли;
					
				ИначеЕсли НЕ ЗначениеДляПроверки1=ЗначениеДляПроверки2 Тогда
					
					Возврат Ложь;
					
				КонецЕсли;
				
			ИначеЕсли НЕ ТаблицаВычисления1[Индекс][Колонка]=ТаблицаВычисления2[Индекс][Колонка] Тогда
				
				Возврат Ложь;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // СравнитьТаблицыВычисленияПараметров()

Функция СравнитьТаблицыЗначений(ТаблицаЗначений1, ТаблицаЗначений2,СтруктураПропускаемыхЗначений=Неопределено,СтруктураКолонокПоиска=Неопределено) Экспорт
	
	Если ТипЗнч(ТаблицаЗначений1) <> Тип("ТаблицаЗначений") ИЛИ ТипЗнч(ТаблицаЗначений2) <> Тип("ТаблицаЗначений") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если ТаблицаЗначений1.Количество() <> ТаблицаЗначений2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если ТаблицаЗначений1.Колонки.Количество() <> ТаблицаЗначений2.Колонки.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверим поля
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если ТаблицаЗначений2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если ТаблицаЗначений1.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	
	// сформируем строку индекса для оптимизации поиска по таблице значений
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса+","+Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	// добавим индекс
	ТаблицаЗначений2.Индексы.Добавить(СтрокаИндекса);
	
	// Проверим записи
	Для каждого СтрокаТаблицы Из ТаблицаЗначений1 Цикл
		
		СтруктураПоиска = Новый Структура;
				
		Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
						
			Если НЕ (СтруктураКолонокПоиска=Неопределено ИЛИ СтруктураКолонокПоиска.Свойство(Колонка.Имя)) Тогда
				
				Продолжить;
				
			КонецЕсли;
			
			Если СтруктураПропускаемыхЗначений=Неопределено 
				ИЛИ НЕ(СтруктураПропускаемыхЗначений.Свойство(Колонка.Имя) И (СтруктураПропускаемыхЗначений[Колонка.Имя]=СтрокаТаблицы[Колонка.Имя] ИЛИ СтруктураПропускаемыхЗначений[Колонка.Имя]=Неопределено)) Тогда
				
				СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
							
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтруктураПоиска.Количество()=0 Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокиТаблицы2 = ТаблицаЗначений2.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы2.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	// сформируем строку индекса для оптимизации поиска по таблице значений
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса+","+Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	// добавим индекс
	ТаблицаЗначений1.Индексы.Добавить(СтрокаИндекса);
	
	Для каждого СтрокаТаблицы Из ТаблицаЗначений2 Цикл
		
		СтруктураПоиска = Новый Структура;
		
		Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
			
			Если НЕ (СтруктураКолонокПоиска=Неопределено ИЛИ СтруктураКолонокПоиска.Свойство(Колонка.Имя)) Тогда
				
				Продолжить;
				
			КонецЕсли;
			
			Если СтруктураПропускаемыхЗначений=Неопределено 
				ИЛИ НЕ(СтруктураПропускаемыхЗначений.Свойство(Колонка.Имя) И (СтруктураПропускаемыхЗначений[Колонка.Имя]=СтрокаТаблицы[Колонка.Имя] ИЛИ СтруктураПропускаемыхЗначений[Колонка.Имя]=Неопределено)) Тогда
				
				СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
							
			КонецЕсли;
			
		КонецЦикла;
		
		Если СтруктураПоиска.Количество()=0 Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокиТаблицы1 = ТаблицаЗначений1.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы1.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // СравнитьТаблицыЗначений()

Функция ОбъектыСовпадают(Объект1, Объект2, Знач РеквизитыПроверки = "", Знач РеквизитыИсключения = "", ПроверятьНаличиеРеквизита = Истина) Экспорт
	
	РеквизитыПроверки = СтрРазделить(РеквизитыПроверки, " ,", Ложь);
	РеквизитыИсключения = СтрРазделить(РеквизитыИсключения, " ,", Ложь);
	
	МетаданныеОбъекта = Объект1.Метаданные(); 
	
	МассивНаборовРеквизитов = Новый Массив;
	МассивНаборовРеквизитов.Добавить(МетаданныеОбъекта.СтандартныеРеквизиты);
	МассивНаборовРеквизитов.Добавить(МетаданныеОбъекта.Реквизиты);

	Для каждого НаборРеквизитов Из МассивНаборовРеквизитов Цикл
		Для каждого Реквизит Из НаборРеквизитов Цикл
			
			Если ЗначениеЗаполнено(РеквизитыПроверки) 
				И РеквизитыПроверки.Найти(Реквизит.Имя) = Неопределено Тогда
				Продолжить
			КонецЕсли;	
			
			Если РеквизитыИсключения.Найти(Реквизит.Имя) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Объект2, Реквизит.Имя) Тогда
				Если ПроверятьНаличиеРеквизита Тогда
					Возврат Ложь;
				Иначе
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			Если Объект1[Реквизит.Имя] <> Объект2[Реквизит.Имя] Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
			
	Для каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
			
		Если РеквизитыИсключения.Найти(ТабличнаяЧасть.Имя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
				
		РеквизитыТЧ = Новый Массив;
		Для каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
			
			ПолноеИмяРеквизита = ТабличнаяЧасть.Имя + "." + Реквизит.Имя;
			
			Если ЗначениеЗаполнено(РеквизитыПроверки) 
				И РеквизитыПроверки.Найти(ТабличнаяЧасть.Имя) = Неопределено
				И РеквизитыПроверки.Найти(ПолноеИмяРеквизита) = Неопределено Тогда
				Продолжить
			КонецЕсли;
			
			Если РеквизитыИсключения.Найти(ПолноеИмяРеквизита) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
						
			РеквизитыТЧ.Добавить(Реквизит.Имя);
			
		КонецЦикла;
		
		Если ЗначениеЗаполнено(РеквизитыТЧ) Тогда
			
			Если НЕ ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Объект2, ТабличнаяЧасть.Имя) Тогда
				Если ПроверятьНаличиеРеквизита Тогда
					Возврат Ложь;
				Иначе
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			Если Объект1[ТабличнаяЧасть.Имя].Количество() <> Объект2[ТабличнаяЧасть.Имя].Количество() Тогда
				Возврат Ложь;
			КонецЕсли;
			
			Для каждого СтрокаТЧ1 Из Объект1[ТабличнаяЧасть.Имя] Цикл
				
				ИндексСтроки = Объект1[ТабличнаяЧасть.Имя].Индекс(СтрокаТЧ1);
				СтрокаТЧ2 = Объект2[ТабличнаяЧасть.Имя][ИндексСтроки];
				
				Для каждого ИмяРеквизита Из РеквизитыТЧ Цикл
					
					Если НЕ ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(СтрокаТЧ2, ИмяРеквизита) Тогда
						Если ПроверятьНаличиеРеквизита Тогда
							Возврат Ложь;
						Иначе
							Продолжить;
						КонецЕсли;
					КонецЕсли;
					
					Если СтрокаТЧ1[ИмяРеквизита] <> СтрокаТЧ2[ИмяРеквизита] Тогда
						Возврат Ложь;
					КонецЕсли;		
				КонецЦикла;		
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// не должно быть одинаковых строк в таблице иначе алгоритм будет неправильно работать
Функция ИзменитсяТабличнаяЧастьПриЗагрузкеДанных(ТабЧасть, ТаблицаНовыхЗначений) Экспорт
	
	Если ТабЧасть.Количество() <> ТаблицаНовыхЗначений.Количество() Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если ТаблицаНовыхЗначений.Количество() = 0 Тогда
		Возврат Ложь
	КонецЕсли;
	
	КолонкиТабЧасти = ТабЧасть.ВыгрузитьКолонки().Колонки;
		
	// сформируем строку индекса для оптимизации поиска по таблице значений
	СтрокаИндекса = "";
	СтруктураПоиска = Новый Структура;
	Для каждого Колонка Из ТаблицаНовыхЗначений.Колонки Цикл
		Если Колонка.Имя <> "НомерСтроки" И Колонка.Имя <> "LineNumber"
			И КолонкиТабЧасти.Найти(Колонка.Имя) <> Неопределено Тогда
			
			СтрокаИндекса = СтрокаИндекса + "," + Колонка.Имя;
			СтруктураПоиска.Вставить(Колонка.Имя);
		КонецЕсли;	
	КонецЦикла;
	
	Если СтруктураПоиска.Количество() = 0 Тогда
		// нет общих колонок
		Возврат Истина;
	КонецЕсли;
	
	СтрокаИндекса = Сред(СтрокаИндекса, 2);
	
	// добавим индекс
	ТаблицаНовыхЗначений.Индексы.Добавить(СтрокаИндекса);
			
	// Проверим записи
	Для каждого СтрокаТЧ Из ТабЧасть Цикл	
		ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаТЧ);
		СтрокиНовыхЗначений = ТаблицаНовыхЗначений.НайтиСтроки(СтруктураПоиска);
		Если СтрокиНовыхЗначений.Количество() <> 1 Тогда
			Возврат Истина;
		КонецЕсли; 
	КонецЦикла;
		
	Возврат Ложь;
	
КонецФункции // ИзменитсяТабличнаяЧастьПриЗагрузкеДанных

Процедура ЗаполнитьКолонкиТаблицыЗначений(ТаблицаЗначений,ДанныеЗаполнения) Экспорт
	
	Для Каждого КлючИЗначение ИЗ ДанныеЗаполнения Цикл
		
		Если НЕ ТаблицаЗначений.Колонки.Найти(КлючИЗначение.Ключ)=Неопределено Тогда
			
			ТаблицаЗначений.ЗаполнитьЗначения(КлючИЗначение.Значение,КлючИЗначение.Ключ);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьКолонкиТаблицыЗначений()

Функция ПолучитьСтрокуИзСпискаЗначений(СписокЗначений) Экспорт
	
	Если СписокЗначений=Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	СтрокаСписок="";
	
	Для Каждого Элемент ИЗ СписокЗначений Цикл
		СтрокаСписок=СтрокаСписок+";"+Элемент.Значение;
	КонецЦикла;
	
	Возврат Сред(СтрокаСписок,2);
	
КонецФункции // ПолучитьСтрокуИзСпискаЗначений()

Функция ПолучитьСтрокуИзСпискаЗначенийПоПредставлению(СписокЗначений) Экспорт
	
	Если СписокЗначений=Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	СтрокаСписок="";
	
	Для Каждого Элемент ИЗ СписокЗначений Цикл
		СтрокаСписок=СтрокаСписок+";"+?(ЗначениеЗаполнено(Элемент.Представление),Элемент.Представление,Элемент.Значение);
	КонецЦикла;
	
	Возврат Сред(СтрокаСписок,2);
	
КонецФункции // ПолучитьСтрокуИзСпискаЗначений()

Функция СписокЗначенийНайтиПоПредставлению(СписокЗначений,Представление) Экспорт
	
	Для Каждого Элемент ИЗ СписокЗначений Цикл
		
		Если Элемент.Представление=Представление Тогда
			
			Возврат Элемент;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
		
КонецФункции // 
	

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт
	
	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;
	
КонецФункции // ПолучитьСписокЭлементовПеречисления()


// Процедура проверяет уникальность строк табличной части
//
Процедура ПроверитьУникальностьСтрокТабличнойЧасти(ТабличнаяЧасть, ИмяКолонки, Отказ, ШапкаОшибки, ЗапретНезаполненныхЗначений = Ложь) Экспорт
	
	СоответствиеНеуникальных = Новый Соответствие;
	
	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
		
		Значение = СтрокаТаблицы[ИмяКолонки];
		СтрокаВстречалась = СоответствиеНеуникальных[Значение];
		
		Если СтрокаВстречалась = Неопределено Тогда
			
			
			СоответствиеНеуникальных.Вставить(Значение, 1);
			Если ЗапретНезаполненныхЗначений и НЕ(ЗначениеЗаполнено(Значение)) Тогда
				
				МетаданныеТЧ         = Метаданные.НайтиПоТипу(ТипЗНЧ(ТабличнаяЧасть));
				ПредставлениеКолонки = МетаданныеТЧ.Реквизиты[ИмяКолонки].Представление();
				ПредставлениеТЧ      = МетаданныеТЧ.Представление();
				СообщитьОбОшибке(СтрШаблон(Нстр("ru = 'Значение реквизита ""%1"" в табличной части ""%2"" строка:%3 не может быть пустым!'"), 
				                 	ПредставлениеКолонки, ПредставлениеТЧ, СтрокаТаблицы.НомерСтроки), Отказ, ШапкаОшибки);
				
			КонецЕсли;
			
		Иначе
			Если СтрокаВстречалась = 1 Тогда
				МетаданныеТЧ         = Метаданные.НайтиПоТипу(ТипЗНЧ(ТабличнаяЧасть));
				ПредставлениеКолонки = МетаданныеТЧ.Реквизиты[ИмяКолонки].Представление();
				ПредставлениеТЧ      = МетаданныеТЧ.Представление();
				СоответствиеНеуникальных.Вставить(Значение, 2);
				СообщитьОбОшибке(СтрШаблон(Нстр("ru = 'Значение ""%1"" реквизита ""%2"" в табличной части ""%3"" не уникально!'"), 
				                 	Значение, ПредставлениеКолонки, ПредставлениеТЧ), Отказ, ШапкаОшибки);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура вставляет ключи в структуру, если их там нет.
//
// Параметры:
//  Структура - Структура, в которую добавляются ключи.
//  Ключи     - Строка - список ключей, разделенных запятыми.
//
Процедура ВставитьКлючи(Структура, Знач Ключи) Экспорт
	
	Ключи = СтрЗаменить(Ключи, " ", "");
	Ключи = СтрЗаменить(Ключи, ",", Символы.ПС);
	
	Для Номер = 1 По СтрЧислоСтрок(Ключи) Цикл
		Ключ = СтрПолучитьСтроку(Ключи, Номер);
		
		Если НЕ ПустаяСтрока(Ключ) Тогда
			Структура.Вставить(Ключ);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет стркутуру представлений реквизтов.
//
// Параметры:
//  СтруктураРеквизитов - (Структуура) - ключ - имя реквизита, значение - представление реквизита.
//  КоллекцияРеквизитов - (Коллекция ОбъектМетаданных) - коллекция реквизитов.
//
Процедура ЗаполнитьПредставленияРеквизитов(СтруктураРеквизитов, КоллекцияРеквизитов) Экспорт
	
	Для каждого Реквизит Из КоллекцияРеквизитов Цикл
		СтруктураРеквизитов.Вставить(Реквизит.Имя, Реквизит.Представление());
	КонецЦикла;
	
КонецПроцедуры

// Проверяет не изменяемые реквизиты объекта.
// У объекта должен быть определен экспортируемый метод НеИзменяемыеРеквизиты().
// У объекта должена быть определена экспортируемая переменная СтруктураРеквизитов.
//
// Параметры:
//  Объект    - объект, реквизиты которого проверяются.
//  Отказ     - Истина, если проверка выявила проблемы. В противном случае не меняется.
//              В параметр удобно передавать параметр Отказ обработчика ПередЗаписью.
//  Сообщение - строка, в которую будут дописаны "замечания", выявленные при проверке.
//              Сформированная таким образом строка может использоваться в вызывающей
//              процедуре в качестве сообщения или предупреждения.
//
Процедура ПроверитьНеИзменяемыеРеквизиты(Объект, Отказ, ШапкаОшибки = "") Экспорт
	
	Если Объект.Ссылка.Пустая() Тогда
		Возврат;
	КонецЕсли;
	
	Для каждого ЭлементСтруктуры Из Объект.НеИзменяемыеРеквизиты() Цикл
		ИмяРеквизита = ЭлементСтруктуры.Ключ;
		
		Если Объект.Метаданные().ТабличныеЧасти.Найти(ИмяРеквизита) = Неопределено Тогда
			Если Объект[ИмяРеквизита] <> Объект.Ссылка[ИмяРеквизита] Тогда
				СообщитьОбОшибке(СтрШаблон(Нстр("ru = '- Запрещено изменение реквизита ""%1%2"".'"), 
				                 	Объект.СтруктураРеквизитов, Объект.СтруктураРеквизитов[ИмяРеквизита]), Отказ,  ШапкаОшибки);
			КонецЕсли;
		Иначе
			Если ЗначениеВСтрокуВнутр(Объект[ИмяРеквизита].Выгрузить()) <> ЗначениеВСтрокуВнутр(Объект.Ссылка[ИмяРеквизита].Выгрузить()) Тогда
				СообщитьОбОшибке(СтрШаблон(Нстр("ru = '- Запрещено изменение табличной части ""%1%2"".'"), 
				                 	Объект.СтруктураРеквизитов, Объект.СтруктураРеквизитов[ИмяРеквизита]), Отказ,  ШапкаОшибки);
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Считывает значение настройки из структуры настроек и присваивает его приемнику, 
// выполняя необходимые проверки
//
// Параметры:
//  СтруктураНастроек - Структура - структура применяемых настроек.
//  КлючЗначения      - Строка - ключ применяемой настройки.
//  ПриемникЗначения  - в этот параметр будет записано значение настройки.
//  ТипЗначения       - Строка - тип, который должно иметь значение настройки.
//
Процедура ПрименитьЭлементНастройкиФормы(СтруктураНастроек, КлючЗначения, ПриемникЗначения, ТипЗначения) Экспорт
	
	Перем Значение;
	
	Если ТипЗнч(СтруктураНастроек) = Тип("Структура") Тогда
		СтруктураНастроек.Свойство(КлючЗначения, Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип(ТипЗначения) Тогда
		ПриемникЗначения = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Процедура заполняет представления элементов всех коллекций построителя отчета на
//  основании соответствия имен и представдлений переданных в параметре
//
// Параметры
//  СтруктураСоответствияИмен - Структура, ключ - имя поля, значение - представление поля
//  ПостроительОтчета         - ПостроительОтчета
//
//  Возвращаемое значение
//   НЕТ
//
Процедура ЗаполнитьПредставленияПолей(СтруктураСоответствияИмен, ПостроительОтчета) Экспорт
	
	СтруктураКоллекцийПостроителяОтчета = Новый Структура("ДоступныеПоля, ВыбранныеПоля, ИзмеренияКолонки, ИзмеренияСтроки, Отбор");
	
	Для каждого ЭлементСтруктуры Из СтруктураКоллекцийПостроителяОтчета Цикл
		Для а = 0 По ПостроительОтчета[ЭлементСтруктуры.Ключ].Количество() - 1 Цикл
			Если ПустаяСтрока(ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя) Тогда
				Продолжить;
			КонецЕсли;
			Если СтруктураСоответствияИмен.Свойство(ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя) Тогда
				ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Представление = СтруктураСоответствияИмен[ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя];
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
	
КонецПроцедуры // ЗаполнитьПредставленияПолей()

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//		ИсхСумма - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность - точность округления при распределении. Необязателен.
//      ПроверкаНулевыхЗначений - определяет, будут ли распределяться нулевые значения
//      ИмяКолонки - имя колонки, содержещей коэффициент для распределения в случае, если передан массив строк
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина,ИмяКолонки="") Экспорт
	
	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СуммаКоэф  = 0;
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		СуммаКоэф = СуммаКоэф + ?(ИмяКолонки="",МассивКоэф[К],МассивКоэф[К][ИмяКолонки]);
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		
		ТекКоэфф=?(ИмяКолонки="",МассивКоэф[К],МассивКоэф[К][ИмяКолонки]);
		
		МассивСумм[К] = ?(СуммаКоэф <> 0, Окр(ИсхСумма * ТекКоэфф / СуммаКоэф, Точность, 1), 0);
		ИсхСумма = ИсхСумма - МассивСумм[К]; 
		СуммаКоэф = СуммаКоэф - ТекКоэфф; 
	КонецЦикла;
	
	Возврат МассивСумм;
	
КонецФункции // РаспределитьПропорционально()

Функция ПроверитьОбъектПередУдалением(Ссылка) Экспорт
	
	СсылкиНаОбъект=Новый Структура;
	ЗапросПоказатели=Новый Запрос;
	ЗапросРегистр=Новый Запрос;
	
	ТекстОтбор="";
	
	Если ТипЗнч(Ссылка)=Тип("СправочникСсылка.СтрокиОтчетов") Тогда
		
		ЗапросПоказатели.Текст="ВЫБРАТЬ
		|	КОЛИЧЕСТВО(ПоказателиОтчетов.Ссылка) КАК КоличествоПоказателей
		|ИЗ
		|	Справочник.ПоказателиОтчетов КАК ПоказателиОтчетов
		|ГДЕ
		|	ПоказателиОтчетов.Строка = &Строка
		|	И (НЕ ПоказателиОтчетов.ПометкаУдаления)";
		
		ЗапросПоказатели.УстановитьПараметр("Строка",Ссылка);	
		Результат=ЗапросПоказатели.Выполнить().Выбрать();
		
		Если Результат.Следующий() Тогда
			
			СсылкиНаОбъект.Вставить("КоличествоПоказателей",Результат.КоличествоПоказателей);
			
		Иначе
			
			СсылкиНаОбъект.Вставить("КоличествоПоказателей",0);
			
		КонецЕсли;
		
		ТекстОтбор="
		|ГДЕ
		|	####.Показатель.Строка = &Строка";
		
		ЗапросРегистр.УстановитьПараметр("Строка",Ссылка);
		
	ИначеЕсли ТипЗнч(Ссылка)=Тип("СправочникСсылка.КолонкиОтчетов") Тогда
		
		ЗапросПоказатели.Текст="ВЫБРАТЬ
		|	КОЛИЧЕСТВО(ПоказателиОтчетов.Ссылка) КАК КоличествоПоказателей
		|ИЗ
		|	Справочник.ПоказателиОтчетов КАК ПоказателиОтчетов
		|ГДЕ
		|	ПоказателиОтчетов.Колонка = &Колонка
		|	И (НЕ ПоказателиОтчетов.ПометкаУдаления)";
		
		ЗапросПоказатели.УстановитьПараметр("Колонка",Ссылка);	
		Результат=ЗапросПоказатели.Выполнить().Выбрать();
		
		Если Результат.Следующий() Тогда
			
			СсылкиНаОбъект.Вставить("КоличествоПоказателей",Результат.КоличествоПоказателей);
			
		Иначе
			
			СсылкиНаОбъект.Вставить("КоличествоПоказателей",0);
			
		КонецЕсли;
		
		ТекстОтбор="
		|ГДЕ
		|	####.Показатель.Колонка = &Колонка";
		
		ЗапросРегистр.УстановитьПараметр("Колонка",Ссылка);
		
	Иначе
		
		ТекстОтбор="
		|ГДЕ
		|	####.Показатель = &Показатель";
		
		ЗапросРегистр.УстановитьПараметр("Показатель",Ссылка);
		
		
	КонецЕсли;
	
	ЗапросРегистр.Текст="ВЫБРАТЬ
	|СУММА(ДанныеРегистров.КоличествоЗаписей) КАК КоличествоЗаписей
	|ИЗ
	|(
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(ЗначенияПоказателейОтчетовСинтетика.Показатель) КАК КоличествоЗаписей
	|ИЗ
	|	РегистрСведений.ЗначенияПоказателейОтчетовСинтетика КАК ЗначенияПоказателейОтчетовСинтетика"+СтрЗаменить(ТекстОтбор,"####","ЗначенияПоказателейОтчетовСинтетика")+"
	|ОБЪЕДИНИТЬ ВСЕ
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(ЗначенияПоказателейОтчетов1.Показатель)
	|ИЗ
	|	РегистрСведений.ЗначенияПоказателейОтчетов1 КАК ЗначенияПоказателейОтчетов1"+СтрЗаменить(ТекстОтбор,"####","ЗначенияПоказателейОтчетов1")+"
	|ОБЪЕДИНИТЬ ВСЕ
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(ЗначенияПоказателейОтчетов2.Показатель)
	|ИЗ
	|	РегистрСведений.ЗначенияПоказателейОтчетов2 КАК ЗначенияПоказателейОтчетов2"+СтрЗаменить(ТекстОтбор,"####","ЗначенияПоказателейОтчетов2")+"
	|ОБЪЕДИНИТЬ ВСЕ
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(ЗначенияПоказателейОтчетов3.Показатель)
	|ИЗ
	|	РегистрСведений.ЗначенияПоказателейОтчетов3 КАК ЗначенияПоказателейОтчетов3"+СтрЗаменить(ТекстОтбор,"####","ЗначенияПоказателейОтчетов3")+"
	|ОБЪЕДИНИТЬ ВСЕ
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(ЗначенияПоказателейОтчетов4.Показатель)
	|ИЗ
	|	РегистрСведений.ЗначенияПоказателейОтчетов4 КАК ЗначенияПоказателейОтчетов4"+СтрЗаменить(ТекстОтбор,"####","ЗначенияПоказателейОтчетов4")+"
	|ОБЪЕДИНИТЬ ВСЕ
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(ЗначенияПоказателейОтчетов5.Показатель)
	|ИЗ
	|	РегистрСведений.ЗначенияПоказателейОтчетов5 КАК ЗначенияПоказателейОтчетов5"+СтрЗаменить(ТекстОтбор,"####","ЗначенияПоказателейОтчетов5")+"
	|ОБЪЕДИНИТЬ ВСЕ
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(ЗначенияПоказателейОтчетовНечисловые.Показатель)
	|ИЗ
	|	РегистрСведений.ЗначенияПоказателейОтчетовНечисловые КАК ЗначенияПоказателейОтчетовНечисловые"+СтрЗаменить(ТекстОтбор,"####","ЗначенияПоказателейОтчетовНечисловые")+") КАК ДанныеРегистров";
	
	Результат=ЗапросРегистр.Выполнить().Выбрать();
	Если Результат.Следующий() Тогда
		
		СсылкиНаОбъект.Вставить("КоличествоЗаписей",Результат.КоличествоЗаписей);
		
	Иначе
		
		СсылкиНаОбъект.Вставить("КоличествоЗаписей",0);
		
	КонецЕсли;
	
	Возврат СсылкиНаОбъект;
	
КонецФункции // ПроверитьОбъектПередУдалением()

Процедура ПометитьСправочникПоРеквизиту(ИмяСправочника,ИмяРеквизита,ЗначениеРеквизита,Пометка,Отказ) Экспорт
	
	Запрос=Новый Запрос;
	
	ТекстОтборПоРеквизитам="";
	
	Если Не ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Если ТипЗнч(ИмяРеквизита)=Тип("Массив") Тогда
		
		Для Каждого Реквизит ИЗ ИмяРеквизита Цикл
			
			ТекстОтборПоРеквизитам=ТекстОтборПоРеквизитам+" ИЛИ "+ИмяСправочника+"."+Реквизит+"=&ЗначениеРеквизита";
			
		КонецЦикла;
		
		ТекстОтборПоРеквизитам="("+Сред(ТекстОтборПоРеквизитам,5)+")";
		
	Иначе
		
		ТекстОтборПоРеквизитам=ИмяСправочника+"."+ИмяРеквизита+"=&ЗначениеРеквизита";
		
	КонецЕсли;
	
	Запрос.Текст="ВЫБРАТЬ
	|"+ИмяСправочника+".Ссылка
	|ИЗ
	|	Справочник."+ИмяСправочника+" КАК "+ИмяСправочника+"
	|ГДЕ
	|	(НЕ "+ИмяСправочника+".ПометкаУдаления=&ПометкаУдаления)
	|	И "+ТекстОтборПоРеквизитам;
	
	Запрос.УстановитьПараметр("ЗначениеРеквизита",ЗначениеРеквизита);
	Запрос.УстановитьПараметр("ПометкаУдаления",Пометка);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		ОбъектСправочник=Результат.Ссылка.ПолучитьОбъект();
		ОбъектСправочник.ПометкаУдаления=Пометка;
		ОбъектСправочник.ОбменДанными.Загрузка=Истина;
				
		Попытка
			
			ОбъектСправочник.Записать();
		Исключение
			
			ТекстСообщения = НСтр("ru = 'Не удалось изменить пометку удаления для элемента справочника
                                  |			%ИмяСправочника% %РезультатСсылка%
                                  |			%ОписаниеОшибки%'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ИмяСправочника%", Строка(ИмяСправочника));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%РезультатСсылка%", Строка(Результат.Ссылка));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОписаниеОшибки%", ОписаниеОшибки());
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, Отказ, , СтатусСообщения.Внимание);
			
			Возврат;
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры // ПометитьСправочникПоРеквизиту()

Процедура ПометитьСправочникПоРеквизитуТЧ(ИмяСправочника,ИмяТЧ,ИмяРеквизитаТЧ,ЗначениеРеквизитаТЧ,Пометка,Отказ) Экспорт
	
	ТекстОтборПоРеквизитам="";
	
	Если ТипЗнч(ИмяРеквизитаТЧ)=Тип("Массив") Тогда
		
		Для Каждого Реквизит ИЗ ИмяРеквизитаТЧ Цикл
			
			ТекстОтборПоРеквизитам=ТекстОтборПоРеквизитам+" ИЛИ "+ИмяСправочника+ИмяТЧ+"."+Реквизит+"=&ЗначениеРеквизита";
			
		КонецЦикла;
		
		ТекстОтборПоРеквизитам="("+Сред(ТекстОтборПоРеквизитам,5)+")";
		
	Иначе
		
		ТекстОтборПоРеквизитам=ИмяСправочника+ИмяТЧ+"."+ИмяРеквизитаТЧ+"=&ЗначениеРеквизита";
		
	КонецЕсли;	
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|"+ИмяСправочника+ИмяТЧ+".Ссылка
	|ИЗ
	|	Справочник."+ИмяСправочника+"."+ИмяТЧ+" КАК "+ИмяСправочника+ИмяТЧ+"
	|ГДЕ
	|	(НЕ "+ИмяСправочника+ИмяТЧ+".Ссылка.ПометкаУдаления = &ПометкаУдаления)
	|	И "+ТекстОтборПоРеквизитам;
	
	Запрос.УстановитьПараметр("ЗначениеРеквизита",ЗначениеРеквизитаТЧ);
	Запрос.УстановитьПараметр("ПометкаУдаления",Пометка);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		ОбъектСправочник=Результат.Ссылка.ПолучитьОбъект();
		ОбъектСправочник.ПометкаУдаления=Пометка;
		ОбъектСправочник.ОбменДанными.Загрузка=Истина;
		
		Попытка
			
			ОбъектСправочник.Записать();
			
		Исключение
			ТекстСообщения = НСтр("ru = 'Не удалось изменить пометку удаления для элемента справочника
                                  |			%ИмяСправочника% %РезультатСсылка%:
                                  |			%ОписаниеОшибки%'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ИмяСправочника%", Строка(ИмяСправочника));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%РезультатСсылка%", Строка(Результат.Ссылка));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОписаниеОшибки%", ОписаниеОшибки());
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, Отказ , , СтатусСообщения.Внимание);
			
			Возврат;
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры // ПометитьСправочникПоРеквизиту()

Процедура УдалитьИнформациюОКоординатах(ЭлементСтруктуры,Отказ) Экспорт
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	БланкиОтчетовАдресаЭлементовСтруктурыОтчета.Ссылка
	|ИЗ
	|	Справочник.БланкиОтчетов.АдресаЭлементовСтруктурыОтчета КАК БланкиОтчетовАдресаЭлементовСтруктурыОтчета
	|ГДЕ
	|	БланкиОтчетовАдресаЭлементовСтруктурыОтчета.Элемент = &Элемент";
	
	Запрос.УстановитьПараметр("Элемент",ЭлементСтруктуры);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		БланкОбъект=Результат.Ссылка.ПолучитьОбъект();
		
		СтрокаЭлемент=БланкОбъект.АдресаЭлементовСтруктурыОтчета.Найти(ЭлементСтруктуры,"Элемент");
		
		Если Не СтрокаЭлемент=Неопределено Тогда
			
			БланкОбъект.АдресаЭлементовСтруктурыОтчета.Удалить(СтрокаЭлемент);
			
			Попытка
				
				БланкОбъект.Записать();
				
			Исключение
				
				ТекстСообщения = НСтр("ru = 'Не удалось удалить координаты для элемента структуры отчета
                                      |				%ЭлементСтруктуры%:
                                      |				%ОписаниеОшибки%'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ЭлементСтруктуры%", Строка(ЭлементСтруктуры));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОписаниеОшибки%", ОписаниеОшибки());
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, Отказ, , СтатусСообщения.Внимание);
				
				Возврат;
				
			КонецПопытки;
			
		КонецЕсли;
		
	КонецЦикла;
		
КонецПроцедуры // УдалитьИнформациюОКоординатах()

Функция ПолучитьСтруктуруРеквизитовОбъекта(Объект,СтруктураРеквизитов=Неопределено) Экспорт
	
	Если СтруктураРеквизитов=Неопределено Тогда
		СтруктураРеквизитов=Новый Структура;
	КонецЕсли;
	
	Для Каждого Реквизит ИЗ Объект.Метаданные().Реквизиты Цикл
		
		СтруктураРеквизитов.Вставить(Реквизит.Имя, Объект[Реквизит.Имя]);
		
	КонецЦикла;
	
	Если ЕстьРеквизитОбъекта("Ссылка", Объект) Тогда
		СтруктураРеквизитов.Вставить("Ссылка", Объект.Ссылка);
	Иначе
		СтруктураРеквизитов.Вставить("Ссылка",Неопределено);
	КонецЕсли;
	
	Возврат СтруктураРеквизитов;
		
КонецФункции // ПолучитьСтруктуруРеквизитовОбъекта()

Функция СтруктураСвойствОбъекта(Объект, МетаданныеОбъекта = Неопределено, НужныТабличныеЧасти = Истина) Экспорт
	
	СтруктураСвойств = Новый Структура;
	Если МетаданныеОбъекта  = Неопределено Тогда
		МетаданныеОбъекта = Объект.Метаданные();
	КонецЕсли;	
	
	Для Каждого Реквизит ИЗ МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		СтруктураСвойств.Вставить(Реквизит.Имя, Объект[Реквизит.Имя]);	
	КонецЦикла;
	
	Для Каждого Реквизит ИЗ МетаданныеОбъекта.Реквизиты Цикл
		СтруктураСвойств.Вставить(Реквизит.Имя, Объект[Реквизит.Имя]);	
	КонецЦикла;
	
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Объект, "Ссылка") Тогда
		СтруктураСвойств.Вставить("Ссылка", Объект.Ссылка);
	Иначе
		СтруктураСвойств.Вставить("Ссылка", Неопределено);
	КонецЕсли;
	
	Если НужныТабличныеЧасти Тогда
		Для каждого ТабЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
			ТЗ = Объект[ТабЧасть.Имя].Выгрузить();
			СтруктураСвойств.Вставить(ТабЧасть.Имя, ТЗ); 
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтруктураСвойств;
	
КонецФункции

Функция СтруктураРеквизитовОбъекта(МетаданныеОбъекта) Экспорт
	
	СтруктураРеквизитов = Новый Структура;
		
	Для Каждого Реквизит ИЗ МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		СтруктураРеквизитов.Вставить(Реквизит.Имя);	
	КонецЦикла;
	
	Для Каждого Реквизит ИЗ МетаданныеОбъекта.Реквизиты Цикл
		СтруктураРеквизитов.Вставить(Реквизит.Имя);	
	КонецЦикла;
	
	Возврат СтруктураРеквизитов;
	
КонецФункции

Функция ИменаРеквизитовОбъекта(МетаданныеОбъекта) Экспорт
	
	МассивИмен = Новый Массив;
	
	Для Каждого Реквизит ИЗ МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		МассивИмен.Добавить(Реквизит.Имя);	
	КонецЦикла;
	
	Для Каждого Реквизит ИЗ МетаданныеОбъекта.Реквизиты Цикл
		МассивИмен.Добавить(Реквизит.Имя);	
	КонецЦикла; 
	
	Для каждого Реквизит Из Метаданные.ОбщиеРеквизиты Цикл
		
		Если Реквизит.Имя = "ОбластьДанныхОсновныеДанные" 
			ИЛИ Реквизит.Имя="ОбластьДанныхВспомогательныеДанные"
			ИЛИ Реквизит.Имя="DataAreaMainData" 
			ИЛИ Реквизит.Имя="DataAreaAuxiliaryData" Тогда
			
			Продолжить;	
			
		КонецЕсли;
		
		ИспользованиеРеквизита = Реквизит.Content.Find(МетаданныеОбъекта.Имя);
		АвтоИспользование = (Реквизит.AutoUse = Метаданные.ObjectProperties.CommonAttributeAutoUse.Use);
		
		Если ИспользованиеРеквизита.Use = Метаданные.ObjectProperties.CommonAttributeUse.DontUse Тогда
			Продолжить;				
		ИначеЕсли НЕ АвтоИспользование И (ИспользованиеРеквизита.Use = Метаданные.ObjectProperties.CommonAttributeUse.Auto) Тогда 
			Продолжить;
		КонецЕсли;
		
		МассивИмен.Добавить(Реквизит.Имя);		
		
	КонецЦикла;
	
	Возврат МассивИмен;
	
КонецФункции	

Процедура ЗаполнитьИзмененныеРеквизиты(Объект, ЗначенияРеквизитов, ИсключаемыеСвойства, ЕстьИзменения) Экспорт
	
	Если ЕстьИзменения Тогда
		ЗаполнитьЗначенияСвойств(Объект, ЗначенияРеквизитов,, ИсключаемыеСвойства);
		Возврат;
	КонецЕсли;		
	
	ИменаРеквизитов = ОбщегоНазначенияУХ.ИменаРеквизитовОбъекта(Объект.Метаданные());
	ИменаОбщихРеквизитов = Новый Массив;
	ИменаОбщихСвойств = Новый Массив;	
	МассивИсключаемыхСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		ИсключаемыеСвойства, ",",, Истина);
	
	Для каждого Элемент Из ЗначенияРеквизитов Цикл
		ИмяСвойства = Элемент.Ключ; 
		Если МассивИсключаемыхСвойств.Найти(ИмяСвойства) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ИменаРеквизитов.Найти(ИмяСвойства) <> Неопределено Тогда
			ИменаОбщихРеквизитов.Добавить(Элемент.Ключ);
		ИначеЕсли ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Объект, ИмяСвойства) Тогда
			ИменаОбщихСвойств.Добавить(ИмяСвойства); 		 
		КонецЕсли;
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСерверУХ.ЗаполнитьЗначенияОтличающихсяСвойств(Объект, ЗначенияРеквизитов, ИменаОбщихРеквизитов,, 
		ЕстьИзменения);
	
	Если ЗначениеЗаполнено(ИменаОбщихСвойств) Тогда
		ЗаполнитьЗначенияСвойств(Объект, ЗначенияРеквизитов, СтрСоединить(ИменаОбщихСвойств, ","));
	КонецЕсли;	

КонецПроцедуры

Процедура ЗагрузитьИзмененнуюТабЧасть(ТабЧасть, ТаблицаНовыхЗначений, ЕстьИзменения) Экспорт
	
	Если НЕ ЕстьИзменения Тогда		
		ЕстьИзменения = ИзменитсяТабличнаяЧастьПриЗагрузкеДанных(ТабЧасть, ТаблицаНовыхЗначений);
	КонецЕсли;

	Если ЕстьИзменения Тогда
		ТабЧасть.Загрузить(ТаблицаНовыхЗначений);
	КонецЕсли;	
	
КонецПроцедуры

Функция ПолучитьРабочийОбъект(ДанныеОбъекта) Экспорт
	
	Если ТипЗнч(ДанныеОбъекта)=Тип("Структура") Тогда
		СтруктураОбъект=ДанныеОбъекта;
	Иначе		
		Если ЭтоАдресВременногоХранилища(ДанныеОбъекта) Тогда
			СтруктураОбъект	= ПолучитьИзВременногоХранилища(ДанныеОбъекта);
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтруктураОбъект.Ссылка) Тогда
		
		РабочийОбъект=Вычислить(СтруктураОбъект.ПроцедураСозданияОбъекта);
		
	Иначе
		
		РабочийОбъект=СтруктураОбъект.Ссылка.ПолучитьОбъект();
		
	КонецЕсли;
	
	РабочийОбъект.ВосстановитьПеременныеДляРасчета(СтруктураОбъект);
	
	Если СтруктураОбъект.Свойство("РеквизитыОбъекта") Тогда
		
		ЗаполнитьЗначенияСвойств(РабочийОбъект,СтруктураОбъект.РеквизитыОбъекта);
		
	КонецЕсли; 
	
	Если СтруктураОбъект.Свойство("ТабличныеЧастиОбъекта") Тогда
		
		Для Каждого ТабличнаяЧасть ИЗ СтруктураОбъект.ТабличныеЧастиОбъекта Цикл
			
			РабочийОбъект[ТабличнаяЧасть.Ключ].Загрузить(ТабличнаяЧасть.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат РабочийОбъект;
		
КонецФункции // ПолучитьРабочийОбъект()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С КОДАМИ ЭЛЕМЕНТОВ СПРАВОЧНИКОВ.

// Функция заменяет все не алфавитноцифровые символы на знак подчеркивания.
// Параметры
//  Код            - Строка, Значение кода, которое необходимо преобразовать.
// Возвращаемое значение
//  Строка, преобразованное значение кода.
//
Функция ВернутьАлфавитноЦифровоеПредставление(Код, РазрешитьЦифрыВНачале = Ложь,
					РазрешитьСлужебныеСимволы = Ложь, ЗаменятьНеправильные=Истина) Экспорт
	Возврат ОбщегоНазначенияКлиентСерверУХ.ВернутьАлфавитноЦифровоеПредставление(
				Код,
				РазрешитьЦифрыВНачале,
				РазрешитьСлужебныеСимволы,
				ЗаменятьНеправильные);
КонецФункции

Функция РусАнгАлфавитВспомогательныеСимволы(Символ) Экспорт
	
	Возврат ОбщегоНазначенияКлиентСерверУХ.РусАнгАлфавитВспомогательныеСимволы(Символ);
	
КонецФункции // РусАнгАлфавитВспомогательныеСимволы(Символ) 

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МЕХАНИЗМ ПОРЯДКОВЫХ НОМЕРОВ СПРАВОЧНИКА

// Функция возвращает новое значения реквизита "ПорядковыйНомер"
//
// Объект   - Тип СправочникОбъект. 
// ИмяРеквизитовРодителя - Строка, имя реквизита, в пределов которых поддерживается уникальность порядковых номеров
//
Функция ПолучитьНовыйПорядковыйНомер(Объект, ИмяРеквизитовРодителя = "Родитель")
	
	ИмяСправочника = Объект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	|	Справочник.ПорядковыйНомер КАК ПорядковыйНомер
	|ИЗ
	|	Справочник."+ ИмяСправочника + " КАК Справочник
	|ГДЕ
	|	Не Справочник.ПометкаУдаления";
	Если Не Объект.Владелец = Неопределено Тогда
		Запрос.Текст = Запрос.Текст + "
		|	И Справочник.Владелец = &Владелец";
		Запрос.УстановитьПараметр("Владелец", Объект.Владелец);
	КонецЕсли;
	
	
	Для каждого КлючИЗначение Из Новый Структура(ИмяРеквизитовРодителя) Цикл
		Запрос.Текст = Запрос.Текст + "
		|И Справочник." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, Объект[КлючИЗначение.Ключ]);
	КонецЦикла;
	
	Запрос.Текст = Запрос.Текст + "
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПорядковыйНомер УБЫВ";
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат ?(ЗначениеЗаполнено(Выборка.ПорядковыйНомер), Выборка.ПорядковыйНомер, 0) + 1;
	Иначе
		Возврат 1;
	КонецЕсли; 
	
КонецФункции // ПолучитьНовыйПорядковыйНомер()

Функция ПолучитьМассивПрефиксовРИБ() Экспорт
	
	МассивПрефиксов = Новый Массив();
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ Различные
	|	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	|ИЗ
	|	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
	
	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			
			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
			
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат МассивПрефиксов;
	
КонецФункции

Функция СформироватьМассивПрефиксовДляРИБИОрганизации(Организация) Экспорт
	
	МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();	
	
	Если ЗначениеЗаполнено(Организация) Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			МассивПрефиксов.Добавить(Префикс);
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		МассивПрефиксов.Добавить("");
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "") Экспорт
	
	Возврат СтрШаблон(Нстр("ru = '%1 № %2 от %3 г.'"), НазваниеДокумента, Формат(ДокументОбъект.Номер,"ЧГ=0"), 
	        	Формат(ДокументОбъект.Дата, "ДФ='дд ММММ гггг'"));
	
КонецФункции // СформироватьЗаголовокДокумента()


// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено) Экспорт
	
	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;
	
	Номер   = СокрЛП(Документ.Номер);
	Префикс = "";
	Если МассивПрефиксов = Неопределено Тогда
		
		Организация = Неопределено;
		
		Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
			ИЛИ ТипЗнч(Документ) = Тип("Структура") Тогда
			
			Организация = Документ.Организация;
			
		Иначе
			
			Если ЕстьРеквизитОбъекта("Организация", Документ) Тогда
				
				Организация = Документ.Организация;
				
			КонецЕсли;
			
		КонецЕсли;
		
		МассивПрефиксовДляОбхода = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация)
		
	Иначе
		
		МассивПрефиксовДляОбхода = МассивПрефиксов;
		
	КонецЕсли;
	
	Для Каждого ТекущийПрефикс ИЗ МассивПрефиксовДляОбхода Цикл
		
		// удаление префикса из номера документа
		Если СтрНайти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Номер;
	
КонецФункции // ПолучитьНомерНаПечать()

// Процедура выполняет установку нового значения реквизита "ПорядковыйНомер" при необходимости
//
// Объект   - Тип СправочникОбъект. 
// ИмяРеквизитовРодителя - Строка, имя реквизита, в пределов которых поддерживается уникальность порядковых номеров
//
Процедура УстановитьНовыйПорядковыйНомерПриНеобходимости(Объект, ИмяРеквизитовРодителя = "Родитель") Экспорт
	
	Если Объект.ПометкаУдаления Тогда
		УстановитьНовоеЗначение(Объект.ПорядковыйНомер, 999999);
	Иначе
		УстанавливатьНовыйПорядковыйНомер = Объект.ПорядковыйНомер = 0 и Объект.ЭтоНовый() или Объект.ПорядковыйНомер = 999999;
		Если Не УстанавливатьНовыйПорядковыйНомер и Не Объект.ЭтоНовый() Тогда
			Для каждого КлючИЗначение Из Новый Структура(ИмяРеквизитовРодителя) Цикл
				Если Не Объект[КлючИЗначение.Ключ] = Объект.Ссылка[КлючИЗначение.Ключ] Тогда
					УстанавливатьНовыйПорядковыйНомер = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если УстанавливатьНовыйПорядковыйНомер Тогда
			УстановитьНовоеЗначение(Объект.ПорядковыйНомер, ПолучитьНовыйПорядковыйНомер(Объект, ИмяРеквизитовРодителя));
		КонецЕсли; 
		
	КонецЕсли;
	
КонецПроцедуры //

Процедура ПодготовитьПоказателиДляЗаполненияОбъектов(Ссылка) Экспорт
	
	ОбновитьПоказателиОбъектовБД(Ссылка);
	
	Запрос=Новый Запрос;
	
	Запрос.Текст="ВЫБРАТЬ
	|	ТабличныеЧастиБД.Ссылка
	|ИЗ
	|	Справочник.ТабличныеЧастиБД КАК ТабличныеЧастиБД
	|ГДЕ
	|	ТабличныеЧастиБД.Владелец = &Владелец";
	
	Запрос.УстановитьПараметр("Владелец",Ссылка);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		ОбновитьПоказателиОбъектовБД(Результат.Ссылка);
		
	КонецЦикла;
			
КонецПроцедуры // ПодготовитьПоказателиДляЗаполненияОбъектов() 

Процедура ОбновитьПоказателиОбъектовБД(Ссылка) Экспорт
	
	ТаблицаПримитивныхРеквизитов=Новый ТаблицаЗначений;
	ТаблицаПримитивныхРеквизитов.Колонки.Добавить("Имя",ПолучитьОписаниеТиповСтроки(100));
	ТаблицаПримитивныхРеквизитов.Колонки.Добавить("ТипДанных",ПолучитьОписаниеТиповСтроки(255));
	
	ТаблицаКлючевыхРеквизитов	= ТаблицаПримитивныхРеквизитов.СкопироватьКолонки();
	ТаблицаКлючевыхРеквизитов.Колонки.Добавить("Синоним",ПолучитьОписаниеТиповСтроки(0));	
	ТаблицаСсылочныхРеквизитов	= ТаблицаКлючевыхРеквизитов.СкопироватьКолонки();
	
	ВладелецПоказателя=?(ТипЗнч(Ссылка)=Тип("СправочникСсылка.ТабличныеЧастиБД"),Ссылка.Владелец,Ссылка);
	
	Для Каждого Реквизит ИЗ Ссылка.Реквизиты Цикл
		
		Если (ТипЗнч(Ссылка)=Тип("СправочникСсылка.ТабличныеЧастиБД") И Реквизит.Имя="НомерСтроки")
			ИЛИ Реквизит.Имя="Ссылка" Тогда
			
			Продолжить;
		
		ИначеЕсли Реквизит.Имя="Код" 
			ИЛИ Реквизит.Имя="Наименование"
			ИЛИ Реквизит.Имя="Дата"
			ИЛИ Реквизит.Имя="Номер" Тогда
			
			НоваяСтрока=ТаблицаКлючевыхРеквизитов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока,Реквизит);
						
		ИначеЕсли ПримитивныйТипСтрока(Реквизит.ТипДанных) Тогда
			
			НоваяСтрока=ТаблицаПримитивныхРеквизитов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока,Реквизит);
			
		Иначе
			
			НоваяСтрока=ТаблицаСсылочныхРеквизитов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока,Реквизит);
			
		КонецЕсли;
		
	КонецЦикла;
		
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	ТаблицаПримитивныхРеквизитов.Имя,
	|	ТаблицаПримитивныхРеквизитов.ТипДанных
	|ПОМЕСТИТЬ ТаблицаРеквизитов
	|ИЗ
	|	&ТаблицаПримитивныхРеквизитов КАК ТаблицаПримитивныхРеквизитов
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЕСТЬNULL(ПоказателиОбъектовБД.Ссылка, НЕОПРЕДЕЛЕНО) КАК ПоказательСсылка,
	|	ЕСТЬNULL(ПоказателиОбъектовБД.Наименование, НЕОПРЕДЕЛЕНО) КАК Наименование,
	|	ЕСТЬNULL(ПоказателиОбъектовБД.ДляЗаполненияШапки, НЕОПРЕДЕЛЕНО) КАК ДляЗаполненияШапки,
	|	ЕСТЬNULL(ПоказателиОбъектовБД.Код, НЕОПРЕДЕЛЕНО) КАК Код,
	|	ЕСТЬNULL(ТаблицаРеквизитов.Имя, НЕОПРЕДЕЛЕНО) КАК Имя,
	|	ЕСТЬNULL(ТаблицаРеквизитов.ТипДанных, НЕОПРЕДЕЛЕНО) КАК ТипДанных
	|ИЗ
	|	(ВЫБРАТЬ 
	|ПоказателиОбъектовБД.Ссылка,
	|ПоказателиОбъектовБД.Наименование,
	|ПоказателиОбъектовБД.ДляЗаполненияШапки,
	|ПоказателиОбъектовБД.Код
	|ИЗ Справочник.ПоказателиОбъектовБД КАК ПоказателиОбъектовБД
	|ГДЕ
	|	ПоказателиОбъектовБД.Владелец = &Владелец
	|	И НЕ ПоказателиОбъектовБД.ПометкаУдаления";
	
	Если ТипЗнч(Ссылка)=Тип("СправочникСсылка.ТабличныеЧастиБД") Тогда
		
		Запрос.Текст=Запрос.Текст+"	
		|И ПоказателиОбъектовБД.ТабличнаяЧастьБД=&ТабличнаяЧастьБД";
		
		Запрос.УстановитьПараметр("ТабличнаяЧастьБД",Ссылка);
		
	Иначе
		
		Запрос.Текст=Запрос.Текст+"	
		|И ПоказателиОбъектовБД.ТабличнаяЧастьБД=ЗНАЧЕНИЕ(Справочник.ТабличныеЧастиБД.ПустаяСсылка)";
			
	КонецЕсли;
	
	Запрос.Текст=Запрос.Текст+") КАК ПоказателиОбъектовБД
	|		ПОЛНОЕ СОЕДИНЕНИЕ ТаблицаРеквизитов КАК ТаблицаРеквизитов
	|		ПО ПоказателиОбъектовБД.Наименование = ТаблицаРеквизитов.Имя";
	
			
	Запрос.УстановитьПараметр("Владелец",						ВладелецПоказателя);
	Запрос.УстановитьПараметр("ТаблицаПримитивныхРеквизитов",	ТаблицаПримитивныхРеквизитов);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	ЕстьПоказательШапки=Ложь;
	
	Пока Результат.Следующий() Цикл
		
		Если (Не Результат.ПоказательСсылка=Неопределено) И Результат.Имя=Неопределено Тогда // Реквизит удален или переименован
			
			Если Результат.ДляЗаполненияШапки Тогда
				
				ЕстьПоказательШапки=Истина;
				
			Иначе
				
				ПоказательОбъект=Результат.ПоказательСсылка.ПолучитьОбъект();
				ПоказательОбъект.ПометкаУдаления=Истина;
				
				Попытка
					
					ПоказательОбъект.Записать();
					
				Исключение
					
				КонецПопытки;
				
			КонецЕсли;
			
		ИначеЕсли (Не Результат.Имя=Неопределено) Тогда
						
			Если Результат.ПоказательСсылка=Неопределено Тогда
				
				ПоказательОбъект=Справочники.ПоказателиОбъектовБД.СоздатьЭлемент();
				ПоказательОбъект.Владелец=ВладелецПоказателя;
				ПоказательОбъект.Наименование= Результат.Имя;
				
				Если ТипЗнч(Ссылка)=Тип("СправочникСсылка.ТабличныеЧастиБД") Тогда
					
					ПроектКода=Ссылка.Наименование+" "+Результат.Имя;
					ПоказательОбъект.ТабличнаяЧастьБД=Ссылка;
					
				Иначе
					
					ПроектКода=Результат.Имя;
					
				КонецЕсли;
				
				ПоказательОбъект.Код = СформироватьКодНаОснованииНаименования(ПроектКода,Метаданные.Справочники.ПоказателиОбъектовБД.ДлинаКода,"ПоказателиОбъектовБД",ВладелецПоказателя);
				
			Иначе
				
				ПоказательОбъект=Результат.ПоказательСсылка.ПолучитьОбъект();
								
			КонецЕсли;
			
			НомерПоследнейАналитики=0;
			
			СохраненныеРеквизиты=ПоказательОбъект.Реквизиты.Выгрузить();
			
			Для Каждого Строка ИЗ СохраненныеРеквизиты Цикл
				
				Если Строка.НомерАналитики>НомерПоследнейАналитики Тогда
					
					НомерПоследнейАналитики=Строка.НомерАналитики;
					
				КонецЕсли;
				
			КонецЦикла;	
						
			ПоказательОбъект.Реквизиты.Очистить();
			
			Если ПоказательОбъект.ДляЗаполненияШапки Тогда
				
				ЕстьПоказательШапки=Истина;
				
				Для Каждого Строка ИЗ ТаблицаКлючевыхРеквизитов Цикл
					
					НоваяСтрока	= ПоказательОбъект.Реквизиты.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка);
					
					ОпределитьНомерАналитики(НоваяСтрока,СохраненныеРеквизиты,НомерПоследнейАналитики);
										
				КонецЦикла;
					
			Иначе
				
				ПоказательОбъект.ТипЗначения=ПолучитьТипЗначенияПоказателяПоСтроке(Результат.ТипДанных);
				
			КонецЕсли;
					
			Для Каждого Строка ИЗ ТаблицаСсылочныхРеквизитов Цикл
				
				НоваяСтрока	= ПоказательОбъект.Реквизиты.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка);
				
				ОпределитьНомерАналитики(НоваяСтрока,СохраненныеРеквизиты,НомерПоследнейАналитики);
				
			КонецЦикла;
			
			Попытка
				
				ПоказательОбъект.Реквизиты.Сортировать("НомерАналитики");
				ПоказательОбъект.Записать();
				
			Исключение
				
			КонецПопытки;
				
		КонецЕсли;
			
	КонецЦикла;	
	
	Если НЕ (ТипЗнч(Ссылка)=Тип("СправочникСсылка.ТабличныеЧастиБД") ИЛИ ЕстьПоказательШапки) Тогда
		
		ПоказательОбъект=Справочники.ПоказателиОбъектовБД.СоздатьЭлемент();
		ПоказательОбъект.Владелец=ВладелецПоказателя;
		ПоказательОбъект.Наименование="Шапка";
		ПоказательОбъект.ДляЗаполненияШапки=Истина;
		
		НомерАналитики=0;
		
		ПроектКода="Шапка";	
		ПоказательОбъект.Код = СформироватьКодНаОснованииНаименования(ПроектКода,Метаданные.Справочники.ПоказателиОбъектовБД.ДлинаКода,"ПоказателиОбъектовБД",ВладелецПоказателя);
		
		Для Каждого Строка ИЗ ТаблицаКлючевыхРеквизитов Цикл
			
			НоваяСтрока					= ПоказательОбъект.Реквизиты.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка);
			
			НомерАналитики=НомерАналитики+1;
			НоваяСтрока.НомерАналитики=НомерАналитики;
			
		КонецЦикла;
		
		Для Каждого Строка ИЗ ТаблицаСсылочныхРеквизитов Цикл
			
			НоваяСтрока					= ПоказательОбъект.Реквизиты.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка);
			
			НомерАналитики=НомерАналитики+1;
			НоваяСтрока.НомерАналитики=НомерАналитики;
			
		КонецЦикла;
		
		Попытка
			
			ПоказательОбъект.Реквизиты.Сортировать("НомерАналитики");
			ПоказательОбъект.Записать();
			
		Исключение
			
			ТекстОшибки = ОписаниеОшибки();
			
		КонецПопытки;	
		
	КонецЕсли;
	
	Запрос.МенеджерВременныхТаблиц=Новый МенеджерВременныхТаблиц;
	
	Запрос.Текст="ВЫБРАТЬ
	|	ПоказателиОбъектовБД.Ссылка,
	|	ПоказателиОбъектовБД.Наименование,
	|	ПоказателиОбъектовБД.ТабличнаяЧастьБД
	|ПОМЕСТИТЬ ПоказателиОбъектовБД
	|ИЗ
	|	Справочник.ПоказателиОбъектовБД КАК ПоказателиОбъектовБД
	|ГДЕ
	|	ПоказателиОбъектовБД.Владелец = &ВладелецПоказателя
	|	И НЕ ПоказателиОбъектовБД.ПометкаУдаления
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ПоказателиОбъектовБД.Наименование,
	|	ПоказателиОбъектовБД.ТабличнаяЧастьБД,
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ПоказателиОбъектовБД.Ссылка) КАК Ссылка
	|ПОМЕСТИТЬ ПоказателиДубли
	|ИЗ
	|	ПоказателиОбъектовБД КАК ПоказателиОбъектовБД
	|
	|СГРУППИРОВАТЬ ПО
	|	ПоказателиОбъектовБД.Наименование,
	|	ПоказателиОбъектовБД.ТабличнаяЧастьБД
	|
	|ИМЕЮЩИЕ
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ПоказателиОбъектовБД.Ссылка) > 1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ИсточникиДанныхДляРасчетов.ПотребительРасчета
	|ПОМЕСТИТЬ ИсточникиДанных
	|ИЗ
	|	Справочник.ИсточникиДанныхДляРасчетов КАК ИсточникиДанныхДляРасчетов
	|ГДЕ
	|	ИсточникиДанныхДляРасчетов.ПотребительРасчета ССЫЛКА Справочник.ПоказателиОбъектовБД
	|	И ИсточникиДанныхДляРасчетов.ПотребительРасчета.Владелец = &ВладелецПоказателя
	|	И НЕ ИсточникиДанныхДляРасчетов.ПотребительРасчета.ПометкаУдаления
	|;
	|ВЫБРАТЬ ПоказателиДубли.Наименование,
	|	ПоказателиДубли.ТабличнаяЧастьБД";
	
	Запрос.УстановитьПараметр("ВладелецПоказателя",ВладелецПоказателя);
	
	ТаблицаДубли=Запрос.Выполнить().Выгрузить();
	
	Запрос.Текст="ВЫБРАТЬ
	|	ПоказателиОбъектовБД.Ссылка,
	|	ВЫБОР
	|		КОГДА ИсточникиДанных.ПотребительРасчета ЕСТЬ NULL
	|			ТОГДА 0
	|		ИНАЧЕ 1
	|	КОНЕЦ КАК ЕстьИсточник
	|ИЗ
	|	ПоказателиОбъектовБД КАК ПоказателиОбъектовБД
	|		ЛЕВОЕ СОЕДИНЕНИЕ ИсточникиДанных КАК ИсточникиДанных
	|		ПО ПоказателиОбъектовБД.Ссылка = ИсточникиДанных.ПотребительРасчета
	|ГДЕ	ПоказателиОбъектовБД.Наименование=&Наименование
	|	И ПоказателиОбъектовБД.ТабличнаяЧастьБД=&ТабличнаяЧастьБД
	|Упорядочить ПО
	| ЕстьИсточник УБЫВ";
	
	Для Каждого Строка ИЗ ТаблицаДубли Цикл
		
		Запрос.УстановитьПараметр("Наименование",		Строка.Наименование);
		Запрос.УстановитьПараметр("ТабличнаяЧастьБД",	Строка.ТабличнаяЧастьБД);
		
		ТабПоказатели=Запрос.Выполнить().Выгрузить();
		
		Для Индекс=1 ПО ТабПоказатели.Количество()-1 Цикл
			
			СтрПоказатель=ТабПоказатели[Индекс];
			
			Если НЕ СтрПоказатель.ЕстьИсточник Тогда
				
				ПоказательОбъект=СтрПоказатель.Ссылка.ПолучитьОбъект();
				ПоказательОбъект.ПометкаУдаления=Истина;
				
				Попытка
					
					ПоказательОбъект.Записать();
					
				Исключение
					
				КонецПопытки;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	
КонецПроцедуры // ОбновитьПоказателиОбъектовБД() 

Процедура ОпределитьНомерАналитики(СтрокаРеквизита,СохраненныеРеквизиты,НомерПоследнейАналитики) Экспорт
	
	СохраненнаяСтрока=СохраненныеРеквизиты.Найти(СтрокаРеквизита.Имя,"Имя");
	
	Если СохраненнаяСтрока=Неопределено ИЛИ СохраненнаяСтрока.НомерАналитики=0 Тогда
		
		НомерПоследнейАналитики=НомерПоследнейАналитики+1;
		СтрокаРеквизита.НомерАналитики=НомерПоследнейАналитики;
		
	Иначе
		
		СтрокаРеквизита.НомерАналитики=СохраненнаяСтрока.НомерАналитики;
		
	КонецЕсли;
		
КонецПроцедуры // ОпределитьНомерАналитики() 



/////////////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции создания описаний объектов текущей или внешних информационных баз
//

Функция ПолучитьИмяСправочникаОписанияПоТипуМетаданных(ТипМетаДанных) Экспорт
	
	Если ТипМетаДанных="Справочник" Тогда
		
		Возврат "СправочникиБД";
		
	ИначеЕсли ТипМетаДанных="ПланВидовХарактеристик" Тогда
		
		Возврат "ПланыВидовХарактеристикБД";
				
	ИначеЕсли ТипМетаДанных="ПланСчетов" Тогда
		
		Возврат "ПланыСчетовБД";
				
	ИначеЕсли ТипМетаДанных="РегистрБухгалтерии" Тогда
			
		Возврат "РегистрыБухгалтерииБД";
					
	ИначеЕсли ТипМетаДанных="РегистрНакопления" Тогда
		
		Возврат "РегистрыНакопленияБД";
				
	ИначеЕсли ТипМетаДанных="РегистрСведений" Тогда
		
		Возврат "РегистрыСведенийБД";
			
	ИначеЕсли ТипМетаДанных="Документ" Тогда
		
		Возврат "ДокументыБД";
				
	ИначеЕсли ТипМетаДанных="Перечисление" Тогда
		
		Возврат "ПеречисленияБД";
						
	ИначеЕсли ТипМетаДанных="ТаблицаADO" Тогда
		
		Возврат "ТаблицыADO";
		
	Иначе
		
		Возврат "";
				
	КонецЕсли;
	
КонецФункции //ПолучитьИмяСправочникаОписанияПоТипуМетаданных() 

Функция ПолучитьОписаниеОбъектаБД(ТекСоединениеВИБ,ТипМетаДанных,ИмяОбъектаБД,Владелец,ЗаполнятьРеквизиты=Истина) Экспорт
	
	Если ПустаяСтрока(ТипМетаДанных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИмяСправочникаОписания=ПолучитьИмяСправочникаОписанияПоТипуМетаданных(ТипМетаДанных);
	
	Если ПустаяСтрока(ИмяСправочникаОписания) Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	ВладелецДляПоиска=?(ЗначениеЗаполнено(Владелец),Владелец,Справочники.ТипыБазДанных.ТекущаяИБ);
	
	Если ТипМетаДанных="ТаблицаADO" Тогда
		
		Если ТипЗнч(ИмяОбъектаБД)=Тип("СправочникСсылка.ТаблицыADO") Тогда
			
			Возврат ИмяОбъектаБД;
			
		ИначеЕсли ИмяОбъектаБД="" Тогда
			
			Возврат Справочники.ТаблицыADO.ПустаяСсылка();
			
		Иначе
			
			ОбъектОписание=Справочники.ТаблицыADO.НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
			
			Если ЗначениеЗаполнено(ОбъектОписание) Тогда
				
				Возврат ОбъектОписание;
				
			Иначе
				
				ОбъектОписание=Справочники.ТаблицыADO.СоздатьЭлемент();
				
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		
		Если ИмяОбъектаБД="" Тогда
			Возврат Справочники[ИмяСправочникаОписания].ПустаяСсылка();
		КонецЕсли;
		
		ОбъектОписание=Справочники[ИмяСправочникаОписания].НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
		
		Если ЗначениеЗаполнено(ОбъектОписание) Тогда
			
			Возврат ОбъектОписание;
			
		Иначе
			
			ОбъектОписание=Справочники[ИмяСправочникаОписания].СоздатьЭлемент();
			
		КонецЕсли;
		
	КонецЕсли;
			
	Попытка
		
		ОбъектОписание.Владелец=ВладелецДляПоиска;
		ОбъектОписание.Наименование=ИмяОбъектаБД;
		
		Если ЗаполнятьРеквизиты Тогда 
			
			ОбъектОписание.ТекСоединениеВИБ=ТекСоединениеВИБ;
			ОбъектОписание.ЗаполнитьРеквизитыОбъекта();
			
		КонецЕсли;
		
		ОбъектОписание.Записать();
		
		Возврат ОбъектОписание.Ссылка;
		
	Исключение
		
		Возврат Неопределено;
		
	КонецПопытки;
	
КонецФункции // СоздатьОписаниеПланаСчетовВИБ()

Функция ПолучитьШаблонСтруктурыОписанияОбъектаБД(ТипОбъектаМетаДанных) Экспорт
	
	СтруктураОписание = Новый Структура("ТипОбъектаМетаДанных",ТипОбъектаМетаДанных);
	
	Если ТипОбъектаМетаДанных = "Catalogs" Тогда
		
		СтруктураОписание.Вставить("Синоним");
		СтруктураОписание.Вставить("ИерархическийСправочник");
		СтруктураОписание.Вставить("ВидИерархии");
							
		ОбъектОписание = Справочники.СправочникиБД.СоздатьЭлемент();
		
		ТабРеквизиты = ОбъектОписание.Реквизиты.ВыгрузитьКолонки();
		ТабРеквизиты.Колонки.Удалить("Использование");
		ТабРеквизиты.Колонки.Добавить("Использование",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(50));
				
		СтруктураОписание.Вставить("Реквизиты",ТабРеквизиты);
		СтруктураОписание.Вставить("Владельцы",ОбъектОписание.Владельцы.ВыгрузитьКолонки());
								
	ИначеЕсли ТипОбъектаМетаДанных = "ChartsOfCharacteristicTypes" Тогда
			
		ОбъектОписание = Справочники.ПланыВидовХарактеристикБД.СоздатьЭлемент();
		
		СтруктураОписание.Вставить("Синоним");
		СтруктураОписание.Вставить("ИерархическийСправочник");
		СтруктураОписание.Вставить("ТипЗначения");

		ТабРеквизиты = ОбъектОписание.Реквизиты.ВыгрузитьКолонки();
		ТабРеквизиты.Колонки.Удалить("Использование");
		ТабРеквизиты.Колонки.Добавить("Использование",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(50));
				
		СтруктураОписание.Вставить("Реквизиты",ТабРеквизиты);
					
	ИначеЕсли ТипОбъектаМетаДанных = "ChartsOfAccounts" Тогда
						
		СтруктураОписание.Вставить("МаксимальноеКоличествоСубконто");
		СтруктураОписание.Вставить("ПризнакиУчета");
		СтруктураОписание.Вставить("ПризнакиУчетаСубконто");
		СтруктураОписание.Вставить("ПланСчетовМетаданные");
		СтруктураОписание.Вставить("ДлинаКода");
		СтруктураОписание.Вставить("ВидыСубконто");
		
		ОбъектОписание = Справочники.ПланыСчетовБД.СоздатьЭлемент();
		СтруктураОписание.Вставить("Реквизиты",	ОбъектОписание.Реквизиты.ВыгрузитьКолонки());
			
		мОписаниеТиповСтрока = ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(150);
		мОписаниеТиповБулево = ОбщегоНазначенияУХ.ПолучитьОписаниеТиповБулево();
		
		мПланСчетов = Новый ТаблицаЗначений;
		мПланСчетов.Колонки.Добавить("Код", 						мОписаниеТиповСтрока);
		мПланСчетов.Колонки.Добавить("Наименование", 				мОписаниеТиповСтрока);
		мПланСчетов.Колонки.Добавить("Родитель", 					мОписаниеТиповСтрока);
		мПланСчетов.Колонки.Добавить("Забалансовый", 				мОписаниеТиповБулево);
		мПланСчетов.Колонки.Добавить("ПересчитыватьВалютнуюСумму", 	мОписаниеТиповБулево);
		мПланСчетов.Колонки.Добавить("ПометкаУдаления", 			мОписаниеТиповБулево);
		мПланСчетов.Колонки.Добавить("ЗапретитьИспользоватьВПроводках");
		мПланСчетов.Колонки.Добавить("РодительЗапретитьИспользоватьВПроводках");
		мПланСчетов.Колонки.Добавить("Вид", 						);
		мПланСчетов.Колонки.Добавить("ВидСтрока", 					);
		мПланСчетов.Колонки.Добавить("СчетСсылка");
		мПланСчетов.Колонки.Добавить("СчетИсточник");
		мПланСчетов.Колонки.Добавить("РодительСсылка");
		мПланСчетов.Колонки.Добавить("РазделПланаСчетов");
		мПланСчетов.Колонки.Добавить("ВидОтложенногоНалога");
		мПланСчетов.Колонки.Добавить("ВидКурса");
		мПланСчетов.Колонки.Добавить("ПризнакиУчета");
		мПланСчетов.Колонки.Добавить("ВидыСубконто");
		мПланСчетов.Колонки.Добавить("Наименование1");
		мПланСчетов.Колонки.Добавить("Наименование2");
		
		СтруктураОписание.Вставить("мПланСчетов",		мПланСчетов);
		
		ТаблицаСубконто = Новый ТаблицаЗначений;
		ТаблицаСубконто.Колонки.Добавить("Номер");
		ТаблицаСубконто.Колонки.Добавить("ВидСубконто");
		ТаблицаСубконто.Колонки.Добавить("ВидСубконтоСсылка");
		ТаблицаСубконто.Колонки.Добавить("ТолькоОбороты");
		ТаблицаСубконто.Колонки.Добавить("ТолькоСальдо");
		ТаблицаСубконто.Колонки.Добавить("ПризнакиУчетаСубконто");
		ТаблицаСубконто.Колонки.Добавить("ТипДанных");
		
		СтруктураОписание.Вставить("ТаблицаСубконто",	ТаблицаСубконто);
	
	ИначеЕсли ТипОбъектаМетаДанных="AccountingRegisters" Тогда
		
		СтруктураОписание.Вставить("Синоним");
		СтруктураОписание.Вставить("Корреспонденция");
		СтруктураОписание.Вставить("Регистраторы");
					
		ОбъектОписание = Справочники.РегистрыБухгалтерииБД.СоздатьЭлемент();
		СтруктураОписание.Вставить("Измерения",	ОбъектОписание.Измерения.ВыгрузитьКолонки());
		СтруктураОписание.Вставить("Ресурсы",	ОбъектОписание.Ресурсы.ВыгрузитьКолонки());
		СтруктураОписание.Вставить("Реквизиты",	ОбъектОписание.Реквизиты.ВыгрузитьКолонки());

	ИначеЕсли ТипОбъектаМетаДанных="AccumulationRegisters" Тогда
		
		СтруктураОписание.Вставить("Синоним");
		СтруктураОписание.Вставить("ВидРегистра");
		СтруктураОписание.Вставить("Регистраторы");
			
		ОбъектОписание = Справочники.РегистрыНакопленияБД.СоздатьЭлемент();
		СтруктураОписание.Вставить("Измерения",	ОбъектОписание.Измерения.ВыгрузитьКолонки());
		СтруктураОписание.Вставить("Ресурсы",	ОбъектОписание.Ресурсы.ВыгрузитьКолонки());
		СтруктураОписание.Вставить("Реквизиты",	ОбъектОписание.Реквизиты.ВыгрузитьКолонки());
		
	ИначеЕсли ТипОбъектаМетаДанных = "InformationRegisters" Тогда
		
		СтруктураОписание.Вставить("Синоним");
		СтруктураОписание.Вставить("Периодический");
		СтруктураОписание.Вставить("Периодичность");
		СтруктураОписание.Вставить("Регистраторы");
		
		ОбъектОписание = Справочники.РегистрыСведенийБД.СоздатьЭлемент();
		СтруктураОписание.Вставить("Измерения",	ОбъектОписание.Измерения.ВыгрузитьКолонки());
		СтруктураОписание.Вставить("Ресурсы",	ОбъектОписание.Ресурсы.ВыгрузитьКолонки());
		СтруктураОписание.Вставить("Реквизиты",	ОбъектОписание.Реквизиты.ВыгрузитьКолонки());
					
	ИначеЕсли ТипОбъектаМетаДанных = "Documents" Тогда
		
		СтруктураОписание.Вставить("Синоним");
		
		ОбъектОписание = Справочники.ДокументыБД.СоздатьЭлемент();
		СтруктураОписание.Вставить("Реквизиты", ОбъектОписание.Реквизиты.ВыгрузитьКолонки());
				
	ИначеЕсли ТипОбъектаМетаДанных="Enums" Тогда
			
		ОбъектОписание = Справочники.ПеречисленияБД.СоздатьЭлемент();
		
		СтруктураОписание.Вставить("Синоним");
		СтруктураОписание.Вставить("Реквизиты",	ОбъектОписание.Реквизиты.ВыгрузитьКолонки());
			
	КонецЕсли;
	
	Возврат СтруктураОписание; 
	
КонецФункции // ПолучитьШаблонСтруктурыОписанияОбъектаБД()

Функция ПолучитьСтруктуруОписанияСправочникаБД(ИмяСправочника, ТекСоединениеВИБ, Используется77, Кэш) Экспорт
	
	ШаблонОписания = ПолучитьШаблонСтруктурыОписанияОбъектаБД("Catalogs");
	ШаблонОписания.Вставить("ИмяОбъектаМетаданных",	ИмяСправочника);

	Если Используется77 Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияСправочника77(ШаблонОписания,ТекСоединениеВИБ);
		
	ИначеЕсли ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияСправочникаWS(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.СтруктураОписанияСправочника8х(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	КонецЕсли;		
	
КонецФункции // ПолучитьСтруктуруОписанияСправочникаБД()

Функция ПолучитьМассивСтруктурТабличныхЧастей1С(ТекСоединениеВИБ, ДанныеОбъектаВладельцаТЧ, Использование77,
	Кэш = Неопределено) Экспорт
	
	ДанныеОбъектаВладельцаТЧ.Вставить("Tabular", Истина);
	
	Если Использование77 Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.ПолучитьМассивСтруктурТабличныхЧастей1CПредприятие77(ДанныеОбъектаВладельцаТЧ,
			ТекСоединениеВИБ);
		
	ИначеЕсли ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.ПолучитьМассивСтруктурТабличныхЧастей1CПредприятиеWS(ДанныеОбъектаВладельцаТЧ,
			ТекСоединениеВИБ, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.ПолучитьМассивСтруктурТабличныхЧастей1CПредприятие8х(
			ДанныеОбъектаВладельцаТЧ, ТекСоединениеВИБ, Кэш);
		
	КонецЕсли;
	
КонецФункции

Функция ПолучитьСтруктуруОписанияДокументаБД(ИмяДокумента, ТекСоединениеВИБ, Используется77, Кэш = Неопределено) Экспорт
	
	ШаблонОписания=ПолучитьШаблонСтруктурыОписанияОбъектаБД("Documents");
	ШаблонОписания.Вставить("ИмяОбъектаМетаданных", ИмяДокумента);
	
	Если Используется77 Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияДокумента77(ШаблонОписания,ТекСоединениеВИБ);
		
	ИначеЕсли ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияДокументаWS(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.СтруктураОписанияДокумента8х(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	КонецЕсли;		
	
КонецФункции // ПолучитьСтруктуруОписанияСправочникаБД()

Функция ПолучитьСтруктуруОписанияПланаВидовХарактеристикБД(ИмяПланаВидовХарактеристик, ТекСоединениеВИБ, Кэш = Неопределено) Экспорт
	
	ШаблонОписания=ПолучитьШаблонСтруктурыОписанияОбъектаБД("ChartsOfCharacteristicTypes");
	ШаблонОписания.Вставить("ИмяОбъектаМетаданных", ИмяПланаВидовХарактеристик);
	
	Если ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияПланаВидовХарактеристикWS(
			ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.СтруктураОписанияПланаВидовХарактеристик8х(
			ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	КонецЕсли;		
	
КонецФункции // ПолучитьСтруктуруОписанияСправочникаБД()

Функция ПолучитьСтруктуруОписанияПеречисленияБД(ИмяПеречисления, ТекСоединениеВИБ, Используется77, Кэш = Неопределено) Экспорт
	
	ШаблонОписания = ПолучитьШаблонСтруктурыОписанияОбъектаБД("Enums");
	ШаблонОписания.Вставить("ИмяОбъектаМетаданных",ИмяПеречисления);
	
	Если Используется77 Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияПеречисления77(ШаблонОписания, ТекСоединениеВИБ);
		
	ИначеЕсли ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияПеречисленияWS(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.СтруктураОписанияПеречисления8х(ШаблонОписания,ТекСоединениеВИБ);
		
	КонецЕсли;		
	
КонецФункции // ПолучитьСтруктуруОписанияПеречисленияБД()

Функция ПолучитьСтруктуруОписанияРегистраНакопленияБД(ИмяРегистраНакопления, ТекСоединениеВИБ, Используется77,
	Кэш = Неопределено) Экспорт
	
	ШаблонОписания = ПолучитьШаблонСтруктурыОписанияОбъектаБД("AccumulationRegisters");
	ШаблонОписания.Вставить("ИмяОбъектаМетаданных", ИмяРегистраНакопления);
	
	Если Используется77 Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияРегистраНакопления77(ШаблонОписания, ТекСоединениеВИБ);
		
	ИначеЕсли ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияРегистраНакопленияWS(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.СтруктураОписанияРегистраНакопления8х(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	КонецЕсли;		
	
КонецФункции // ПолучитьСтруктуруОписанияРегистраНакопленияБД()

Функция ПолучитьСтруктуруОписанияРегистраБухгалтерииБД(ИмяРегистраБухгалтерии, ТекСоединениеВИБ, Используется77,
	Кэш = Неопределено) Экспорт
	
	ШаблонОписания = ПолучитьШаблонСтруктурыОписанияОбъектаБД("AccountingRegisters");
	ШаблонОписания.Вставить("ИмяОбъектаМетаданных", ИмяРегистраБухгалтерии);
	
	Если Используется77 Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияРегистраБухгалтерии77(ШаблонОписания, ТекСоединениеВИБ);
		
	ИначеЕсли ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияРегистраБухгалтерииWS(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.СтруктураОписанияРегистраБухгалтерии8х(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	КонецЕсли;		
	
КонецФункции // ПолучитьСтруктуруОписанияРегистраБухгалтерииБД()

Функция ПолучитьСтруктуруОписанияПланаСчетовБД(ПланСчетовНаименование,ПланСчетовМетаданные, ТекСоединениеВИБ, Используется77, 
	СчетБД = Неопределено, Кэш = Неопределено) Экспорт
	
	ШаблонОписания=ПолучитьШаблонСтруктурыОписанияОбъектаБД("ChartsOfAccounts");
	ШаблонОписания.Вставить("ИмяОбъектаМетаданных", 	ПланСчетовМетаданные);
	ШаблонОписания.Вставить("ПланСчетовНаименование", 	ПланСчетовНаименование);
	ШаблонОписания.Вставить("ТекущаяИБ", (ТипЗнч(ТекСоединениеВИБ) = Тип("ОбработкаОбъект.РаботаСМетаданнымиУХ")));
		
	Если Используется77 Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияПланаСчетов77(ШаблонОписания, ТекСоединениеВИБ);
		
	ИначеЕсли ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияПланаСчетовWS(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.СтруктураОписанияПланаСчетов8х(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	КонецЕсли;		
	
КонецФункции // ПолучитьСтруктуруОписанияПланаСчетовБД()

Функция ПолучитьСтруктуруОписанияРегистраСведенийБД(ИмяРегистраСведений, ТекСоединениеВИБ, Кэш = Неопределено) Экспорт
	
	ШаблонОписания=ПолучитьШаблонСтруктурыОписанияОбъектаБД("InformationRegisters");
	ШаблонОписания.Вставить("ИмяОбъектаМетаданных", ИмяРегистраСведений);
	
	Если ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.СтруктураОписанияРегистраСведенийWS(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.СтруктураОписанияРегистраСведений8х(ШаблонОписания, ТекСоединениеВИБ, Кэш);
		
	КонецЕсли;		
	
КонецФункции // ПолучитьСтруктуруОписанияРегистраСведенийБД()

Функция ПолучитьМассивИменОбъектовБД(ТипОбъектаМетаданных, ТекСоединениеВИБ, Кэш = Неопределено)
	
	Если ТипЗнч(ТекСоединениеВИБ) = Тип("WSProxy") Тогда
		
		Возврат РаботаСОбъектамиМетаданныхВнутреннийУХ.ПолучитьМассивИменОбъектовWS(ТипОбъектаМетаданных, ТекСоединениеВИБ,, Кэш);
		
	Иначе
		
		Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.ПолучитьМассивИменОбъектов8x(ТипОбъектаМетаданных,ТекСоединениеВИБ);
		
	КонецЕсли;
		
	
КонецФункции // ПолучитьМассивИменОбъектовБД() 


Функция ПроверитьНаличиеОписанияОбъектаБД(ТекСоединениеВИБ,СтрТипЗначения,ТипБД,ЗаполнятьПроизводныеРеквизиты) Экспорт
	
	ТипМетаДанных=ОбщегоНазначенияУХ.ПолучитьНаименованиеСсылочногоТипаБД(Неопределено,СтрТипЗначения);
	
	Если ТипМетаДанных="НеПоддерживается" Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	
	ДанныеОбъекта=РазложитьСтрокуВМассивПодстрок(СтрТипЗначения,".");	
	
	ИмяОбъекта=?(ДанныеОбъекта.Количество()=2,ДанныеОбъекта[1],СтрТипЗначения);
	
	Если ЗаполнятьПроизводныеРеквизиты Тогда
		ТекОписание=ПолучитьОписаниеОбъектаБД(ТекСоединениеВИБ,ТипМетаДанных,ИмяОбъекта,ТипБД);
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // ПроверитьНаличиеОписанияОбъектаБД() 

Функция ПолучитьСтрокуТиповДанныхБД(ТекСоединениеВИБ,ОписаниеТиповБД,ТипБД,ЗаполнятьПроизводныеРеквизиты=Истина) Экспорт
	
	Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.ПолучитьСтрокуТиповДанныхБД(ТекСоединениеВИБ,ОписаниеТиповБД);
	
КонецФункции // ПолучитьСтрокуТиповДанныхБД()

Функция ПолучитьСтрокуПримитивныхТипов(ОписаниеТипов) Экспорт
	
	Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.ПолучитьСтрокуПримитивныхТипов(ОписаниеТипов);
	
КонецФункции // ПолучитьСтрокуПримитивныхТипов()

Функция ПолучитьРасширенныеДанныеТипа(СтрокаТип)
	
	ТипЗначения="";
	УточненииеТипа="";
	
	ПозицияТипа=СтрНайти(СтрокаТип,"(");
	ТипДанных=Лев(СтрокаТип,ПозицияТипа-1);
	
	ДанныеКвалификатора=Сред(СтрокаТип,ПозицияТипа+1);
	ДанныеКвалификатора=СтрЗаменить(ДанныеКвалификатора,")","");
	
	СтруктураДанных=Новый Структура;
	СтруктураДанных.Вставить("ТипЗначения",ТипДанных);
	
	Если ТипДанных="Строка" Тогда
		
		ДанныеСтроки=РазложитьСтрокуВМассивПодстрок(ДанныеКвалификатора,",");
		СтруктураДанных.Вставить("Длина",Число(ДанныеСтроки[0]));
		
	ИначеЕсли ТипДанных="Число" Тогда
		
		ДанныеСтроки=РазложитьСтрокуВМассивПодстрок(ДанныеКвалификатора,",");
		
		СтруктураДанных.Вставить("Разрядность",Число(ДанныеСтроки[0]));
		
		Если ДанныеСтроки.Количество()>1 Тогда
			
			СтруктураДанных.Вставить("РазрядностьДробнойЧасти",Число(ДанныеСтроки[1]));
			
			Если ДанныеСтроки.Количество()>2 Тогда
				
				СтруктураДанных.Вставить("ДопустимыйЗнак",ДанныеСтроки[2]);
				
			Иначе
				
				СтруктураДанных.Вставить("ДопустимыйЗнак","Любой");
				
			КонецЕсли;
			
		Иначе
			
			СтруктураДанных.Вставить("РазрядностьДробнойЧасти",0);
			СтруктураДанных.Вставить("ДопустимыйЗнак","Неотрицательный");
			
		КонецЕсли;
		
	ИначеЕсли ТипДанных="Дата" Тогда
		
		СтруктураДанных.Вставить("ЧастиДаты",ДанныеКвалификатора);
		
	КонецЕсли;
	
	Возврат СтруктураДанных;
		
КонецФункции // ПолучитьРасширенныеДанныеТипа(СтрокаТип) 

Функция ПроверитьВозможностьУстановкиСоответствия(ОписаниеТиповИсточник,ОписаниеТиповПриемник) Экспорт
	
	Если ПустаяСтрока(ОписаниеТиповИсточник) ИЛИ ПустаяСтрока(ОписаниеТиповПриемник) Тогда
		
		Возврат "";
		
	КонецЕсли;
	
	МассивТиповИсточник=РазложитьСтрокуВМассивПодстрок(ОписаниеТиповИсточник,";");
	МассивТиповПриемник=РазложитьСтрокуВМассивПодстрок(ОписаниеТиповПриемник,";");
	
	ТекстОшибки="";
	ЕстьСовпадающиеТипы=Ложь;
	
	Для Каждого СтрокаИсточник ИЗ МассивТиповИсточник Цикл
		
		Для Каждого СтрокаПриемник ИЗ МассивТиповПриемник Цикл
			
			ДанныеТипаИсточник=	ПолучитьРасширенныеДанныеТипа(СтрокаИсточник);
			ДанныеТипаПриемник=	ПолучитьРасширенныеДанныеТипа(СтрокаПриемник);
			
			Если НЕ ДанныеТипаИсточник.ТипЗначения=ДанныеТипаПриемник.ТипЗначения Тогда
				
				Продолжить;
				
			КонецЕсли;
			
			ЕстьСовпадающиеТипы=Истина;
			
			Если ДанныеТипаИсточник.ТипЗначения="Строка" Тогда
				
				Если ДанныеТипаПриемник.Длина>0 И ДанныеТипаИсточник.Длина>ДанныеТипаПриемник.Длина Тогда
					
					ТекстОшибки=Нстр("ru = 'Максимальная длина поля источника больше максимальной длины поля приемника.'");
					
				КонецЕсли;
				
			ИначеЕсли ДанныеТипаИсточник.ТипЗначения="Число" Тогда
				
				ТекстОшибки="";
				
				Если ДанныеТипаИсточник.Разрядность>ДанныеТипаПриемник.Разрядность Тогда
					
					ТекстОшибки=СтрШаблон(Нстр("ru = '%1
					|Разрядность поля источника больше разрядности поля приемника.'"), 
					            	ТекстОшибки);
					
				КонецЕсли;
					
				Если ДанныеТипаИсточник.РазрядностьДробнойЧасти>ДанныеТипаПриемник.РазрядностьДробнойЧасти Тогда
					
					ТекстОшибки=СтрШаблон(Нстр("ru = '%1
					|Разрядность дробной части поля источника больше разрядности дробной части поля приемника.'"), 
					            	ТекстОшибки);
					
				КонецЕсли;
				
				Если ДанныеТипаИсточник.ДопустимыйЗнак="Любой" И ДанныеТипаПриемник.ДопустимыйЗнак="Неотрицательный" Тогда
					
					ТекстОшибки=СтрШаблон(Нстр("ru = '%1
					|При отрицательном  значении источника поле приемника заполнено не будет.'"), 
					            	ТекстОшибки);
					
				КонецЕсли;
				
			ИначеЕсли ДанныеТипаИсточник.ТипЗначения="Дата"
				И ДанныеТипаИсточник.ЧастиДаты="Дата и время"
				И ДанныеТипаПриемник.ЧастиДаты="Дата" Тогда
				
				ТекстОшибки=Нстр("ru = 'Размерность даты поля источника больше размерности даты поля приемника'");
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Если НЕ ЕстьСовпадающиеТипы Тогда
		
		ТекстОшибки=Нстр("ru = 'Несовпадение типов.'");
		
	КонецЕсли;
	
	Возврат ТекстОшибки;	
	
КонецФункции // ВозможнаУстановкаСоответствия()


Функция ПреобразоватьПримитивныйТипВСтроку(Тип,ВозвращатьТип=Истина) Экспорт
	
	Если Тип=Тип("Строка") Тогда
		
		Возврат "Строка";
		
	ИначеЕсли Тип=Тип("Число") Тогда
		
		Возврат "Число";
		
	ИначеЕсли Тип=Тип("Дата") Тогда
		
		Возврат "Дата";
		
	ИначеЕсли Тип=Тип("Булево") Тогда
		
		Возврат "Булево";
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции // ПреобразоватьТИП()

Функция ПолучитьТипСтрокой(Тип) Экспорт
	
	ПримитивныйТип=ПреобразоватьПримитивныйТипВСтроку(Тип);
	
	Если ПримитивныйТип=Неопределено Тогда
		
		Возврат Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		
	Иначе
		
		Возврат ПримитивныйТип;
		
	КонецЕсли;
	
КонецФункции // 

#Область СтруктураМетаданныхИБ
Функция ПолучитьСтрокуТиповДанныхТек(ОписаниеТипов,ТипБД,ЗаполнятьПроизводныеРеквизиты=Истина) Экспорт
	
	МассивТипов = ОписаниеТипов.Типы();
	СтрокаТипов="";
	СтрокаПримитивныхТипов="";
	
	Если МассивТипов.Количество()>1 Тогда
		
		СтрокаПримитивныхТипов=ОбщегоНазначенияУХ.ПолучитьСтрокуПримитивныхТипов(ОписаниеТипов);
		
	КонецЕсли;
	
	Для Каждого Тип ИЗ МассивТипов Цикл
		
		// Проверим на примитивное значение типа
		
		ПримитивныйТип=ПреобразоватьПримитивныйТипВСтроку(Тип);
		
		Если ПримитивныйТип=Неопределено Тогда 
			
			ТекОбъект=Метаданные.НайтиПоТипу(Тип);
			
			Если ТекОбъект=Неопределено Тогда
				
				Продолжить;
				
			Иначе
				
				СтрТипЗначения=ТекОбъект.ПолноеИмя();
				
				Если ПроверитьНаличиеОписанияОбъектаБД(Неопределено,СтрТипЗначения,ТипБД,ЗаполнятьПроизводныеРеквизиты) Тогда 
					
					СтрокаТипов=СтрокаТипов+";"+СтрТипЗначения;
					
				КонецЕсли;
					
			КонецЕсли;
			
		ИначеЕсли ПустаяСтрока(СтрокаПримитивныхТипов) Тогда
			
			СтрокаТипов=СтрокаТипов+";"+ПримитивныйТип;
			
		КонецЕсли;	
		
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(СтрокаПримитивныхТипов) Тогда
		
		СтрокаТипов=СтрокаТипов+";"+СтрокаПримитивныхТипов;
		
	КонецЕсли;
	
	Возврат Сред(СтрокаТипов,2);
	
КонецФункции // ПолучитьСтрокуТиповДанныхТек()

Процедура ЗаполнитьСписокРегистровБД(ТипБД, База = Неопределено, 
										РегистрыБухгалерии = Ложь, 
										РегистрыНакопления = Ложь,
										РегистрыСведений = Ложь,
										ЗаполнятьРеквизиты = Ложь,
										ОбновлятьПланыСчетов = Ложь,
										Кэш = Неопределено) Экспорт
										
	Если НЕ ПодключитьсяКИБ(ТипБД, База, Кэш) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипБД.ВерсияПлатформы = Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие77 Тогда
		
		НачатьТранзакцию();
		
		Если РегистрыБухгалерии Тогда
			
			Для Инд = 1 По База.Метаданные().ПланСчетов() Цикл
				
				ТекПланСчетов 	= База.Метаданные().ПланСчетов(Инд);
				ИмяОбъекта 		= ТекПланСчетов.Идентификатор;
				
				ТекСправочник = Справочники.ПланыСчетовБД.НайтиПоНаименованию(ИмяОбъекта, Истина,, ТипБД);
				
				Если ЗначениеЗаполнено(ТекСправочник) Тогда
					
					Если НЕ ЗаполнятьРеквизиты Тогда
						
						Продолжить;
						
					Иначе
						
						ОбъектОписание = ТекСправочник.ПолучитьОбъект();
						
					КонецЕсли;		
					
				Иначе
					
					ОбъектОписание = Справочники.ПланыСчетовБД.СоздатьЭлемент();
					ОбъектОписание.Владелец = ТипБД;
					
				КонецЕсли;
				
				ЕстьИзменения = ОбъектОписание.ЭтоНовый();
				ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ОбъектОписание.Наименование, ИмяОбъекта, ЕстьИзменения);
				ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ОбъектОписание.Синоним, ТекПланСчетов.Представление(), 
					ЕстьИзменения);
				ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ОбъектОписание.ПланСчетовМетаданные,ИмяОбъекта,ЕстьИзменения, 
					ЕстьИзменения);
				
				Если ЗаполнятьРеквизиты Тогда
					
					ОбъектОписание.ЗаполнитьРеквизитыОбъекта(Кэш, ЕстьИзменения);
					
				КонецЕсли;
				
				Если ЕстьИзменения Тогда
					ОбъектОписание.Записать();
				КонецЕсли;	
				
			КонецЦикла;
			
		КонецЕсли;
		
		Если РегистрыНакопления Тогда
			
			Для Инд = 1 По База.Метаданные().Регистр() Цикл
				
				ТекРегистр	 	= База.Метаданные().Регистр(Инд);
				ИмяОбъекта 		= ТекРегистр.Идентификатор;
				
				ТекСправочник = Справочники.РегистрыНакопленияБД.НайтиПоНаименованию(ИмяОбъекта, Истина,, ТипБД);
				
				Если ЗначениеЗаполнено(ТекСправочник) Тогда
					
					Если НЕ ЗаполнятьРеквизиты Тогда
						
						Продолжить;
						
					Иначе
						
						ОбъектОписание = ТекСправочник.ПолучитьОбъект();
						
					КонецЕсли;		
					
				Иначе
					
					ОбъектОписание = Справочники.РегистрыНакопленияБД.СоздатьЭлемент();
					ОбъектОписание.Владелец=ТипБД;
					
				КонецЕсли;
				
				ЕстьИзменения = ОбъектОписание.ЭтоНовый();
				ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ОбъектОписание.Наименование, ИмяОбъекта, ЕстьИзменения);
				ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ОбъектОписание.Синоним, 
					ТекРегистр.Представление(), ЕстьИзменения);
				
				
				Если ЗаполнятьРеквизиты Тогда
					
					ОбъектОписание.ЗаполнитьРеквизитыОбъекта(Кэш, ЕстьИзменения);
					
				КонецЕсли;
				
				Если ЕстьИзменения Тогда
					ОбъектОписание.Записать();
				КонецЕсли;	
				
			КонецЦикла;
			
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Иначе
		
		// КЭШ WS
		Если ТипЗнч(База) = Тип("WSПрокси") Тогда		
			
			М = РаботаСОбъектамиМетаданныхВнутреннийУХ;
			ПараметрыЗаполнения = М.НовыеПараметрыЗаполненияКэшаМетаданныхWS();
			
			Если РегистрыБухгалерии Тогда
				М.ДобавитьПараметрЗаполненияКэшаМетаданныхWS(ПараметрыЗаполнения, "AccountingRegisters");
				М.ДобавитьПараметрЗаполненияКэшаМетаданныхWS(ПараметрыЗаполнения, "ChartsOfAccounts");
			КонецЕсли;
			
			Если РегистрыНакопления Тогда
				М.ДобавитьПараметрЗаполненияКэшаМетаданныхWS(ПараметрыЗаполнения, "AccumulationRegisters");
			КонецЕсли;
			
			Если РегистрыСведений Тогда
				М.ДобавитьПараметрЗаполненияКэшаМетаданныхWS(ПараметрыЗаполнения, "InformationRegisters");
			КонецЕсли;
			
			М.ЗаполнитьКэшМетаданныхWSПакетно(Кэш, База, ПараметрыЗаполнения);
		КонецЕсли;
		
		НачатьТранзакцию();

		Если РегистрыБухгалерии Тогда
			
			МассивСуществующих = Новый Массив;
			МассивПлановСчетов = Новый Массив;
			
			МассивРБ = ПолучитьМассивИменОбъектовБД("AccountingRegisters", База, Кэш);
			МассивПС = ПолучитьМассивИменОбъектовБД("ChartsOfAccounts", База, Кэш);
			
			Для Каждого ИмяОбъекта ИЗ МассивРБ Цикл
								
				ТекСправочник = Справочники.РегистрыБухгалтерииБД.НайтиПоНаименованию(ИмяОбъекта, Истина,, ТипБД);
				
				Если ЗначениеЗаполнено(ТекСправочник) Тогда
					
					Если НЕ ЗаполнятьРеквизиты Тогда
						
						Продолжить;
						
					Иначе
						
						ОбъектОписание=ТекСправочник.ПолучитьОбъект();
						
					КонецЕсли;		
					
				Иначе
					
					ОбъектОписание = Справочники.РегистрыБухгалтерииБД.СоздатьЭлемент();
					ОбъектОписание.Владелец = ТипБД;
					ОбъектОписание.Наименование = ИмяОбъекта;
					
				КонецЕсли;
				
				ЕстьИзменения = ОбъектОписание.ЭтоНовый();
				
				Если ЗаполнятьРеквизиты Тогда
					
					ОбъектОписание.ЗаполнитьРеквизитыОбъекта(Кэш, ЕстьИзменения);
					
				КонецЕсли;
				
				Если ЕстьИзменения Тогда
					ОбъектОписание.Записать();
				КонецЕсли;
				
				МассивСуществующих.Добавить(СокрЛП(ИмяОбъекта));
				
			КонецЦикла;
			
			МассивСуществующих = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивСуществующих);
			МассивСуществующих = ОбщегоНазначенияКлиентСерверУХ.УдалитьПустыеЭлементыМассива(МассивСуществующих);
			// Обновление реквизита Отсутствует в конфигурации.
			ОбновитьОтсутствующиеВКонфигурации(МассивСуществующих, ТипБД, "Справочник.РегистрыБухгалтерииБД");
			
			Если ОбновлятьПланыСчетов Тогда
				
				МассивСуществующих = Новый Массив;
				
				Для Каждого СтруктураОписания ИЗ МассивПС Цикл
					
					ИмяОбъекта=?(ЗначениеЗаполнено(СтруктураОписания.ПланСчетовБД),СтруктураОписания.ПланСчетовБД,СтруктураОписания.ПланСчетовМетаданные);
					
					Если МассивПлановСчетов.Найти(ИмяОбъекта)=Неопределено Тогда
						
						ТекСправочник = Справочники.ПланыСчетовБД.НайтиПоНаименованию(ИмяОбъекта,Истина,,ТипБД);
						
						Если ЗначениеЗаполнено(ТекСправочник) Тогда
							
							Если НЕ ЗаполнятьРеквизиты Тогда
								
								Продолжить;
								
							Иначе
								
								ОбъектОписание = ТекСправочник.ПолучитьОбъект();
								ОбъектОписание.ПланСчетовМетаданные=СтруктураОписания.ПланСчетовМетаданные;
								
							КонецЕсли;		
							
						Иначе
							
							ОбъектОписание = Справочники.ПланыСчетовБД.СоздатьЭлемент();
							ОбъектОписание.Владелец=ТипБД;
							ОбъектОписание.Наименование = ИмяОбъекта;
							ОбъектОписание.ПланСчетовМетаданные=СтруктураОписания.ПланСчетовМетаданные;
							
						КонецЕсли;
						
						ЕстьИзменения = ОбъектОписание.ЭтоНовый();
						
						Если ЗаполнятьРеквизиты Тогда
							
							ОбъектОписание.ЗаполнитьРеквизитыОбъекта(Кэш, ЕстьИзменения);
							
						КонецЕсли;
						
						Если ЕстьИзменения Тогда
							ОбъектОписание.Записать();
						КонецЕсли;	
						
					КонецЕсли;
					
					МассивСуществующих.Добавить(СокрЛП(ИмяОбъекта));
					
				КонецЦикла;
				
				МассивСуществующих = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивСуществующих);
				МассивСуществующих = ОбщегоНазначенияКлиентСерверУХ.УдалитьПустыеЭлементыМассива(МассивСуществующих);
				// Обновление реквизита Отсутствует в конфигурации.
				ОбновитьОтсутствующиеВКонфигурации(МассивСуществующих, ТипБД, "Справочник.ПланыСчетовБД");
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если РегистрыНакопления Тогда
			
			МассивСуществующих = Новый Массив;	
			МассивРН = ПолучитьМассивИменОбъектовБД("AccumulationRegisters", База, Кэш);
	
			Для Каждого ИмяОбъекта ИЗ МассивРН Цикл
								
				ТекСправочник = Справочники.РегистрыНакопленияБД.НайтиПоНаименованию(ИмяОбъекта, Истина,, ТипБД);
				
				Если ЗначениеЗаполнено(ТекСправочник) Тогда
					
					Если НЕ ЗаполнятьРеквизиты Тогда
						
						Продолжить;
						
					Иначе
						
						ОбъектОписание = ТекСправочник.ПолучитьОбъект();
						
					КонецЕсли;		
					
				Иначе
					
					ОбъектОписание = Справочники.РегистрыНакопленияБД.СоздатьЭлемент();
					ОбъектОписание.Владелец=ТипБД;
					ОбъектОписание.Наименование=ИмяОбъекта;
					
				КонецЕсли;
				
				ЕстьИзменения = ОбъектОписание.ЭтоНовый();
				
				Если ЗаполнятьРеквизиты Тогда
					
					ОбъектОписание.ЗаполнитьРеквизитыОбъекта(Кэш, ЕстьИзменения);
					
				КонецЕсли;
				
				Если ЕстьИзменения Тогда
					ОбъектОписание.Записать();
				КонецЕсли;
				
				МассивСуществующих.Добавить(СокрЛП(ИмяОбъекта));
				
			КонецЦикла;
			
			МассивСуществующих = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивСуществующих);
			МассивСуществующих = ОбщегоНазначенияКлиентСерверУХ.УдалитьПустыеЭлементыМассива(МассивСуществующих);
			
			// Обновление реквизита Отсутствует в конфигурации.
			ОбновитьОтсутствующиеВКонфигурации(МассивСуществующих, ТипБД, "Справочник.РегистрыНакопленияБД");
			
		КонецЕсли;
		
		Если РегистрыСведений Тогда
			
			МассивСуществующих = Новый Массив;
			МассивРС = ПолучитьМассивИменОбъектовБД("InformationRegisters", База, Кэш);
	
			Для Каждого ИмяОбъекта ИЗ МассивРС Цикл
								
				ТекСправочник = Справочники.РегистрыСведенийБД.НайтиПоНаименованию(ИмяОбъекта, Истина,, ТипБД);
				
				Если ЗначениеЗаполнено(ТекСправочник) Тогда
					
					Если НЕ ЗаполнятьРеквизиты Тогда
						
						Продолжить;
						
					Иначе
						
						ОбъектОписание=ТекСправочник.ПолучитьОбъект();
						
					КонецЕсли;		
					
				Иначе
					
					ОбъектОписание = Справочники.РегистрыСведенийБД.СоздатьЭлемент();
					ОбъектОписание.Владелец = ТипБД;
					ОбъектОписание.Наименование = ИмяОбъекта;
					
				КонецЕсли;
								
				ЕстьИзменения = ОбъектОписание.ЭтоНовый();
				
				Если ЗаполнятьРеквизиты Тогда
					
					ОбъектОписание.ЗаполнитьРеквизитыОбъекта(Кэш, ЕстьИзменения);
					
				КонецЕсли;
				
				Если ЕстьИзменения Тогда
					ОбъектОписание.Записать();
				КонецЕсли;
				
				МассивСуществующих.Добавить(СокрЛП(ИмяОбъекта));
				
			КонецЦикла;
			
			МассивСуществующих = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивСуществующих);
			МассивСуществующих = ОбщегоНазначенияКлиентСерверУХ.УдалитьПустыеЭлементыМассива(МассивСуществующих);
			
			// Обновление реквизита Отсутствует в конфигурации.
			ОбновитьОтсутствующиеВКонфигурации(МассивСуществующих, ТипБД, "Справочник.РегистрыСведенийБД");
			
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();

	КонецЕсли;
		
КонецПроцедуры 

Процедура ЗаполнитьСписокСправочниковБД(ТипБД, База = Неопределено, Кэш = Неопределено) Экспорт
	
	Если НЕ ПодключитьсяКИБ(ТипБД, База, Кэш) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипБД.ВерсияПлатформы = Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие77 Тогда
		
		НачатьТранзакцию();
		
		Для Инд = 1 По База.Метаданные().Справочник() Цикл
			
			СправочникБД 	= База.Метаданные().Справочник(Инд);
			ИмяОбъекта 		= СправочникБД.Идентификатор;
			
			ОбновитьОписаниеОбъектаБД(База, "Справочник", ИмяОбъекта, ТипБД, Кэш);
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Иначе
		
		МассивСуществующих = Новый Массив;
		
		Если ТипЗнч(База) = Тип("WSПрокси") Тогда
			РаботаСОбъектамиМетаданныхВнутреннийУХ.ЗаполнитьКэшМетаданныхWS(Кэш, База, "Catalogs", Истина); 
		КонецЕсли;
			
		МассивИмен = ПолучитьМассивИменОбъектовБД("Catalogs", База, Кэш);
		
		НачатьТранзакцию();
		
		Для Каждого ИмяОбъекта ИЗ МассивИмен Цикл
						
			ОбновитьОписаниеОбъектаБД(База,"Справочник", ИмяОбъекта, ТипБД, Истина, Кэш);
			МассивСуществующих.Добавить(СокрЛП(ИмяОбъекта));
			
		КонецЦикла;
		
		МассивСуществующих = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивСуществующих);
		МассивСуществующих = ОбщегоНазначенияКлиентСерверУХ.УдалитьПустыеЭлементыМассива(МассивСуществующих);
		// Обновление реквизита Отсутствует в конфигурации.
		ОбновитьОтсутствующиеВКонфигурации(МассивСуществующих, ТипБД, "Справочник.СправочникиБД");
		
		ЗафиксироватьТранзакцию();
		
	КонецЕсли;
	
КонецПроцедуры //

Функция ПодключитьсяКИБ(ТипБД, База, Кэш = Неопределено) Экспорт
		
	РаботаСОбъектамиМетаданныхУХ.ПроверитьКэшПередПодключениемКИБ(Кэш);
		
	Если Кэш = Неопределено Тогда
		Кэш = РаботаСОбъектамиМетаданныхУХ.НовыйКэшОбновленияМетаданных();
	КонецЕсли;

	Если НЕ ТипБД = Справочники.ТипыБазДанных.ТекущаяИБ Тогда
		
		Если База = Неопределено Тогда
			База = РаботаСОбъектамиМетаданныхУХ.ПодключениеИзКэша(Кэш);
		КонецЕсли;

		Если База = Неопределено Тогда
			База = ПолучитьСоединениеСВИБПоУмолчанию(ТипБД, 1);
		КонецЕсли;
			
		Если База = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		
	Иначе
		
		База = Обработки.РаботаСМетаданнымиУХ.Создать();
		
	КонецЕсли;
	
	РаботаСОбъектамиМетаданныхУХ.ИнициализироватьКэш(Кэш, База);
	
	Возврат Истина;
	
КонецФункции	

Процедура ЗаполнитьСписокПлановВидовХарактеристикБД(ТипБД, База = Неопределено, Кэш = Неопределено) Экспорт
	
	Если НЕ ПодключитьсяКИБ(ТипБД, База, Кэш) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(База) = Тип("WSПрокси") Тогда
		РаботаСОбъектамиМетаданныхВнутреннийУХ.ЗаполнитьКэшМетаданныхWS(Кэш, База, "ChartsOfCharacteristicTypes", Истина); 
	КонецЕсли;
	
	МассивСуществующих = Новый Массив;	
	МассивИмен = ПолучитьМассивИменОбъектовБД("ChartsOfCharacteristicTypes", База, Кэш);

	НачатьТранзакцию();
		
	Для Каждого ИмяОбъекта ИЗ МассивИмен Цикл
		
		ОбновитьОписаниеОбъектаБД(База, "ПланВидовХарактеристик", ИмяОбъекта, ТипБД, Истина, Кэш);
		МассивСуществующих.Добавить(СокрЛП(ИмяОбъекта));
		
	КонецЦикла;
	
	МассивСуществующих = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивСуществующих);
	МассивСуществующих = ОбщегоНазначенияКлиентСерверУХ.УдалитьПустыеЭлементыМассива(МассивСуществующих);
	// Обновление реквизита Отсутствует в конфигурации.
	ОбновитьОтсутствующиеВКонфигурации(МассивСуществующих, ТипБД, "Справочник.ПланыВидовХарактеристикБД");
	
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры //

// Обновляет ревизит ОтсутствуетВКонфигурации для справочника Справочник БД по данным
// МассивСуществующихВход для баз данных с типом ТипБдВход.
Процедура ОбновитьОтсутствующиеВКонфигурации(МассивСуществующихВход, ТипБдВход, ИмяСправочникаВход = "")
	// Получение исходных данных.
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	СправочникиБД.Ссылка КАК Ссылка,
	|	СправочникиБД.ОтсутствуетВКонфигурации КАК ОтсутствуетВКонфигурации,
	|	СправочникиБД.Наименование КАК Наименование
	|ИЗ
	|	Справочник.СправочникиБД КАК СправочникиБД
	|ГДЕ
	|	СправочникиБД.Владелец = &Владелец";
	Запрос.УстановитьПараметр("Владелец", ТипБдВход);
	Если СокрЛП(ИмяСправочникаВход) <> "" Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "Справочник.СправочникиБД", ИмяСправочникаВход);
	Иначе
		// Пустой параметр. По умолчанию используем справочники.
	КонецЕсли;
	РезультатЗапроса = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		// Проверим отсутствие элемента в конфигурации.
		ТекНаименованиеСправочника = СокрЛП(ВыборкаДетальныеЗаписи.Наименование);
		ТекСправочникаСсылка = ВыборкаДетальныеЗаписи.Ссылка;
		СправочникНайден = (МассивСуществующихВход.Найти(ТекНаименованиеСправочника) <> Неопределено);
		ТекСправочникПрисутствует = НЕ ВыборкаДетальныеЗаписи.ОтсутствуетВКонфигурации;
		Если СправочникНайден <> ТекСправочникПрисутствует Тогда
			// Есть несоответствие данных. Обновим значения в элементах.
			Попытка
				СправочникОбъект = ТекСправочникаСсылка.ПолучитьОбъект();
				СправочникОбъект.ОтсутствуетВКонфигурации = НЕ СправочникНайден;
				СправочникОбъект.ОбменДанными.Загрузка=Истина;
				СправочникОбъект.Записать();
			Исключение
				ТекстСообщения = НСтр("ru = 'При обновлении поля Отсутствует в конфигурации справочника ИБ %Справочник% возникли ошибки: %ОписаниеОшибки%'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Справочник%", Строка(ТекСправочникаСсылка));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОписаниеОшибки%", ОписаниеОшибки());
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
			КонецПопытки;
		Иначе
			// Не требуется обновление.
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры		// ОбновитьОтсутствующиеВКонфигурации()

// Серверная обёртка команды ПометитьНаУдалениеОтсутствующие.
Функция ПометитьНаУдалениеОтсутствующие(ИмяСправочникаВход = "") Экспорт
	// Получение исходных данных.
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	СправочникиБД.Ссылка КАК Ссылка,
		|	СправочникиБД.ПометкаУдаления КАК ПометкаУдаления,
		|	СправочникиБД.ОтсутствуетВКонфигурации КАК ОтсутствуетВКонфигурации
		|ИЗ
		|	Справочник.СправочникиБД КАК СправочникиБД
		|ГДЕ
		|	НЕ СправочникиБД.ПометкаУдаления
		|	И СправочникиБД.ОтсутствуетВКонфигурации";
	Если СокрЛП(ИмяСправочникаВход) <> "" Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "Справочник.СправочникиБД", ИмяСправочникаВход);
	Иначе
		// Пустой параметр. По умолчанию используем справочники.
	КонецЕсли;
	РезультатЗапроса = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Попытка
			// Пометка на удаление полученных справочников.
			СправочникСсылка = ВыборкаДетальныеЗаписи.Ссылка;
			СправочникОбъект = СправочникСсылка.ПолучитьОбъект();
			СправочникОбъект.ПометкаУдаления = Истина;
			СправочникОбъект.Записать();
		Исключение
			ТекстСообщения = НСтр("ru = 'При установке пометки на удаление справочника БД %Справочник% возникли ошибки: %ОписаниеОшибки%'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Справочник%", Строка(СправочникСсылка));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОписаниеОшибки%", ОписаниеОшибки());
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
		КонецПопытки;
	КонецЦикла;
КонецФункции		// ПометитьНаУдалениеОтсутствующие()

Процедура ЗаполнитьСписокДокументовБД(ТипБД, База = Неопределено, Кэш = Неопределено) Экспорт
	
	Если НЕ ПодключитьсяКИБ(ТипБД, База, Кэш) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипБД.ВерсияПлатформы = Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие77 Тогда
		
		НачатьТранзакцию();
		
		Для Инд = 1 По База.Метаданные().Документ() Цикл
			
			ДокументВИБ 	= База.Метаданные().Документ(Инд);
			ИмяОбъекта 		= ДокументВИБ.Идентификатор;
			
			ОбновитьОписаниеОбъектаБД(База,"Документ",ИмяОбъекта,ТипБД, Истина, Кэш);
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Иначе
		
		Если ТипЗнч(База) = Тип("WSПрокси") Тогда
			РаботаСОбъектамиМетаданныхВнутреннийУХ.ЗаполнитьКэшМетаданныхWS(Кэш, База, "Documents", Истина); 
		КонецЕсли;
		
		МассивСуществующих = Новый Массив;	
		МассивИмен = ПолучитьМассивИменОбъектовБД("Documents", База, Кэш);
		
		НачатьТранзакцию();
		
		Для Каждого ИмяОбъекта ИЗ МассивИмен Цикл
			ОбновитьОписаниеОбъектаБД(База, "Документ", ИмяОбъекта, ТипБД, Истина, Кэш);
			МассивСуществующих.Добавить(СокрЛП(ИмяОбъекта));
		КонецЦикла;
		
		МассивСуществующих = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивСуществующих);
		МассивСуществующих = ОбщегоНазначенияКлиентСерверУХ.УдалитьПустыеЭлементыМассива(МассивСуществующих);
		// Обновление реквизита Отсутствует в конфигурации.
		ОбновитьОтсутствующиеВКонфигурации(МассивСуществующих, ТипБД, "Справочник.ДокументыБД");
		
		ЗафиксироватьТранзакцию();
		
	КонецЕсли;
	
КонецПроцедуры //

Процедура ЗаполнитьСписокПеречисленийБД(ТипБД, База = Неопределено, Кэш = Неопределено) Экспорт
	
	Если НЕ ПодключитьсяКИБ(ТипБД, База, Кэш) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипБД.ВерсияПлатформы = Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие77 Тогда
		
		НачатьТранзакцию();
		
		Для Инд = 1 По База.Метаданные().Перечисление() Цикл
			
			СправочникБД 	= База.Метаданные().Перечисление(Инд);
			ИмяОбъекта 		= СправочникБД.Идентификатор;
			
			ОбновитьОписаниеОбъектаБД(База, "Перечисление", ИмяОбъекта, ТипБД,, Кэш)
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Иначе
		
		Если ТипЗнч(База) = Тип("WSПрокси") Тогда
			РаботаСОбъектамиМетаданныхВнутреннийУХ.ЗаполнитьКэшМетаданныхWS(Кэш, База, "Enums", Ложь); 
		КонецЕсли;
		
		МассивСуществующих = Новый Массив;		
		МассивИмен = ПолучитьМассивИменОбъектовБД("Enums", База, Кэш);
		
		НачатьТранзакцию();
		
		Для Каждого ИмяОбъекта ИЗ МассивИмен Цикл

			ОбновитьОписаниеОбъектаБД(База, "Перечисление", ИмяОбъекта, ТипБД,,Кэш);
			МассивСуществующих.Добавить(СокрЛП(ИмяОбъекта));
			
		КонецЦикла;
		
		МассивСуществующих = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивСуществующих);
		МассивСуществующих = ОбщегоНазначенияКлиентСерверУХ.УдалитьПустыеЭлементыМассива(МассивСуществующих);
		// Обновление реквизита Отсутствует в конфигурации.
		ОбновитьОтсутствующиеВКонфигурации(МассивСуществующих, ТипБД, "Справочник.ПеречисленияБД");
		
		ЗафиксироватьТранзакцию();
		
	КонецЕсли;
	
КонецПроцедуры //

Процедура ЗаполнитьДеревоТЧ(Объект,ТабличныеЧасти) Экспорт 
	
	ТабличныеЧасти.ПолучитьЭлементы().Очистить();
	
	Если Не ЗначениеЗаполнено(Объект.Ссылка) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	ТабличныеЧастиБД.Имя,
	|	ТабличныеЧастиБД.Синоним,
	|	ТабличныеЧастиБД.Реквизиты.(
	|		Синоним,
	|		ТипДанных,
	|		Имя
	|	) КАК Реквизиты,
	|	ТабличныеЧастиБД.Ссылка
	|ИЗ
	|	Справочник.ТабличныеЧастиБД КАК ТабличныеЧастиБД
	|ГДЕ
	|	ТабличныеЧастиБД.Владелец = &Владелец
	|	И НЕ ТабличныеЧастиБД.ПометкаУдаления";
	
	Запрос.УстановитьПараметр("Владелец",Объект.Ссылка);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		СтрокаТЧ=ТабличныеЧасти.ПолучитьЭлементы().Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТЧ,Результат);
		
		РеквизитыТЧ=Результат.Реквизиты.Выбрать();
		
		Пока РеквизитыТЧ.Следующий() Цикл
			
			СтрокаРеквизит=СтрокаТЧ.ПолучитьЭлементы().Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаРеквизит,РеквизитыТЧ);
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // ВернутьДеревоТЧ() 

Процедура ОбновитьОписаниеОбъектаБД(ТекСоединениеВИБ, ТипМетаДанных, ИмяОбъектаБД, Владелец, ОбновлятьТабличныеЧасти = Ложь, 
	Кэш = Неопределено) Экспорт
	
	Если ИмяОбъектаБД="" Тогда
		Возврат ;
	КонецЕсли;
	
	ВладелецДляПоиска = ?(ЗначениеЗаполнено(Владелец), Владелец, Справочники.ТипыБазДанных.ТекущаяИБ);
	ИзменитьСогласование = Ложь;
	
	Если ТипМетаДанных = "Справочник" Тогда
				
		ТекОписание = Справочники.СправочникиБД.НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
		
		Если ЗначениеЗаполнено(ТекОписание) Тогда
			
			ОбъектОписание = ТекОписание.ПолучитьОбъект();
			
		Иначе
			
			ОбъектОписание = Справочники.СправочникиБД.СоздатьЭлемент();
			
		КонецЕсли;
		
		ДанныеОбъектаБД = Новый Структура("ТипОбъектаМетаданных,ИмяОбъектаМетаданных", "Catalogs", ИмяОбъектаБД);
		
		Если (НЕ ОбъектОписание.ПометкаУдаления) И (Метаданные.Справочники.Найти(ИмяОбъектаБД) <> неопределено) тогда
			ОбъектСогласуется = Метаданные.ОпределяемыеТипы.ОбъектыДляСогласования.Тип.СодержитТип(Тип("СправочникСсылка." + ИмяОбъектаБД));
			ИзменитьСогласование = (ОбъектОписание.Согласуется <> ОбъектСогласуется);
		КонецЕсли;
		
	ИначеЕсли ТипМетаДанных="ПланВидовХарактеристик" Тогда
				
		ТекОписание=Справочники.ПланыВидовХарактеристикБД.НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
		
		Если ЗначениеЗаполнено(ТекОписание) Тогда
			
			ОбъектОписание=ТекОписание.ПолучитьОбъект();
			
		Иначе
			
			ОбъектОписание=Справочники.ПланыВидовХарактеристикБД.СоздатьЭлемент();
			
		КонецЕсли;
		
		ДанныеОбъектаБД=Новый Структура("ТипОбъектаМетаданных,ИмяОбъектаМетаданных","ChartsOfCharacteristicTypes",ИмяОбъектаБД);
		
	ИначеЕсли ТипМетаДанных="ПланСчетов" Тогда
				
		ТекОписание=Справочники.ПланыСчетовБД.НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
		
		Если ЗначениеЗаполнено(ТекОписание) Тогда
			
			ОбъектОписание=ТекОписание.ПолучитьОбъект();
			
		Иначе
			
			ОбъектОписание=Справочники.ПланыСчетовБД.СоздатьЭлемент();
			
		КонецЕсли;
		
		ДанныеОбъектаБД=Новый Структура("ТипОбъектаМетаданных,ИмяОбъектаМетаданных","ChartsOfAccounts",ИмяОбъектаБД);
		
	ИначеЕсли ТипМетаДанных="РегистрБухгалтерии" Тогда
				
		ТекОписание=Справочники.РегистрыБухгалтерииБД.НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
		
		Если ЗначениеЗаполнено(ТекОписание) Тогда
			
			ОбъектОписание=ТекОписание.ПолучитьОбъект();
			
		Иначе
			
			ОбъектОписание=Справочники.РегистрыБухгалтерииБД.СоздатьЭлемент();
			
		КонецЕсли;
		
	ИначеЕсли ТипМетаДанных="РегистрНакопления" Тогда
				
		ТекОписание=Справочники.РегистрыНакопленияБД.НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
		
		Если ЗначениеЗаполнено(ТекОписание) Тогда
			
			ОбъектОписание=ТекОписание.ПолучитьОбъект();
			
		Иначе
			
			ОбъектОписание=Справочники.РегистрыНакопленияБД.СоздатьЭлемент();
			
		КонецЕсли;
		
	ИначеЕсли ТипМетаДанных="РегистрСведений" Тогда
				
		ТекОписание=Справочники.РегистрыСведенийБД.НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
		
		Если ЗначениеЗаполнено(ТекОписание) Тогда
			
			ОбъектОписание=ТекОписание.ПолучитьОбъект();
			
		Иначе
			
			ОбъектОписание=Справочники.РегистрыСведенийБД.СоздатьЭлемент();
			
		КонецЕсли;
				
	ИначеЕсли ТипМетаДанных="Документ" Тогда
			
		ТекОписание=Справочники.ДокументыБД.НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
		
		Если ЗначениеЗаполнено(ТекОписание) Тогда
			
			ОбъектОписание=ТекОписание.ПолучитьОбъект();
			
		Иначе
			
			ОбъектОписание=Справочники.ДокументыБД.СоздатьЭлемент();
			
		КонецЕсли;
		
		ДанныеОбъектаБД=Новый Структура("ТипОбъектаМетаданных,ИмяОбъектаМетаданных","Documents",ИмяОбъектаБД);
		
		Если (НЕ ОбъектОписание.ПометкаУдаления) И (Метаданные.Документы.Найти(ИмяОбъектаБД) <> неопределено) тогда
			ОбъектСогласуется = Метаданные.ОпределяемыеТипы.ОбъектыДляСогласования.Тип.СодержитТип(Тип("ДокументСсылка." + ИмяОбъектаБД));
			ИзменитьСогласование = (ОбъектОписание.Согласуется <> ОбъектСогласуется);
		КонецЕсли;
		
	ИначеЕсли ТипМетаДанных="Перечисление" Тогда
			
		ТекОписание=Справочники.ПеречисленияБД.НайтиПоНаименованию(ИмяОбъектаБД,Истина,,ВладелецДляПоиска);
		
		Если ЗначениеЗаполнено(ТекОписание) Тогда
			
			ОбъектОписание=ТекОписание.ПолучитьОбъект();
			
		Иначе
			
			ОбъектОписание=Справочники.ПеречисленияБД.СоздатьЭлемент();
			
		КонецЕсли;
		
	КонецЕсли;
	
	ЕстьИзменения = ОбъектОписание.ЭтоНовый();
	ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ОбъектОписание.Владелец, ВладелецДляПоиска, ЕстьИзменения);
	ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ОбъектОписание.Наименование, ИмяОбъектаБД, ЕстьИзменения);
	ЕстьИзменения = Макс(ЕстьИзменения, ИзменитьСогласование);
	
	ОбъектОписание.ТекСоединениеВИБ = ТекСоединениеВИБ;
	ОбъектОписание.ЗаполнитьРеквизитыОбъекта(Кэш, ЕстьИзменения);
	
	Если ЕстьИзменения Тогда
		ОбъектОписание.Записать();
	КонецЕсли;	
	
	Если ОбновлятьТабличныеЧасти Тогда
		
		ОбновитьОписаниеТабличнойЧастиБД(ТекСоединениеВИБ, ОбъектОписание.Ссылка, ДанныеОбъектаБД, 
			ВладелецДляПоиска.ВерсияПлатформы=Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие77,
			Кэш);
		
	КонецЕсли;
	
КонецПроцедуры // СоздатьОписаниеПланаСчетовВИБ()


#КонецОбласти

Функция ПолучитьДанныеОбъектаБД(ОписаниеОбъектаБД) Экспорт
	
	ОбъектМетаданных						= Неопределено;
	СоздаватьПриНеудачномПоискеПриИмпорте	= Ложь;
	ОбновлятьРеквизитыПриИмпорте			= Ложь;
	РазделятьПоОрганизациям					= Ложь;

	Если ТипЗнч(ОписаниеОбъектаБД)=Тип("Строка") Тогда
		
		ТаблицаАналитики=ОписаниеОбъектаБД;
		
	Иначе
		
		Запрос=Новый Запрос;
		Запрос.Текст="ВЫБРАТЬ
		|	ВидыСубконтоКорпоративные.ТипЗначения,
		|	ВидыСубконтоКорпоративные.СоздаватьПриНеудачномПоискеПриИмпорте,
		|	ВидыСубконтоКорпоративные.ОбновлятьРеквизитыПриИмпорте,
		|	ВидыСубконтоКорпоративные.РазделятьПоОрганизациям
		|ИЗ
		|	ПланВидовХарактеристик.ВидыСубконтоКорпоративные КАК ВидыСубконтоКорпоративные
		|ГДЕ
		|	ВидыСубконтоКорпоративные.Ссылка = &Ссылка";
		
		Запрос.УстановитьПараметр("Ссылка",ОписаниеОбъектаБД);
		
		Результат=Запрос.Выполнить().Выбрать();
		
		Результат.Следующий();
		
		ОбъектМетаданных=Метаданные.НайтиПоТипу(Результат.ТипЗначения.Типы()[0]);
		
		ТаблицаАналитики=ОбъектМетаданных.ПолноеИмя();
		
		СоздаватьПриНеудачномПоискеПриИмпорте	= Результат.СоздаватьПриНеудачномПоискеПриИмпорте;
		ОбновлятьРеквизитыПриИмпорте			= Результат.ОбновлятьРеквизитыПриИмпорте;
		РазделятьПоОрганизациям					= Результат.РазделятьПоОрганизациям;
				
	КонецЕсли;
		
	МетаданныеОбъекта=РазложитьСтрокуВМассивПодстрок(ТаблицаАналитики,".");
	
	ТипОбъектаМетаданных=МетаданныеОбъекта[0];
	ИмяОбъектаМетаданных=МетаданныеОбъекта[1];
		
	Если ТипОбъектаМетаданных="Справочник" Тогда
		
		ТаблицаОписания="Справочник.СправочникиБД";
		
		Если ОбъектМетаданных=Неопределено Тогда
			
			ОбъектМетаданных=Метаданные.Справочники[ИмяОбъектаМетаданных];
			
		КонецЕсли;
		
		Если НЕ ТаблицаОписания="Справочник.ПроизвольныйКлассификаторУХ" Тогда
			
			Запрос=Новый Запрос;
			Запрос.Текст="ВЫБРАТЬ
			|	СправочникиБД.СоздаватьПриНеудачномПоискеПриИмпорте,
			|	СправочникиБД.ОбновлятьРеквизитыПриИмпорте
			|ИЗ
			|	Справочник.СправочникиБД КАК СправочникиБД
			|ГДЕ
			|	СправочникиБД.Наименование = &Наименование
			|	И СправочникиБД.Владелец = ЗНАЧЕНИЕ(Справочник.ТипыБазДанных.ТекущаяИБ)";
			
			Запрос.УстановитьПараметр("Наименование",ИмяОбъектаМетаданных);
			
			Результат=Запрос.Выполнить().Выбрать();
			
			Если Результат.Следующий() Тогда
				
				СоздаватьПриНеудачномПоискеПриИмпорте	= Результат.СоздаватьПриНеудачномПоискеПриИмпорте;
				ОбновлятьРеквизитыПриИмпорте			= Результат.ОбновлятьРеквизитыПриИмпорте;
				
			КонецЕсли;
			
		КонецЕсли;	
		
	ИначеЕсли ТипОбъектаМетаданных="ПланСчетов" Тогда
		
		ТаблицаОписания="Справочник.ПланыСчетовБД";
		
		Если ОбъектМетаданных=Неопределено Тогда
			
			ОбъектМетаданных=Метаданные.ПланыСчетов[ИмяОбъектаМетаданных];
			
		КонецЕсли;
				
	ИначеЕсли ТипОбъектаМетаданных="ПланВидовХарактеристик" Тогда
		
		ТаблицаОписания="Справочник.ПланыВидовХарактеристикБД";
		
		Если ОбъектМетаданных=Неопределено Тогда
			
			ОбъектМетаданных=Метаданные.ПланыВидовХарактеристик[ИмяОбъектаМетаданных];
			
		КонецЕсли;
		
		Запрос=Новый Запрос;
		Запрос.Текст="ВЫБРАТЬ
		|	ПланыВидовХарактеристикБД.СоздаватьПриНеудачномПоискеПриИмпорте КАК СоздаватьПриНеудачномПоискеПриИмпорте,
		|	ПланыВидовХарактеристикБД.ОбновлятьРеквизитыПриИмпорте КАК ОбновлятьРеквизитыПриИмпорте
		|ИЗ
		|	Справочник.ПланыВидовХарактеристикБД КАК ПланыВидовХарактеристикБД
		|ГДЕ
		|	ПланыВидовХарактеристикБД.Наименование = &Наименование
		|	И ПланыВидовХарактеристикБД.Владелец = ЗНАЧЕНИЕ(Справочник.ТипыБазДанных.ТекущаяИБ)";
		
		Запрос.УстановитьПараметр("Наименование",ИмяОбъектаМетаданных);
		
		Результат=Запрос.Выполнить().Выбрать();
		
		Если Результат.Следующий() Тогда
			
			СоздаватьПриНеудачномПоискеПриИмпорте	= Результат.СоздаватьПриНеудачномПоискеПриИмпорте;
			ОбновлятьРеквизитыПриИмпорте			= Результат.ОбновлятьРеквизитыПриИмпорте;
			
		КонецЕсли;
			
	ИначеЕсли ТипОбъектаМетаданных="РегистрБухгалтерии" Тогда
				
		ТаблицаОписания="Справочник.РегистрыБухгалтерииБД";
		
		Если ОбъектМетаданных=Неопределено Тогда
			
			ОбъектМетаданных=Метаданные.РегистрыБухгалтерии[ИмяОбъектаМетаданных];
			
		КонецЕсли;
				
	ИначеЕсли ТипОбъектаМетаданных="РегистрНакопления" Тогда
				
		ТаблицаОписания="Справочник.РегистрыНакопленияБД";
		
		Если ОбъектМетаданных=Неопределено Тогда
			
			ОбъектМетаданных=Метаданные.РегистрыНакопления[ИмяОбъектаМетаданных];
			
		КонецЕсли;
				
	ИначеЕсли ТипОбъектаМетаданных="Документ" Тогда
			
		ТаблицаОписания="Справочник.ДокументыБД";
		
		Если ОбъектМетаданных=Неопределено Тогда
			
			ОбъектМетаданных=Метаданные.Документы[ИмяОбъектаМетаданных];
			
		КонецЕсли;
			
	ИначеЕсли ТипОбъектаМетаданных="Перечисление" Тогда
			
		ТаблицаОписания="Справочник.ПеречисленияБД";
		
		Если ОбъектМетаданных=Неопределено Тогда
			
			ОбъектМетаданных=Метаданные.Перечисления[ИмяОбъектаМетаданных];
			
		КонецЕсли;
				
	КонецЕсли;
	
	Данныеобъекта=Новый Структура;
	ДанныеОбъекта.Вставить("ТипОбъектаМетаданных"					,ТипОбъектаМетаданных);
	ДанныеОбъекта.Вставить("ИмяОбъектаМетаданных"					,ИмяОбъектаМетаданных);
	ДанныеОбъекта.Вставить("ТаблицаОписания"						,ТаблицаОписания);
	ДанныеОбъекта.Вставить("ОбъектМетаданных"						,ОбъектМетаданных);
	ДанныеОбъекта.Вставить("СоздаватьПриНеудачномПоискеПриИмпорте"	,СоздаватьПриНеудачномПоискеПриИмпорте);
	ДанныеОбъекта.Вставить("ОбновлятьРеквизитыПриИмпорте"			,ОбновлятьРеквизитыПриИмпорте);
	ДанныеОбъекта.Вставить("РазделятьПоОрганизациям"				,РазделятьПоОрганизациям);
	
	Возврат Данныеобъекта;
	
КонецФункции // ПолучитьДанныеОбъектаБД()


Процедура ОбновитьОписаниеТабличнойЧастиБД(СоединениеВИБ, ВладелецТЧ, ДанныеВладельцаТЧ, Использование77 = Ложь, 
	Кэш = Неопределено) Экспорт
	
	МассивТЧ = ПолучитьМассивСтруктурТабличныхЧастей1С(СоединениеВИБ, ДанныеВладельцаТЧ, Использование77, Кэш);
	
	НачатьТранзакцию();
		
	Для Каждого ТЧ Из МассивТЧ Цикл
		
		ЕстьИзменения = Ложь;
		ТабличнаяЧастьСсылка = Справочники.ТабличныеЧастиБД.НайтиПоРеквизиту("Имя", ТЧ.Имя,, ВладелецТЧ);	
		Если ТабличнаяЧастьСсылка.Пустая() Тогда
			
			ТабличнаяЧастьОбъект = Справочники.ТабличныеЧастиБД.СоздатьЭлемент();
			ТабличнаяЧастьОбъект.Владелец = ВладелецТЧ;
			ТабличнаяЧастьОбъект.Имя = ТЧ.Имя;
			ТабличнаяЧастьОбъект.Наименование = ТЧ.Представление;
			ЕстьИзменения = Истина;
		Иначе		
			ТабличнаяЧастьОбъект = ТабличнаяЧастьСсылка.ПолучитьОбъект();
			ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ТабличнаяЧастьОбъект.ПометкаУдаления, Ложь, ЕстьИзменения);			
		КонецЕсли;
			
		ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ТабличнаяЧастьОбъект.Наименование, ТЧ.Представление, ЕстьИзменения);
		ОбщегоНазначенияКлиентСерверУХ.УстановитьНовоеЗначение(ТабличнаяЧастьОбъект.Синоним, ТЧ.Представление, ЕстьИзменения);
		
		ТабНовыеРеквизиты = ТабличнаяЧастьОбъект.Реквизиты.ВыгрузитьКолонки();
		Для Каждого РеквизитТЧ Из ТЧ.Реквизиты Цикл
			
			НоваяСтрока = ТабНовыеРеквизиты.Добавить();
			НоваяСтрока.Имя = РеквизитТЧ.Имя;			
			НоваяСтрока.Синоним = РеквизитТЧ.Представление;
			НоваяСтрока.ТипДанных = РеквизитТЧ.Тип;
			НоваяСтрока.ОписаниеПримитивногоТипа = РеквизитТЧ.ОписаниеПримитивногоТипа;		
		КонецЦикла;
		
		ОбщегоНазначенияУХ.ЗагрузитьИзмененнуюТабЧасть(ТабличнаяЧастьОбъект.Реквизиты, ТабНовыеРеквизиты, ЕстьИзменения);
		
		Если ЕстьИзменения Тогда
			ТабличнаяЧастьОбъект.Записать();
		КонецЕсли;	
				
	КонецЦикла;
		
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры

Функция ПринудительноеЗаполнениеПоля(СтрПравило) Экспорт
			
	Возврат СтрПравило.СпособЗаполнения=Перечисления.СпособыЗаполненияПолейИсточника.КонтекстОбъектаЗагрузки
			ИЛИ СтрПравило.СпособЗаполнения=Перечисления.СпособыЗаполненияПолейИсточника.ФиксированноеЗначение
			ИЛИ СтрПравило.СпособЗаполнения=Перечисления.СпособыЗаполненияПолейИсточника.РучнойВвод
			ИЛИ СтрПравило.СпособЗаполнения=Перечисления.СпособыЗаполненияПолейИсточника.ПолеДругогоИсточникаДанных;
			
КонецФункции // ПринудительноеЗаполнениеПоля() 

Функция ОтборПоАналитикамЭкземпляраОтчета(СпособВычисленияПараметра) Экспорт
	
	Возврат (СтрНайти(XMLСтрока(СпособВычисленияПараметра),"Аналитика")>0
	ИЛИ СпособВычисленияПараметра=Перечисления.СпособыВычисленияПараметровОперандов.ОрганизацияОтчета
	ИЛИ СпособВычисленияПараметра=Перечисления.СпособыВычисленияПараметровОперандов.ПроектОтчета
	ИЛИ СпособВычисленияПараметра=Перечисления.СпособыВычисленияПараметровОперандов.ПроектОтчетаИерархия
	ИЛИ СпособВычисленияПараметра=Перечисления.СпособыВычисленияПараметровОперандов.СценарийОтчета
	ИЛИ СпособВычисленияПараметра=Перечисления.СпособыВычисленияПараметровОперандов.ПериметрОтчета
	ИЛИ СпособВычисленияПараметра=Перечисления.СпособыВычисленияПараметровОперандов.ВалютаОтчета);
	
КонецФункции // ОтборПоАналитикамЭкземпляраОтчета()
	
//////////////////////////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМОВ УПРАВЛЕНИЯ НСИ

// Функция получает список реквизитов для конкретного справочника ИБ Консолидации
// Параметры:
//  ЛокальныйСправочник - Строка, хранит имя справочника в ВИБ
//                        ВидХарактеристик, хранит ссылку на вид характеристик
//  СписокРеквизитов    - СписокЗначений, получает список реквизитов справочника ИБ Консолидации
//  
Функция ПолучитьЛокальныйСписокРеквизитов(ТипОбъектаКонсолидации,ИмяОбъектаМетаданных) Экспорт
	
	СписокПримитивныхЗначений = Новый СписокЗначений;
	СписокСсылочныхЗначений   = Новый СписокЗначений;
	
	Если ПустаяСтрока(ИмяОбъектаМетаданных) Тогда
		Возврат  Новый Структура("ПримитивныеРеквизиты,СсылочныеРеквизиты",СписокПримитивныхЗначений,СписокСсылочныхЗначений);;
	КонецЕсли;
	
	Если ТипОбъектаКонсолидации="Справочник" Тогда
		
		МетаДанныеСправочник = МетаДанные.Справочники[ИмяОбъектаМетаданных];
		
		Если МетаДанныеСправочник <> Неопределено Тогда
			Для Каждого Реквизит Из МетаДанныеСправочник.Реквизиты Цикл
				
				Если СтрНайти(Реквизит.Имя,"НСИ_")>0 Тогда
					Продолжить;
				КонецЕсли;
				
				Если ОбщегоНазначенияУХ.ПроверитьНаПримитивныйТипКонсолидация(Реквизит) Тогда
					СписокПримитивныхЗначений.Добавить(Реквизит.Имя);
				Иначе
					СписокСсылочныхЗначений.Добавить(Реквизит.Имя);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если МетаданныеСправочник.ДлинаНаименования>0 Тогда	
			СписокПримитивныхЗначений.Вставить(0,"Наименование");
		КонецЕсли;
		
		Если МетаданныеСправочник.ДлинаКода>0 Тогда	
			СписокПримитивныхЗначений.Вставить(0,"Код");
		КонецЕсли;
		
	ИначеЕсли ТипОбъектаКонсолидации="ПланВидовХарактеристик" Тогда
		
		МетаДанныеСправочник = МетаДанные.ПланыВидовХарактеристик[ИмяОбъектаМетаданных];
		
		Если МетаДанныеСправочник <> Неопределено Тогда
			Для Каждого Реквизит Из МетаДанныеСправочник.Реквизиты Цикл
				
				Если СтрНайти(Реквизит.Имя,"НСИ_")>0 Тогда
					Продолжить;
				КонецЕсли;
				
				Если ОбщегоНазначенияУХ.ПроверитьНаПримитивныйТипКонсолидация(Реквизит) Тогда
					СписокПримитивныхЗначений.Добавить(Реквизит.Имя);
				Иначе
					СписокСсылочныхЗначений.Добавить(Реквизит.Имя);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если МетаданныеСправочник.ДлинаНаименования>0 Тогда	
			СписокПримитивныхЗначений.Вставить(0,"Наименование");
		КонецЕсли;
		
		Если МетаданныеСправочник.ДлинаКода>0 Тогда	
			СписокПримитивныхЗначений.Вставить(0,"Код");
		КонецЕсли;
		
	ИначеЕсли ТипОбъектаКонсолидации="ВидСубконто" Тогда
		
		МетаДанныеСправочник = ПолучитьСправочникПоВидуСубконто (ИмяОбъектаМетаданных);
		
		Если МетаДанныеСправочник <> Неопределено Тогда
			
			Для Каждого Реквизит Из МетаДанныеСправочник.Реквизиты Цикл
				
				Если СтрНайти(Реквизит.Имя,"НСИ_")>0 Тогда
					Продолжить;
				КонецЕсли;
				
				Если ОбщегоНазначенияУХ.ПроверитьНаПримитивныйТипКонсолидация(Реквизит) Тогда
					СписокПримитивныхЗначений.Добавить(Реквизит.Имя);
				Иначе
					СписокСсылочныхЗначений.Добавить(Реквизит.Имя);
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
		СписокПримитивныхЗначений.Вставить(0,"Наименование");
		СписокПримитивныхЗначений.Вставить(0,"Код");
		
	ИначеЕсли ТипОбъектаКонсолидации="Документ" Тогда 
		
		МетаДанныеДокумент = МетаДанные.Документы[ИмяОбъектаМетаданных];
		
		Если МетаДанныеДокумент <> Неопределено Тогда
			Для Каждого Реквизит Из МетаДанныеДокумент.Реквизиты Цикл
				
				Если СтрНайти(Реквизит.Имя,"НСИ_")>0 Тогда
					Продолжить;
				КонецЕсли;
				
				Если ОбщегоНазначенияУХ.ПроверитьНаПримитивныйТипКонсолидация(Реквизит) Тогда
					СписокПримитивныхЗначений.Добавить(Реквизит.Имя);
				Иначе
					СписокСсылочныхЗначений.Добавить(Реквизит.Имя);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		СписокПримитивныхЗначений.Вставить(0,"Номер");
		СписокПримитивныхЗначений.Вставить(0,"Дата");
		
	ИначеЕсли ТипОбъектаКонсолидации="Перечисление" Тогда
		
		СписокПримитивныхЗначений.Добавить("Наименование");
		
	ИначеЕсли ТипОбъектаКонсолидации="ПланСчетов" Тогда
		
		СписокПримитивныхЗначений.Добавить("Код");
		
	КонецЕсли;
	
	Возврат Новый Структура("ПримитивныеРеквизиты,СсылочныеРеквизиты",СписокПримитивныхЗначений,СписокСсылочныхЗначений);
	
КонецФункции

Функция ЗаполнитьТабличноеПолеРеквизитов(ИмяСправочника,Ссылка) Экспорт
	
	Запрос       = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	СоответствиеВнешнимИБСоответствиеРеквизитов.РеквизитОбъектаКонсолидации,
	|	СоответствиеВнешнимИБСоответствиеРеквизитов.РеквизитОбъектаВнешнейИБ,
	|	ВЫБОР
	|		КОГДА СоответствиеВнешнимИБСоответствиеРеквизитов.РеквизитОбъектаКонсолидации = """"
	|				ИЛИ СоответствиеВнешнимИБСоответствиеРеквизитов.РеквизитОбъектаВнешнейИБ = """"
	|			ТОГДА ЛОЖЬ
	|		ИНАЧЕ ИСТИНА
	|	КОНЕЦ КАК Сопоставлено,
	|"+?(ИмяСправочника="ПеречисленияБД","ЛОЖЬ","СоответствиеВнешнимИБСоответствиеРеквизитов.НеИспользоватьДляСинхронизации")+" КАК НеИспользоватьДляСинхронизации 
	|ИЗ
	|	Справочник."+ИмяСправочника+".СоответствиеРеквизитов КАК СоответствиеВнешнимИБСоответствиеРеквизитов
	|ГДЕ
	|	СоответствиеВнешнимИБСоответствиеРеквизитов.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	ПолеСоответствияРеквизитов = Запрос.Выполнить().Выгрузить();
	ПолеСоответствияРеквизитов.Сортировать("Сопоставлено Убыв, РеквизитОбъектаКонсолидации, РеквизитОбъектаВнешнейИБ");
	
	Возврат ПолеСоответствияРеквизитов; 
	
КонецФункции

Процедура ПроставитьСостояниеСогласованности(ПолеСоответствияРеквизитов,ТекущаяСтрока = Неопределено) Экспорт
	Если ПустаяСтрока(ТекущаяСтрока) Тогда
		Для Каждого Элемент Из ПолеСоответствияРеквизитов Цикл
			
			Если ПустаяСтрока(Элемент.РеквизитОбъектаКонсолидации) 
				ИЛИ ПустаяСтрока(Элемент.РеквизитОбъектаВнешнейИБ) Тогда
				
				Элемент.Сопоставлено = Ложь;
			Иначе
				Элемент.Сопоставлено = Истина;
			КонецЕсли;
			
		КонецЦикла;
	Иначе
		Если ПустаяСтрока(ТекущаяСтрока.РеквизитОбъектаКонсолидации) 
			ИЛИ ПустаяСтрока(ТекущаяСтрока.РеквизитОбъектаВнешнейИБ) Тогда
			
			ТекущаяСтрока.Сопоставлено = Ложь;
		Иначе
			ТекущаяСтрока.Сопоставлено = Истина;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьСтолбецЛокальныхРеквизитов(ПолеСоответствияРеквизитов,ТипОбъектаКонсолидации,ИмяОбъектаМетаданных,ОчищатьСтолбец = Истина) Экспорт
	
	СписокЛокальныхРеквизитов=ПолучитьЛокальныйСписокРеквизитов(ТипОбъектаКонсолидации,ИмяОбъектаМетаданных).ПримитивныеРеквизиты;
	
	Если ОчищатьСтолбец Тогда
		
		ПолеСоответствияРеквизитов.ЗаполнитьЗначения(Неопределено, "РеквизитОбъектаКонсолидации");
		
		Для Каждого Элемент Из СписокЛокальныхРеквизитов Цикл
			
			РеквизитОбъектаКонсолидации=Элемент.Значение;
			
			Если РеквизитОбъектаКонсолидации="Код" Тогда
				СтрокаСоответствия=ПолеСоответствияРеквизитов.Добавить();
				СтрокаСоответствия.РеквизитОбъектаКонсолидации = Элемент.Значение;
				Продолжить;
			ИначеЕсли РеквизитОбъектаКонсолидации="КодДляСинхронизации" Тогда
				РеквизитОбъектаКонсолидации="Код";
			КонецЕсли;
			
			СтрокаСоответствия =  ПолеСоответствияРеквизитов.Найти(РеквизитОбъектаКонсолидации, "РеквизитОбъектаВнешнейИБ");
			СтрокаСоответствия = ?(ПустаяСтрока(СтрокаСоответствия), ПолеСоответствияРеквизитов.Добавить(), СтрокаСоответствия);
			СтрокаСоответствия.РеквизитОбъектаКонсолидации = Элемент.Значение;
			ПроставитьСостояниеСогласованности(ПолеСоответствияРеквизитов,СтрокаСоответствия);
		КонецЦикла;
		
		Инд = 0;
		Пока Инд < ПолеСоответствияРеквизитов.Количество() Цикл 
			
			Элемент = ПолеСоответствияРеквизитов[Инд];
			Если ПустаяСтрока(Элемент.РеквизитОбъектаКонсолидации) И ПустаяСтрока(Элемент.РеквизитОбъектаВнешнейИБ) Тогда
				ПолеСоответствияРеквизитов.Удалить(Элемент);
			Иначе
				Инд = Инд + 1;
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		Для Каждого Элемент Из СписокЛокальныхРеквизитов Цикл
			Если ПустаяСтрока(ПолеСоответствияРеквизитов.Найти(Элемент.Значение, "РеквизитОбъектаКонсолидации")) Тогда
				
				СтрокаСоответствия                             = ПолеСоответствияРеквизитов.Добавить();
				СтрокаСоответствия.РеквизитОбъектаКонсолидации = Элемент.Значение;
				СтрокаСоответствия.Сопоставлено                = Ложь;
				
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ПолеСоответствияРеквизитов.Сортировать("Сопоставлено Убыв, РеквизитОбъектаВнешнейИБ, РеквизитОбъектаКонсолидации");
	
КонецПроцедуры

Функция ЗаполнитьТаблицуРеквизитовКонсолидации(ОбъектМетаданных) Экспорт
	
	ТаблицаРеквизитовКонсолидации=Новый ТаблицаЗначений;
	ТаблицаРеквизитовКонсолидации.Колонки.Добавить("ИмяРеквизита",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(50));
	ТаблицаРеквизитовКонсолидации.Колонки.Добавить("ТипЗначения");
	ТаблицаРеквизитовКонсолидации.Колонки.Добавить("ТипОбъектаКонсолидации",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(50));
	ТаблицаРеквизитовКонсолидации.Колонки.Добавить("ИмяОбъектаМетаДанных",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(50));
	ТаблицаРеквизитовКонсолидации.Колонки.Добавить("ПримитивныйТип",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповБулево());
	
	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
		
		Если СтрНайти(Реквизит.Имя,"НСИ_")>0 Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока=ТаблицаРеквизитовКонсолидации.Добавить();
		НоваяСтрока.ИмяРеквизита=Реквизит.Имя;	
		
		Если Реквизит.Тип.Типы()[0]=Тип("Строка") ИЛИ ОбщегоНазначенияУХ.ПроверитьНаПримитивныйТипКонсолидация(Реквизит) Тогда
			
			НоваяСтрока.ПримитивныйТип=Истина;
			
		Иначе
			
			НоваяСтрока.ТипЗначения=Реквизит.Тип.Типы()[0];
			
			ТаблицаАналитики=Метаданные.НайтиПоТипу(НоваяСтрока.ТипЗначения).ПолноеИмя();
			ДанныеСинхронизации=ОбщегоНазначенияУХ.РазложитьСтрокуВМассивПодстрок(ТаблицаАналитики,".");
			
			НоваяСтрока.ТипОбъектаКонсолидации=ДанныеСинхронизации[0];
			НоваяСтрока.ИмяОбъектаМетаданных=ДанныеСинхронизации[1];
			
		КонецЕсли;	
		
	КонецЦикла;
	
	Возврат ТаблицаРеквизитовКонсолидации; 
	
КонецФункции // ЗаполнитьТаблицуРеквизитовКонсолидации()

// Функция получает объект справочника, на который ссылается ВидСубконто
//
Функция ПолучитьСправочникПоВидуСубконто (ВидСубконто) Экспорт
	
	МетаДанныеСправочник = Метаданные.НайтиПоТипу(ВидСубконто.ТипЗначения.Типы()[0]);	
	Возврат МетаДанныеСправочник;
	
КонецФункции

// Функция определяет, является ли справочник иерархическим.
// Параметры:
//  Справочник      - Строка, Справочник.ЛюбаяСсылка, имя или ссылка на проверяемый справочник.
//  ЯвляетсяЛокальным - Булево, признак принадлежности справочника локальной ИБ.
//
Функция ИерархическийСправочник(Справочник, ЯвляетсяЛокальным = Истина) Экспорт
			
	Если ЯвляетсяЛокальным Тогда
		
		Если ТипЗнч(Справочник) = Тип("Строка") Тогда	
			МетаДанныеСправочник = МетаДанные.Справочники[Справочник]
		Иначе
			МетаДанныеСправочник = Справочник;
		КонецЕсли;
		
		Возврат МетаДанныеСправочник.Иерархический;
		
	Иначе
		
		Возврат Справочник.Hierarchical;
		
	КонецЕсли;
	
КонецФункции

// Функция проверяет на возможность использовать аналитику внешней информационной базы 
// в отборе. 
Функция ПроверитьНаПримитивныйТипКонсолидация(Аналитика) Экспорт
	
	ДлинаСимвольногоПоля = Аналитика.Тип.КвалификаторыСтроки.Длина;
	
	Для Каждого ТипКонсолидации Из Аналитика.Тип.Типы() Цикл
		СложныйТип = Истина;
		
		Если ТипКонсолидации = Тип("Булево") Тогда
			СложныйТип = Ложь;
		КонецЕсли;
		
		Если ТипКонсолидации = Тип("Число") Тогда
			СложныйТип = Ложь;
		КонецЕсли;
		
		Если ТипКонсолидации = Тип("Дата") Тогда
			СложныйТип = Ложь;
		КонецЕсли;
		
		Если ТипКонсолидации = Тип("Строка") Тогда
			Если ДлинаСимвольногоПоля <> 0 Тогда
				СложныйТип = Ложь;
			КонецЕсли;
		КонецЕсли;
		
		Если СложныйТип Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Функция заполняет список значений аналитик переданного объекта (вида отчета или группы раскрытия показателя).
// Параметры:
//	ОбъектАналитики - объект, виды аналитики которого анализируются.
//  ТаблицаАналитик- Таблица значений, список, в который помещаются наименования
//	 аналитик показателя.
//
Функция ЗаполнитьВидыАналитик(ОбъектАналитики, НеВключатьАналитикуВГО = Ложь, ДобавлятьПоказатели=Ложь,ПоказательОтбор=Неопределено) Экспорт
		
	ТаблицаАналитик=Новый ТаблицаЗначений;
	ТаблицаАналитик.Колонки.Добавить("КодАналитики");
	ТаблицаАналитик.Колонки.Добавить("НаименованиеАналитики");
	ТаблицаАналитик.Колонки.Добавить("ВидАналитики");
	ТаблицаАналитик.Колонки.Добавить("ТипЗначенияАналитики");
	ТаблицаАналитик.Колонки.Добавить("ТипДанныхАналитики");
	ТаблицаАналитик.Колонки.Добавить("ПредставлениеАналитики");
	ТаблицаАналитик.Колонки.Добавить("ТаблицаАналитики");
	ТаблицаАналитик.Колонки.Добавить("ИерархияГруппИЭлементов",ОбщегоНазначенияУХ.ПолучитьОписаниеТиповБулево());
	
	Если ОбъектАналитики=Неопределено
		ИЛИ ОбъектАналитики=Справочники.ГруппыРаскрытия.ПустаяСсылка()
		ИЛИ ТипЗнч(ОбъектАналитики)=Тип("СправочникСсылка.ШаблоныТрансформационныхКорректировок") Тогда
		
		Возврат ТаблицаАналитик;
		
	КонецЕсли;
	
	Если НеВключатьАналитикуВГО Тогда
		АналитикаВГО = ОбъектАналитики.АналитикаВГО;
	Иначе
		АналитикаВГО = 0;
	КонецЕсли;
	
	Если ТипЗнч(ОбъектАналитики.Владелец)= Тип("СправочникСсылка.ШаблоныТрансформационныхКорректировок") Тогда
		
		ВидАналитики = ?(ЗначениеЗаполнено(ОбъектАналитики["ВидАналитикиВалютаДт"]),ОбъектАналитики["ВидАналитикиВалютаДт"],ОбъектАналитики["ВидАналитикиВалютаКт"]);
		
		Если Не ПустаяСтрока(ВидАналитики) Тогда
			
			НоваяСтрока=ТаблицаАналитик.Добавить();
			НоваяСтрока.НаименованиеАналитики	= Строка(ВидАналитики);
			НоваяСтрока.ВидАналитики			= ВидАналитики;
			НоваяСтрока.ПредставлениеАналитики	= Нстр("ru = 'Валюта проводки'");
			НоваяСтрока.ТипЗначенияАналитики	= ВидАналитики.ТипЗначения;
			НоваяСтрока.ТипДанныхАналитики		= НоваяСтрока.ТипЗначенияАналитики.Типы()[0];
			НоваяСтрока.КодАналитики			= "АналитикаВалюта";
			НоваяСтрока.ТаблицаАналитики		= ?(НоваяСтрока.ТипДанныхАналитики = Тип("Строка"), "", Метаданные.НайтиПоТипу(НоваяСтрока.ТипДанныхАналитики).ПолноеИмя());
			НоваяСтрока.ИерархияГруппИЭлементов	= ИерархияГруппИЭлементов(НоваяСтрока.ТаблицаАналитики);
			
		КонецЕсли;

		Для Индекс=1 ПО ОбъектАналитики.ЧислоАналитикДт Цикл  
			
			Если ЗначениеЗаполнено(ОбъектАналитики["ВидАналитики"+Индекс]) Тогда
				
				ВидАналитики=ОбъектАналитики["ВидАналитики"+Индекс];
				
				НоваяСтрока=ТаблицаАналитик.Добавить();
				НоваяСтрока.НаименованиеАналитики	= Строка(ВидАналитики);
				НоваяСтрока.ВидАналитики			= ВидАналитики;
				НоваяСтрока.ПредставлениеАналитики	= "АналитикаДт"+Индекс+": "+Строка(ВидАналитики);
				НоваяСтрока.ТипЗначенияАналитики	= ВидАналитики.ТипЗначения;
				НоваяСтрока.ТипДанныхАналитики		= НоваяСтрока.ТипЗначенияАналитики.Типы()[0];
				НоваяСтрока.КодАналитики			= "Аналитика"+Индекс;
				НоваяСтрока.ТаблицаАналитики		= ?(НоваяСтрока.ТипДанныхАналитики = Тип("Строка"), "", Метаданные.НайтиПоТипу(НоваяСтрока.ТипДанныхАналитики).ПолноеИмя());				
				НоваяСтрока.ИерархияГруппИЭлементов	= ИерархияГруппИЭлементов(НоваяСтрока.ТаблицаАналитики);
				
			КонецЕсли;
			
		КонецЦикла;
				
		Инд=1;
		
		Для Индекс=(ОбъектАналитики.ЧислоАналитикДт+1) ПО (ОбъектАналитики.ЧислоАналитикДт+ОбъектАналитики.ЧислоАналитикКт) Цикл  
			
			Если ЗначениеЗаполнено(ОбъектАналитики["ВидАналитики"+Индекс]) Тогда
				
				ВидАналитики=ОбъектАналитики["ВидАналитики"+Индекс];
				НоваяСтрока=ТаблицаАналитик.Добавить();
				НоваяСтрока.НаименованиеАналитики	= Строка(ВидАналитики);
				НоваяСтрока.ВидАналитики			= ВидАналитики;
				НоваяСтрока.ПредставлениеАналитики	= "АналитикаКт"+Инд+": "+Строка(ВидАналитики);
				НоваяСтрока.ТипЗначенияАналитики	= ВидАналитики.ТипЗначения;
				НоваяСтрока.ТипДанныхАналитики		= НоваяСтрока.ТипЗначенияАналитики.Типы()[0];
				НоваяСтрока.КодАналитики			= "Аналитика"+Индекс;
				НоваяСтрока.ТаблицаАналитики		= ?(НоваяСтрока.ТипДанныхАналитики = Тип("Строка"), "", Метаданные.НайтиПоТипу(НоваяСтрока.ТипДанныхАналитики).ПолноеИмя());				
				НоваяСтрока.ИерархияГруппИЭлементов	= ИерархияГруппИЭлементов(НоваяСтрока.ТаблицаАналитики);
				
				Инд=Инд+1;
				
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		Если ТипЗнч(ОбъектАналитики)=Тип("СправочникСсылка.ГруппыРаскрытия") Тогда
			
			ВидАналитики = ОбъектАналитики["ВидАналитикиВалютаДт"];
			
			Если Не ПустаяСтрока(ВидАналитики) Тогда
				
				НоваяСтрока=ТаблицаАналитик.Добавить();
				НоваяСтрока.НаименованиеАналитики	= Строка(ВидАналитики);
				НоваяСтрока.ВидАналитики			= ВидАналитики;
				НоваяСтрока.ПредставлениеАналитики	= Нстр("ru = 'Валюта (раскрытие)'");
				НоваяСтрока.ТипЗначенияАналитики	= ВидАналитики.ТипЗначения;
				НоваяСтрока.ТипДанныхАналитики		= НоваяСтрока.ТипЗначенияАналитики.Типы()[0];
				НоваяСтрока.КодАналитики			= "АналитикаВалюта";
				НоваяСтрока.ТаблицаАналитики		= ?(НоваяСтрока.ТипДанныхАналитики = Тип("Строка"), "", Метаданные.НайтиПоТипу(НоваяСтрока.ТипДанныхАналитики).ПолноеИмя());
				НоваяСтрока.ИерархияГруппИЭлементов	= ИерархияГруппИЭлементов(НоваяСтрока.ТаблицаАналитики);
				
			КонецЕсли;
			
		КонецЕсли;	
		
		Для Инд = 1 По ПараметрыСеанса.ЧислоДопАналитик Цикл
			
			Если НеВключатьАналитикуВГО И АналитикаВГО = Инд Тогда
				Продолжить;
			КонецЕсли;
			
			Если ОбъектАналитики.МетаДанные().Реквизиты.Найти("ВидАналитики" + Инд) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ВидАналитики = ОбъектАналитики["ВидАналитики"+Инд];
			
			Если Не ПустаяСтрока(ВидАналитики) Тогда
				
				НоваяСтрока=ТаблицаАналитик.Добавить();
				НоваяСтрока.НаименованиеАналитики		= Строка(ВидАналитики);
				НоваяСтрока.ВидАналитики				= ВидАналитики;
				НоваяСтрока.ПредставлениеАналитики		= СтрШаблон(Нстр("ru = 'Аналитика%1: %2'"), 
				                                  		  	Инд, Строка(ВидАналитики));
				НоваяСтрока.ТипЗначенияАналитики		= ВидАналитики.ТипЗначения;
				НоваяСтрока.ТипДанныхАналитики			= НоваяСтрока.ТипЗначенияАналитики.Типы()[0];
				НоваяСтрока.КодАналитики				= "Аналитика"+Инд;
				НоваяСтрока.ТаблицаАналитики			= ?(НоваяСтрока.ТипДанныхАналитики = Тип("Строка"), "", Метаданные.НайтиПоТипу(НоваяСтрока.ТипДанныхАналитики).ПолноеИмя());
				НоваяСтрока.ИерархияГруппИЭлементов		= ИерархияГруппИЭлементов(НоваяСтрока.ТаблицаАналитики);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если ДобавлятьПоказатели Тогда
		
		Если ПоказательОтбор=Неопределено Тогда
			
			Запрос=Новый Запрос;
			Запрос.Текст="ВЫБРАТЬ
			|	ПоказателиОтчетов.Код,
			|	ПоказателиОтчетов.Наименование,
			|	ПоказателиОтчетов.ТипЗначения
			|ИЗ
			|	Справочник.ПоказателиОтчетов КАК ПоказателиОтчетов
			|ГДЕ
			|	ПоказателиОтчетов.ГруппаРаскрытия = &ГруппаРаскрытия";
			
			Запрос.УстановитьПараметр("ГруппаРаскрытия",ОбъектАналитики);
			
		Иначе
			
			Запрос=Новый Запрос;
			Запрос.Текст="ВЫБРАТЬ
			|	ПоказателиОтчетов.Код,
			|	ПоказателиОтчетов.Наименование,
			|	ПоказателиОтчетов.ТипЗначения
			|ИЗ
			|	Справочник.ПоказателиОтчетов КАК ПоказателиОтчетов
			|ГДЕ
			|	ПоказателиОтчетов.Ссылка = &Ссылка";
			
			Запрос.УстановитьПараметр("Ссылка",ПоказательОтбор);
			
		КонецЕсли;	
		
		Результат=Запрос.Выполнить().Выбрать();
		
		Пока Результат.Следующий() Цикл
			
			НоваяСтрока=ТаблицаАналитик.Добавить();
			НоваяСтрока.НаименованиеАналитики		= Результат.Наименование;
			НоваяСтрока.ПредставлениеАналитики		= СтрШаблон(Нстр("ru = 'Показатель : %1'"), Результат.Наименование);
			НоваяСтрока.ТипЗначенияАналитики		= ПолучитьОписаниеТипаПоТипуПоказателя(Результат.ТипЗначения);
			НоваяСтрока.ТипДанныхАналитики			= НоваяСтрока.ТипЗначенияАналитики.Типы()[0];
			НоваяСтрока.КодАналитики				= СокрЛП(Результат.Код);
			НоваяСтрока.ТаблицаАналитики			= "Простой";
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТаблицаАналитик;
	
КонецФункции // ЗаполнитьВидыАналитик()

Функция ИерархияГруппИЭлементов(ТаблицаАналитики) Экспорт
	
	Если СтрНайти(ТаблицаАналитики,"Справочник.")>0 Тогда
		
		ОбъектМетаданных= МетаДанные.Справочники[СтрЗаменить(ТаблицаАналитики,"Справочник.","")];
		
		Возврат ОбъектМетаданных.Иерархический И ОбъектМетаданных.ВидИерархии=Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов
		
	ИначеЕсли СтрНайти(ТаблицаАналитики,"ПланВидовХарактеристик.")>0 Тогда
		
		ОбъектМетаданных= МетаДанные.ПланыВидовХарактеристик[СтрЗаменить(ТаблицаАналитики,"ПланВидовХарактеристик.","")];
		
		Возврат ОбъектМетаданных.Иерархический;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
			
КонецФункции // ИерархияГруппИЭлементов()

Функция ПолучитьНаименованиеСсылочногоТипаБД(База, Тип) Экспорт
	
	Возврат РаботаСОбъектамиМетаданныхВнешнийУХ.ПолучитьНаименованиеСсылочногоТипаБД(База, Тип);
		
КонецФункции


// Функция заполняет список значений аналитик переданного объекта (вида отчета или группы раскрытия показателя).
// Параметры:
//	ОбъектАналитики - объект, виды аналитики которого анализируются.
//  ТаблицаАналитик- Таблица значений, список, в который помещаются наименования
//	 аналитик показателя.
//
Функция ЗаполнитьВидыАналитикпоТЧ(ОбъектАналитики) Экспорт
	
	ТаблицаАналитик=Новый ТаблицаЗначений;
	ТаблицаАналитик.Колонки.Добавить("КодАналитики");
	ТаблицаАналитик.Колонки.Добавить("НаименованиеАналитики");
	ТаблицаАналитик.Колонки.Добавить("ВидАналитики");
	ТаблицаАналитик.Колонки.Добавить("ТипЗначенияАналитики");
	ТаблицаАналитик.Колонки.Добавить("ТипДанныхАналитики");
	ТаблицаАналитик.Колонки.Добавить("ПредставлениеАналитики");
	ТаблицаАналитик.Колонки.Добавить("ТаблицаАналитики");
	
	Если ОбъектАналитики=Неопределено Тогда
		
		Возврат ТаблицаАналитик;
		
	КонецЕсли;
	
	Для Каждого СтрАналитика ИЗ ОбъектАналитики.Аналитики Цикл
		
		Если Не ПустаяСтрока(СтрАналитика.ВидАналитики) Тогда
			
			НоваяСтрока=ТаблицаАналитик.Добавить();
			НоваяСтрока.НаименованиеАналитики	= СтрАналитика.Имя;
			НоваяСтрока.ВидАналитики			= СтрАналитика.ВидАналитики;
			НоваяСтрока.ПредставлениеАналитики	= СтрАналитика.Имя;
			НоваяСтрока.ТипЗначенияАналитики	= СтрАналитика.ВидАналитики.ТипЗначения;
			НоваяСтрока.ТипДанныхАналитики		= НоваяСтрока.ТипЗначенияАналитики.Типы()[0];
			НоваяСтрока.КодАналитики			= СтрАналитика.Имя;
			НоваяСтрока.ТаблицаАналитики		= ?(НоваяСтрока.ТипДанныхАналитики = Тип("Строка"), "", Метаданные.НайтиПоТипу(НоваяСтрока.ТипДанныхАналитики).ПолноеИмя());
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого СтрАналитика ИЗ ОбъектАналитики.Ресурсы Цикл
			
		НоваяСтрока=ТаблицаАналитик.Добавить();
		НоваяСтрока.НаименованиеАналитики		= СтрАналитика.Имя;
		НоваяСтрока.ПредставлениеАналитики		= СтрАналитика.Имя;
		НоваяСтрока.ТипЗначенияАналитики		= ПолучитьОписаниеТипаПоТипуПоказателя(СтрАналитика.ТипЗначения);
		НоваяСтрока.ТипДанныхАналитики			= НоваяСтрока.ТипЗначенияАналитики.Типы()[0];
		НоваяСтрока.КодАналитики				= СтрАналитика.Имя;
		НоваяСтрока.ТаблицаАналитики			= "Простой";
		
	КонецЦикла;
		
	Возврат ТаблицаАналитик;
	
КонецФункции // ЗаполнитьВидыАналитик()

Функция ПолучитьТекстАналитикОбъекта(ОбъектАналитики,Разделитель=Неопределено) Экспорт
	
	Если Разделитель=Неопределено Тогда
		Разделитель="; ";
	КонецЕсли;
	
	ТаблицаАналитик=ЗаполнитьВидыАналитик(ОбъектАналитики);
	
	ТекстАналитики="";
	
	Для Каждого СтрАналитика ИЗ ТаблицаАналитик Цикл
		ТекстАналитики=ТекстАналитики+Разделитель+СтрАналитика.НаименованиеАналитики;
	КонецЦикла;
	
	Возврат Сред(ТекстАналитики,СтрДлина(Разделитель+1));
	
КонецФункции // ПолучитьТекстАналитикОбъекта 

Функция МаксКоличествоАналитикПоказателей(ВидОтчета) Экспорт
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	МАКСИМУМ(ПоказателиОтчетов.ГруппаРаскрытия.ЧислоАналитик) КАК КоличествоАналитик
	|ИЗ
	|	Справочник.ПоказателиОтчетов КАК ПоказателиОтчетов
	|ГДЕ
	|	ПоказателиОтчетов.Владелец = &ВидОтчета
	|	И (НЕ ПоказателиОтчетов.ПометкаУдаления)
	|	И (НЕ ПоказателиОтчетов.ГруппаРаскрытия = ЗНАЧЕНИЕ(Справочник.ГруппыРаскрытия.ПустаяСсылка))";
	
	Запрос.УстановитьПараметр("ВидОтчета",ВидОтчета);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Если Результат.Следующий() Тогда
		
		ЕСЛИ Результат.КоличествоАналитик = NULL Тогда
			
			Возврат 0
			
		Иначе
			
			Возврат Результат.КоличествоАналитик;
			
		КонецЕсли;
		
	Иначе
		
		Возврат 0;
		
	КонецЕсли;
	
КонецФункции

Процедура ЗаполнитьОбщиеРеквизитыАналитики(ТекВидАналитики,СтруктураАналитика)
	
	МассивРеквизитов=Новый Массив;
	МассивРеквизитов.Добавить("Наименование");
	МассивРеквизитов.Добавить("Наименование1");
	МассивРеквизитов.Добавить("Наименование2");
	МассивРеквизитов.Добавить("ТипЗначения");
	МассивРеквизитов.Добавить("РазделятьПоОрганизациям");
	
	ДанныеРеквизитов=ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ТекВидАналитики,МассивРеквизитов);
	
	Для Каждого КлючИЗначения ИЗ ДанныеРеквизитов Цикл
		
		СтруктураАналитика.Вставить(КлючИЗначения.Ключ,КлючИЗначения.Значение);
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьОбщиеРеквизитыАналитики()

Функция ПолучитьДанныеГруппыРаскрытия(Показатель=Неопределено,ГруппаРаскрытия=Неопределено) Экспорт
	
	ДанныеГруппыРаскрытия=Новый Структура;
	
	РабочаяГруппаРаскрытия=Неопределено;
	
	Если ЗначениеЗаполнено(ГруппаРаскрытия) Тогда
		РабочаяГруппаРаскрытия=ГруппаРаскрытия;
	ИначеЕсли ЗначениеЗаполнено(Показатель) И ЗначениеЗаполнено(Показатель.ГруппаРаскрытия) Тогда
		РабочаяГруппаРаскрытия=Показатель.ГруппаРаскрытия;
	КонецЕсли;
	
	Если РабочаяГруппаРаскрытия=Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	ЕстьСвязьПоВладельцу=Ложь;
	
	ДанныеГруппыРаскрытия.Вставить("Валютная",РабочаяГруппаРаскрытия.Валютная);
	МаксАналитик=?(ПараметрыСеанса.ЧислоДопАналитик<6,6,ПараметрыСеанса.ЧислоДопАналитик);
	
	Для Инд=1 По МаксАналитик Цикл
		
		СтруктураАналитика=Новый Структура;
		ТекВидАналитики=РабочаяГруппаРаскрытия["ВидАналитики"+Инд];
		СтруктураАналитика.Вставить("ВидАналитики",ТекВидАналитики);
		
		Если ЗначениеЗаполнено(ТекВидАналитики) Тогда
			
			ЗаполнитьОбщиеРеквизитыАналитики(ТекВидАналитики,СтруктураАналитика);
			СтруктураАналитика.Вставить("Тип",СтруктураАналитика.ТипЗначения.Типы()[0]);
			
			//////////////////////////////////////////////////////////////////////////
			// Определим возможных владельцев для отбора.
			
			ОбъектМетаДанных=Метаданные.НайтиПоТипу(СтруктураАналитика.Тип);
			
			Если НЕ ОбъектМетаДанных=Неопределено Тогда
				
				ТаблицаАналитики=ОбъектМетаДанных.ПолноеИмя();
				СтруктураАналитика.Вставить("ТаблицаАналитики",ТаблицаАналитики);
				
				Если СтрНайти(ТаблицаАналитики,"Справочник.")>0 И ОбъектМетаДанных.Владельцы.Количество()>0 Тогда
					
					СписокТипов=Новый СписокЗначений;
					
					Для Каждого ТекВладелец ИЗ ОбъектМетаДанных.Владельцы Цикл
						
						Если СтрНайти(ТекВладелец.ПолноеИмя(),"Справочник.")=0 Тогда
							Продолжить;
						КонецЕсли;
						
						СписокТипов.Добавить(Тип("СправочникСсылка."+ТекВладелец.Имя));
						
					КонецЦикла;
					
					СтруктураАналитика.Вставить("ТипыВладельцев",СписокТипов);
					ЕстьСвязьПоВладельцу=Истина;
					
				КонецЕсли;
				
			КонецЕсли;	
			
		КонецЕсли;
		
		ДанныеГруппыРаскрытия.Вставить("ВидАналитики"+Инд,СтруктураАналитика);
		
	КонецЦикла;
	
	СтруктураАналитика=Новый Структура;
	ТекВидАналитики=РабочаяГруппаРаскрытия["ВидАналитикиВалютаДт"];
	СтруктураАналитика.Вставить("ВидАналитики",ТекВидАналитики);
	
	Если ЗначениеЗаполнено(ТекВидАналитики) Тогда
		
		ЗаполнитьОбщиеРеквизитыАналитики(ТекВидАналитики,СтруктураАналитика);
		СтруктураАналитика.Вставить("Тип",СтруктураАналитика.ТипЗначения.Типы()[0]);
		
		//////////////////////////////////////////////////////////////////////////
		// Определим возможных владельцев для отбора.
		
		ОбъектМетаДанных=Метаданные.НайтиПоТипу(СтруктураАналитика.Тип);
		
		Если НЕ ОбъектМетаДанных=Неопределено Тогда
			
			ТаблицаАналитики=ОбъектМетаДанных.ПолноеИмя();
			СтруктураАналитика.Вставить("ТаблицаАналитики",ТаблицаАналитики);
			
			Если СтрНайти(ТаблицаАналитики,"Справочник.")>0 И ОбъектМетаДанных.Владельцы.Количество()>0 Тогда
				
				СписокТипов=Новый СписокЗначений;
				
				Для Каждого ТекВладелец ИЗ ОбъектМетаДанных.Владельцы Цикл
					
					Если СтрНайти(ТекВладелец.ПолноеИмя(),"Справочник.")=0 Тогда
						Продолжить;
					КонецЕсли;
					
					СписокТипов.Добавить(Тип("СправочникСсылка."+ТекВладелец.Имя));
					
				КонецЦикла;
				
				СтруктураАналитика.Вставить("ТипыВладельцев",СписокТипов);
				ЕстьСвязьПоВладельцу=Истина;
				
			КонецЕсли;
			
		КонецЕсли;	
		
	КонецЕсли;
	
	ДанныеГруппыРаскрытия.Вставить("ВидАналитикиВалютаДт",СтруктураАналитика);
	
	СтруктураАналитика=Новый Структура;
	ТекВидАналитики=РабочаяГруппаРаскрытия["ВидАналитикиВалютаКт"];
	СтруктураАналитика.Вставить("ВидАналитики",ТекВидАналитики);
	
	Если ЗначениеЗаполнено(ТекВидАналитики) Тогда
		
		ЗаполнитьОбщиеРеквизитыАналитики(ТекВидАналитики,СтруктураАналитика);
		СтруктураАналитика.Вставить("Тип",СтруктураАналитика.ТипЗначения.Типы()[0]);
		
		//////////////////////////////////////////////////////////////////////////
		// Определим возможных владельцев для отбора.
		
		ОбъектМетаДанных=Метаданные.НайтиПоТипу(СтруктураАналитика.Тип);
		
		Если НЕ ОбъектМетаДанных=Неопределено Тогда
			
			ТаблицаАналитики=ОбъектМетаДанных.ПолноеИмя();
			СтруктураАналитика.Вставить("ТаблицаАналитики",ТаблицаАналитики);
			
			Если СтрНайти(ТаблицаАналитики,"Справочник.")>0 И ОбъектМетаДанных.Владельцы.Количество()>0 Тогда
				
				СписокТипов=Новый СписокЗначений;
				
				Для Каждого ТекВладелец ИЗ ОбъектМетаДанных.Владельцы Цикл
					
					Если СтрНайти(ТекВладелец.ПолноеИмя(),"Справочник.")=0 Тогда
						Продолжить;
					КонецЕсли;
					
					СписокТипов.Добавить(Тип("СправочникСсылка."+ТекВладелец.Имя));
					
				КонецЦикла;
				
				СтруктураАналитика.Вставить("ТипыВладельцев",СписокТипов);
				ЕстьСвязьПоВладельцу=Истина;
				
			КонецЕсли;
			
		КонецЕсли;	
		
	КонецЕсли;
	
	ДанныеГруппыРаскрытия.Вставить("ВидАналитикиВалютаКт",СтруктураАналитика);
	
	Если ЕстьСвязьПоВладельцу Тогда // Определим аналитику для отбора по владельцу
		
		Для Инд=1 ПО 6 Цикл
			
			ТекСтруктураАналитики=ДанныеГруппыРаскрытия["ВидАналитики"+Инд];
			
			Если ТекСтруктураАналитики.Свойство("ТипыВладельцев") Тогда
				
				СписокТипов=ТекСтруктураАналитики.ТипыВладельцев;
				
				Для ВнИнд=1 ПО 6 Цикл
					
					СтруктураВладелец=ДанныеГруппыРаскрытия["ВидАналитики"+ВнИнд];
					
					Если СтруктураВладелец.Свойство("Тип") И (НЕ СписокТипов.НайтиПоЗначению(СтруктураВладелец.Тип)=Неопределено) Тогда
						
						ТекСтруктураАналитики.Вставить("Владелец","Аналитика"+ВнИнд);
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;		
		
	КонецЕсли;
	
	Возврат ДанныеГруппыРаскрытия;
	
КонецФункции // ПолучитьДанныеГруппыРаскрытия()

Функция ПолучитьДанныеАналитикВидаОтчета(ВидОтчета) Экспорт
	
	ДанныеГруппыРаскрытия=Новый Структура;
		
	Для Инд=1 По ПараметрыСеанса.ЧислоДопАналитик Цикл
		
		СтруктураАналитика=Новый Структура;
		ТекВидАналитики=ВидОтчета["ВидАналитики"+Инд];
		СтруктураАналитика.Вставить("ВидАналитики",ТекВидАналитики);
		
		Если ЗначениеЗаполнено(ТекВидАналитики) Тогда
			
			СтруктураАналитика.Вставить("Наименование",ТекВидАналитики.Наименование);
			СтруктураАналитика.Вставить("ТипЗначения",ТекВидАналитики.ТипЗначения);
			СтруктураАналитика.Вставить("Тип",СтруктураАналитика.ТипЗначения.Типы()[0]);
			
			//////////////////////////////////////////////////////////////////////////
			// Определим возможных владельцев для отбора.
			
			ОбъектМетаДанных=Метаданные.НайтиПоТипу(СтруктураАналитика.Тип);
			
			Если НЕ ОбъектМетаДанных=Неопределено Тогда
				
				ТаблицаАналитики=ОбъектМетаДанных.ПолноеИмя();
				СтруктураАналитика.Вставить("ТаблицаАналитики",ТаблицаАналитики);
				
				Если СтрНайти(ТаблицаАналитики,"Справочник.")>0 И ОбъектМетаДанных.Владельцы.Количество()>0 Тогда
					
					СписокТипов=Новый СписокЗначений;
					
					Для Каждого ТекВладелец ИЗ ОбъектМетаДанных.Владельцы Цикл
						
						Если СтрНайти(ТекВладелец.ПолноеИмя(),"Справочник.")=0 Тогда
							Продолжить;
						КонецЕсли;
						
						СписокТипов.Добавить(Тип("СправочникСсылка."+ТекВладелец.Имя));
						
					КонецЦикла;
					
					СтруктураАналитика.Вставить("ТипыВладельцев",СписокТипов);
					ЕстьСвязьПоВладельцу=Истина;
					
				КонецЕсли;
				
			КонецЕсли;	
			
			СтруктураАналитика.Вставить("РазделятьПоОрганизациям",ТекВидАналитики.РазделятьПоОрганизациям);
			
		КонецЕсли;
		
		ДанныеГруппыРаскрытия.Вставить("ВидАналитики"+Инд,СтруктураАналитика);
		
	КонецЦикла;
		
	Возврат ДанныеГруппыРаскрытия;
	
КонецФункции // ПолучитьДанныеГруппыРаскрытия()

Функция ПолучитьДанныеГруппыРаскрытияТЧ(Объект=Неопределено,ГруппаРаскрытия=Неопределено) Экспорт
	
	ДанныеГруппыРаскрытия=Новый Структура;
	
	РабочаяГруппаРаскрытия=Неопределено;
	
	Если ЗначениеЗаполнено(ГруппаРаскрытия) Тогда
		РабочаяГруппаРаскрытия=ГруппаРаскрытия;
	ИначеЕсли ЗначениеЗаполнено(Объект) И ЗначениеЗаполнено(Объект.ГруппаРаскрытия) Тогда
		РабочаяГруппаРаскрытия=Объект.ГруппаРаскрытия;
	КонецЕсли;
	
	Если РабочаяГруппаРаскрытия=Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	ЕстьСвязьПоВладельцу=Ложь;
	
	Для Каждого СтрАналитика ИЗ ГруппаРаскрытия.Аналитики Цикл
		
		СтруктураАналитика=Новый Структура;
		ТекВидАналитики=СтрАналитика.ВидАналитики;
		СтруктураАналитика.Вставить("ВидАналитики",ТекВидАналитики);
		
		Если ЗначениеЗаполнено(ТекВидАналитики) Тогда
			
			СтруктураАналитика.Вставить("Наименование",ТекВидАналитики.Наименование);
			СтруктураАналитика.Вставить("ТипЗначения",ТекВидАналитики.ТипЗначения);
			СтруктураАналитика.Вставить("Тип",СтруктураАналитика.ТипЗначения.Типы()[0]);
			
			//////////////////////////////////////////////////////////////////////////
			// Определим возможных владельцев для отбора.
			
			ОбъектМетаДанных=Метаданные.НайтиПоТипу(СтруктураАналитика.Тип);
			
			Если НЕ ОбъектМетаДанных=Неопределено Тогда
				
				ТаблицаАналитики=ОбъектМетаДанных.ПолноеИмя();
				СтруктураАналитика.Вставить("ТаблицаАналитики",ТаблицаАналитики);
				
				Если СтрНайти(ТаблицаАналитики,"Справочник.")>0 И ОбъектМетаДанных.Владельцы.Количество()>0 Тогда
					
					СписокТипов=Новый СписокЗначений;
					
					Для Каждого ТекВладелец ИЗ ОбъектМетаДанных.Владельцы Цикл
						
						Если СтрНайти(ТекВладелец.ПолноеИмя(),"Справочник.")=0 Тогда
							Продолжить;
						КонецЕсли;
						
						СписокТипов.Добавить(Тип("СправочникСсылка."+ТекВладелец.Имя));
						
					КонецЦикла;
					
					СтруктураАналитика.Вставить("ТипыВладельцев",СписокТипов);
					ЕстьСвязьПоВладельцу=Истина;
					
				КонецЕсли;
				
			КонецЕсли;	
			
			Если ЕстьРеквизитОбъекта("РазделятьПоОрганизациям",ТекВидАналитики) Тогда
				
				СтруктураАналитика.Вставить("РазделятьПоОрганизациям",ТекВидАналитики.РазделятьПоОрганизациям);
				
			Иначе
				
				СтруктураАналитика.Вставить("РазделятьПоОрганизациям",Ложь);
				
			КонецЕсли;
			
		КонецЕсли;
		
		ДанныеГруппыРаскрытия.Вставить(СтрАналитика.Имя,СтруктураАналитика);
		
	КонецЦикла;
		
	Если ЕстьСвязьПоВладельцу Тогда // Определим аналитику для отбора по владельцу
		
		Для Каждого СтрАналитика ИЗ ГруппаРаскрытия.Аналитики Цикл
			
			ТекСтруктураАналитики=ДанныеГруппыРаскрытия[СтрАналитика.Имя];
			
			Если ТекСтруктураАналитики.Свойство("ТипыВладельцев") Тогда
				
				СписокТипов=ТекСтруктураАналитики.ТипыВладельцев;
				
				Для Индекс=0 ПО ГруппаРаскрытия.Аналитики.Количество()-1 Цикл
					
					ТекДанныеАналитики=ГруппаРаскрытия.Аналитики[Индекс];
					
					СтруктураВладелец=ДанныеГруппыРаскрытия[ТекДанныеАналитики.Имя];
					
					Если СтруктураВладелец.Свойство("Тип") И (НЕ СписокТипов.НайтиПоЗначению(СтруктураВладелец.Тип)=Неопределено) Тогда
						
						ТекСтруктураАналитики.Вставить("Владелец",ТекДанныеАналитики.Имя);
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;		
		
	КонецЕсли;
	
	Возврат ДанныеГруппыРаскрытия;
	
КонецФункции // ПолучитьДанныеГруппыРаскрытия()

Функция ВернутьКоличествоАналитикНаУровнеОтчета(ВидОтчета) Экспорт
	
	Для Инд = 1 По ПараметрыСеанса.ЧислоДопАналитик Цикл
		
		Если НЕ ЗначениеЗаполнено(ВидОтчета["ВидАналитики" + Инд]) Тогда
			Возврат Инд - 1;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Инд - 1;
	
КонецФункции

Функция ЕстьРеквизитСправочника(ТаблицаСправочника,ИмяРеквизита) Экспорт

	Если ТипЗнч(ТаблицаСправочника)=Тип("Строка") Тогда
		
		МетаданныеОбъекта=Метаданные.Справочники[ТаблицаСправочника];
		
	ИначеЕсли ТипЗнч(ТаблицаСправочника)=Тип("ПланВидовХарактеристикСсылка.ВидыСубконтоКорпоративные") Тогда
		
		МетаданныеОбъекта=ПолучитьСправочникПоВидуСубконто(ТаблицаСправочника);
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
			
	Возврат ЕстьРеквизитОбъектаМД(ИмяРеквизита,МетаданныеОбъекта);
	
КонецФункции // ЕстьРеквизитСправочника()


// Процедура выдает список ЭО, по которым замена ссылок будет невозможна или дублирования
// строк в регистре сведений
// Параметры
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
Функция ПроверитьНаличиеВозможныхОшибокСДублямиАналитик(ТаблицаДокументовСОшибками, ПравильныйЭлемент, МассивДублей, ТаблицаСсылок)
	
	Таблица = ТаблицаДокументовСОшибками.Выгрузить();
	Таблица.Очистить();
	
	Для каждого Стр Из ТаблицаСсылок Цикл
		
		Если Метаданные.РегистрыСведений.Содержит(Стр.Метаданные) 
			И СтрНайти(Стр.Метаданные.Имя, "ЗначенияПоказателей") = 1  //обрабатываем только РС по показателям
			И НЕ Стр.Метаданные.Измерения.Найти("Аналитика1") = Неопределено //исключаем РС, которые не двигаются через ЭО
			Тогда
			
			Запрос = Новый Запрос();
			
			ТекстЗапроса = "ВЫБРАТЬ СУММА(1) как СчетчикЗаписей, Табл.Версия.Регистратор как Регистратор";
			Для каждого Измерение из Стр.Метаданные.Измерения Цикл
				Если СтрНайти(Измерение.Имя, "Аналитика") = 1 Тогда
					ТекстЗапроса = ТекстЗапроса + ", ВЫБОР Когда Табл." + Измерение.Имя + " В (&МассивДублей, &ПравильныйЭлемент) 
									|	ТОГДА &ПравильныйЭлемент ИНАЧЕ Табл." + Измерение.Имя + " КОНЕЦ КАК " + Измерение.Имя;
				Иначе
					ТекстЗапроса = ТекстЗапроса + ", Табл." + Измерение.Имя;   				
                КонецЕсли;
			КонецЦикла;
			
			ТекстЗапроса = ТекстЗапроса + " ИЗ РегистрСведений." + Стр.Метаданные.Имя 
						+ " КАК Табл ГДЕ Табл.Версия.Регистратор = &Регистратор И (";
			
			Для каждого Измерение из Стр.Метаданные.Измерения Цикл   
				Если СтрНайти(Измерение.Имя, "Аналитика") = 1 Тогда
					ТекстЗапроса = ТекстЗапроса + " Табл." + Измерение.Имя + " В (&МассивДублей, &ПравильныйЭлемент) ИЛИ";
				КонецЕсли;
			КонецЦикла;
			
			ТекстЗапроса = ТекстЗапроса + " ЛОЖЬ) СГРУППИРОВАТЬ ПО Табл.Версия.Регистратор";
			
			Для каждого Измерение из Стр.Метаданные.Измерения Цикл  
				Если СтрНайти(Измерение.Имя, "Аналитика") = 1 Тогда
					ТекстЗапроса = ТекстЗапроса + ", ВЫБОР Когда Табл." + Измерение.Имя + " В (&МассивДублей, &ПравильныйЭлемент) 
									|	ТОГДА &ПравильныйЭлемент ИНАЧЕ Табл." + Измерение.Имя + " КОНЕЦ ";
				Иначе
					ТекстЗапроса = ТекстЗапроса + ", Табл." + Измерение.Имя;  				
                КонецЕсли;
			КонецЦикла;
			
			ТекстЗапроса = ТекстЗапроса + " ИМЕЮЩИЕ СУММА(1) > 1";
				
			Запрос.УстановитьПараметр("Регистратор", 		Стр.Данные.Версия.Регистратор);
			Запрос.УстановитьПараметр("ПравильныйЭлемент", 	ПравильныйЭлемент);
			Запрос.УстановитьПараметр("МассивДублей", 		МассивДублей);
			
			Запрос.Текст = ТекстЗапроса;
				
			Если НЕ Запрос.Выполнить().Пустой() Тогда
				НовСтрока = Таблица.Добавить();
				НовСтрока.ИмяРегистра = Стр.Метаданные.Имя;
				НовСтрока.Документ = Стр.Данные.Версия.Регистратор;
			КонецЕсли;	
			
		КонецЕсли;
		
	КонецЦикла;
	
	Таблица.Свернуть("Документ,ИмяРегистра");
	
	ТаблицаДокументовСОшибками.Загрузить(Таблица);
	
	Возврат ТаблицаДокументовСОшибками.Количество() > 0;

КонецФункции // ПроверитьНаличиеВозможныхОшибокСДублямиАналитик()

Функция ВыполнитьЗаменуЭлементов(ПравильныйЭлемент, МассивДублей, УдалятьДубли=Истина, ТаблицаДокументовСОшибками = Неопределено) Экспорт
	
	ТаблицаСсылок=НайтиПоСсылкам(МассивДублей);
	
	Если НЕ ТаблицаДокументовСОшибками = Неопределено Тогда
	
		Если ПроверитьНаличиеВозможныхОшибокСДублямиАналитик(ТаблицаДокументовСОшибками, ПравильныйЭлемент, МассивДублей, ТаблицаСсылок) Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
	НачатьТранзакцию();
	
	БылиИсключения = Ложь;
	
	ОбрабатываемаяСсылка = Неопределено;
		
	ПараметрыОбъектов = Новый Структура;
	
	Для Каждого РегистрБухгалтерии ИЗ Метаданные.РегистрыБухгалтерии Цикл
		ПараметрыОбъектов.Вставить(РегистрБухгалтерии.Имя+"Субконто", РегистрБухгалтерии.ПланСчетов.МаксКоличествоСубконто);
		ПараметрыОбъектов.Вставить(РегистрБухгалтерии.Имя+"Корреспонденция", РегистрБухгалтерии.Корреспонденция);		
	КонецЦикла;
	
	ПараметрыОбъектов.Вставить("Объект", Неопределено);	
		
	Для Каждого СтрокаТаблицы Из ТаблицаСсылок Цикл
		
		Ссылка = СтрокаТаблицы.Ссылка;
		
		Если ОбрабатываемаяСсылка <> СтрокаТаблицы.Данные Тогда
			
			Если ОбрабатываемаяСсылка <> Неопределено и ПараметрыОбъектов.Объект <> Неопределено Тогда
				
				ПараметрыОбъектов.Объект.ОбменДанными.Загрузка = Истина;
	
				Попытка
					ПараметрыОбъектов.Объект.Записать();
				Исключение
					ОбщегоНазначенияУХ.СообщитьОбОшибке(ОписаниеОшибки(),,,СтатусСообщения.Внимание);
					ОтменитьТранзакцию();
					Возврат Ложь;
				КонецПопытки;
				
				ПараметрыОбъектов.Объект = Неопределено;
				
			КонецЕсли;
			
			ОбрабатываемаяСсылка = СтрокаТаблицы.Данные;
			
		КонецЕсли;
		
			
		Если Метаданные.Документы.Содержит(СтрокаТаблицы.Метаданные) Тогда
			
			Если ПараметрыОбъектов.Объект = Неопределено Тогда
				ПараметрыОбъектов.Объект = СтрокаТаблицы.Данные.ПолучитьОбъект();
			КонецЕсли;
			
			Для Каждого Реквизит Из СтрокаТаблицы.Метаданные.Реквизиты Цикл
				Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ПараметрыОбъектов.Объект[Реквизит.Имя] = Ссылка Тогда
					ПараметрыОбъектов.Объект[Реквизит.Имя] = ПравильныйЭлемент;
				КонецЕсли;
			КонецЦикла;
				
			Для Каждого ТЧ ИЗ СтрокаТаблицы.Метаданные.ТабличныеЧасти Цикл
				Для Каждого Реквизит Из ТЧ.Реквизиты Цикл
					Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
						СтрокаТабЧасти = ПараметрыОбъектов.Объект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
						Пока СтрокаТабЧасти <> Неопределено Цикл
							СтрокаТабЧасти[Реквизит.Имя] = ПравильныйЭлемент;
							СтрокаТабЧасти = ПараметрыОбъектов.Объект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
			
			Для Каждого Движение ИЗ СтрокаТаблицы.Метаданные.Движения Цикл
				
				ЭтоДвижениеРегистраБухгалтерии = Метаданные.РегистрыБухгалтерии.Содержит(Движение);
				ЕстьКорреспонденция = ЭтоДвижениеРегистраБухгалтерии и ПараметрыОбъектов[Движение.Имя + "Корреспонденция"];
				
				НаборЗаписей  = ПараметрыОбъектов.Объект.Движения[Движение.Имя];
				НаборЗаписей.Прочитать();
				НадоЗаписывать = Ложь;
				ТаблицаНабора = НаборЗаписей.Выгрузить();
				Для Каждого Измерение ИЗ Движение.Измерения Цикл
					
					Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
						
						Если ЭтоДвижениеРегистраБухгалтерии И (НЕ Измерение.Балансовый) Тогда
							
							СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Измерение.Имя+"Дт");
							Пока СтрокаТабЧасти <> Неопределено Цикл
								СтрокаТабЧасти[Измерение.Имя+"Дт"] = ПравильныйЭлемент;
								НадоЗаписывать = Истина;
								СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Измерение.Имя+"Дт");
							КонецЦикла;
							
							СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Измерение.Имя+"Кт");
							Пока СтрокаТабЧасти <> Неопределено Цикл
								СтрокаТабЧасти[Измерение.Имя+"Кт"] = ПравильныйЭлемент;
								НадоЗаписывать = Истина;
								СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Измерение.Имя+"Кт");
							КонецЦикла;
							
							
						Иначе
							
							СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Измерение.Имя);
							
							Пока СтрокаТабЧасти <> Неопределено Цикл
								СтрокаТабЧасти[Измерение.Имя] = ПравильныйЭлемент;
								НадоЗаписывать = Истина;
								СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Измерение.Имя);
							КонецЦикла;
							
						КонецЕсли;
						
					КонецЕсли; 
					
				КонецЦикла;
				
				ЕСли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
					Для Каждого Ресурс ИЗ Движение.Ресурсы Цикл
						Если Ресурс.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
							СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Ресурс.Имя);
							Пока СтрокаТабЧасти <> Неопределено Цикл
								СтрокаТабЧасти[Ресурс.Имя] = ПравильныйЭлемент;
								НадоЗаписывать = Истина;
								СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Ресурс.Имя);
							КонецЦикла;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Для Каждого Реквизит ИЗ Движение.Реквизиты Цикл
					Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
						СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Реквизит.Имя);
						Пока СтрокаТабЧасти <> Неопределено Цикл
							СтрокаТабЧасти[Реквизит.Имя] = ПравильныйЭлемент;
							НадоЗаписывать = Истина;
							СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, Реквизит.Имя);
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;
				
				Если Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
					
					Для ИндексСубконто = 1 по ПараметрыОбъектов[Движение.Имя + "Субконто"] Цикл
						Если ЕстьКорреспонденция Тогда
							СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "СубконтоДт"+ИндексСубконто);
							Пока СтрокаТабЧасти <> Неопределено Цикл
								СтрокаТабЧасти["СубконтоДт"+ИндексСубконто] = ПравильныйЭлемент;
								НадоЗаписывать = Истина;
								СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "СубконтоДт"+ИндексСубконто);
							КонецЦикла;
							СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "СубконтоКт"+ИндексСубконто);
							Пока СтрокаТабЧасти <> Неопределено Цикл
								СтрокаТабЧасти["СубконтоКт"+ИндексСубконто] = ПравильныйЭлемент;
								НадоЗаписывать = Истина;
								СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "СубконтоКт"+ИндексСубконто);
							КонецЦикла;
						Иначе
							СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "Субконто"+ИндексСубконто);
							Пока СтрокаТабЧасти <> Неопределено Цикл
								СтрокаТабЧасти["Субконто"+ИндексСубконто] = ПравильныйЭлемент;
								НадоЗаписывать = Истина;
								СтрокаТабЧасти = ТаблицаНабора.Найти(Ссылка, "Субконто"+ИндексСубконто);
							КонецЦикла;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;

				Если НадоЗаписывать Тогда
					НаборЗаписей.Загрузить(ТаблицаНабора);
					НаборЗаписей.ОбменДанными.Загрузка = Истина;
					Попытка
						НаборЗаписей.Записать();
					Исключение
						ОбщегоНазначенияУХ.СообщитьОбОшибке(ОписаниеОшибки(),,,СтатусСообщения.Внимание);
						ОтменитьТранзакцию();
						Возврат Ложь;
					КонецПопытки;
					
				КонецЕсли;
				
			КонецЦикла;
			
			Для Каждого Последовательность ИЗ Метаданные.Последовательности Цикл
				Если Последовательность.Документы.Содержит(СтрокаТаблицы.Метаданные) Тогда
					НадоЗаписывать = Ложь;
					НаборЗаписи = Последовательности[Последовательность.Имя].СоздатьНаборЗаписей();
					НаборЗаписи.Отбор.Регистратор.Установить(СтрокаТаблицы.Данные);
					НаборЗаписи.Прочитать();
					
					Если НаборЗаписи.Количество() > 0 Тогда
						Для Каждого Измерение ИЗ Последовательность.Измерения Цикл
							Если Измерение.Тип.СодержитТип(ТипЗнч(Ссылка)) И НаборЗаписи[0][Измерение.Имя]=Ссылка Тогда
								НаборЗаписи[0][Измерение.Имя] = ПравильныйЭлемент;
								НадоЗаписывать = Истина;
							КонецЕсли;
						КонецЦикла;					
						Если НадоЗаписывать Тогда
								НаборЗаписи.ОбменДанными.Загрузка = Истина;
									Попытка
								НаборЗаписи.Записать();
							Исключение
								ОбщегоНазначенияУХ.СообщитьОбОшибке(ОписаниеОшибки(),,,СтатусСообщения.Внимание);
								ОтменитьТранзакцию();
								Возврат Ложь;
							КонецПопытки;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;	
			
		ИначеЕсли Метаданные.Справочники.Содержит(СтрокаТаблицы.Метаданные) Тогда
			
			Если ПараметрыОбъектов.Объект = Неопределено Тогда
				ПараметрыОбъектов.Объект = СтрокаТаблицы.Данные.ПолучитьОбъект();
			КонецЕсли;
			
			Если СтрокаТаблицы.Метаданные.Владельцы.Содержит(Ссылка.Метаданные()) И ПараметрыОбъектов.Объект.Владелец = Ссылка Тогда
				ПараметрыОбъектов.Объект.Владелец = ПравильныйЭлемент;
			КонецЕсли;
			
			Если СтрокаТаблицы.Метаданные.Иерархический И ПараметрыОбъектов.Объект.Родитель = Ссылка Тогда
				ПараметрыОбъектов.Объект.Родитель = ПравильныйЭлемент;
			КонецЕсли;
			
			Для Каждого Реквизит Из СтрокаТаблицы.Метаданные.Реквизиты Цикл
				Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ПараметрыОбъектов.Объект[Реквизит.Имя] = Ссылка Тогда
					ПараметрыОбъектов.Объект[Реквизит.Имя] = ПравильныйЭлемент;
				КонецЕсли;
			КонецЦикла;
			
			Для Каждого Реквизит Из СтрокаТаблицы.Метаданные.СтандартныеРеквизиты Цикл
				
				Если Реквизит.Имя="Ссылка" Тогда
					Продолжить;
				КонецЕсли;
				
				Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ПараметрыОбъектов.Объект[Реквизит.Имя] = Ссылка Тогда
					ПараметрыОбъектов.Объект[Реквизит.Имя] = ПравильныйЭлемент;
				КонецЕсли;
			КонецЦикла;
				
			Для Каждого ТЧ ИЗ СтрокаТаблицы.Метаданные.ТабличныеЧасти Цикл
				Для Каждого Реквизит Из ТЧ.Реквизиты Цикл
					Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
						СтрокаТабЧасти = ПараметрыОбъектов.Объект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
						Пока СтрокаТабЧасти <> Неопределено Цикл
							СтрокаТабЧасти[Реквизит.Имя] = ПравильныйЭлемент;
							СтрокаТабЧасти = ПараметрыОбъектов.Объект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
			
		ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(СтрокаТаблицы.Метаданные)
				  ИЛИ Метаданные.ПланыСчетов.Содержит(СтрокаТаблицы.Метаданные)
				  ИЛИ Метаданные.ПланыВидовРасчета.Содержит(СтрокаТаблицы.Метаданные)
				  ИЛИ Метаданные.Задачи.Содержит(СтрокаТаблицы.Метаданные)
				  ИЛИ Метаданные.БизнесПроцессы.Содержит(СтрокаТаблицы.Метаданные) Тогда
			
			Если ПараметрыОбъектов.Объект = Неопределено Тогда
				ПараметрыОбъектов.Объект = СтрокаТаблицы.Данные.ПолучитьОбъект();
			КонецЕсли;
						
			Для Каждого Реквизит Из СтрокаТаблицы.Метаданные.Реквизиты Цикл
				Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ПараметрыОбъектов.Объект[Реквизит.Имя] = Ссылка Тогда
					ПараметрыОбъектов.Объект[Реквизит.Имя] = ПравильныйЭлемент;
				КонецЕсли;
			КонецЦикла;
			
			Для Каждого Реквизит Из СтрокаТаблицы.Метаданные.СтандартныеРеквизиты Цикл
				Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) И ПараметрыОбъектов.Объект[Реквизит.Имя] = Ссылка Тогда
					ПараметрыОбъектов.Объект[Реквизит.Имя] = ПравильныйЭлемент;
				КонецЕсли;
			КонецЦикла;

			Если  Метаданные.ПланыСчетов.Содержит(СтрокаТаблицы.Метаданные)
				ИЛИ Метаданные.ПланыВидовРасчета.Содержит(СтрокаТаблицы.Метаданные) Тогда
				
				Для Каждого ТЧ ИЗ СтрокаТаблицы.Метаданные.СтандартныеТабличныеЧасти Цикл
					Для Каждого Реквизит Из ТЧ.СтандартныеРеквизиты Цикл
						Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
							СтрокаТабЧасти = ПараметрыОбъектов.Объект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
							Пока СтрокаТабЧасти <> Неопределено Цикл
								СтрокаТабЧасти[Реквизит.Имя] = ПравильныйЭлемент;
								СтрокаТабЧасти = ПараметрыОбъектов.Объект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
							КонецЦикла;
						КонецЕсли;
					КонецЦикла;
				КонецЦикла;
				
			КонецЕсли;
						
			Для Каждого ТЧ ИЗ СтрокаТаблицы.Метаданные.ТабличныеЧасти Цикл
				Для Каждого Реквизит Из ТЧ.Реквизиты Цикл
					Если Реквизит.Тип.СодержитТип(ТипЗнч(Ссылка)) Тогда
						СтрокаТабЧасти = ПараметрыОбъектов.Объект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
						Пока СтрокаТабЧасти <> Неопределено Цикл
							СтрокаТабЧасти[Реквизит.Имя] = ПравильныйЭлемент;
							СтрокаТабЧасти = ПараметрыОбъектов.Объект[ТЧ.Имя].Найти(Ссылка, Реквизит.Имя);
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;	
			
		ИначеЕсли Метаданные.Константы.Содержит(СтрокаТаблицы.Метаданные) Тогда
			
			Константы[СтрокаТаблицы.Метаданные.Имя].Установить(ПравильныйЭлемент);
			
			
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(СтрокаТаблицы.Метаданные) Тогда	
			
			СтруктураИзмерений = Новый Структура;
			НаборЗаписей = РегистрыСведений[СтрокаТаблицы.Метаданные.Имя].СоздатьНаборЗаписей();
			Для Каждого Измерение ИЗ СтрокаТаблицы.Метаданные.Измерения Цикл
				НаборЗаписей.Отбор[Измерение.Имя].Установить(СтрокаТаблицы.Данные[Измерение.Имя]);
				СтруктураИзмерений.Вставить(Измерение.Имя);
			КонецЦикла;
			Если СтрокаТаблицы.Метаданные.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
				НаборЗаписей.Отбор["Период"].Установить(СтрокаТаблицы.Данные.Период);
			КонецЕсли;
			
			НаборЗаписей.Прочитать();
			Если НаборЗаписей.Количество() > 0 Тогда
				ТаблицаНабора = НаборЗаписей.Выгрузить();
				НаборЗаписей.Очистить();	
				НаборЗаписей.ОбменДанными.Загрузка = Истина;
							
				Попытка
					
					НаборЗаписей.Записать();
					
					Для Каждого Колонка ИЗ ТаблицаНабора.Колонки Цикл
						Если ТаблицаНабора[0][Колонка.Имя] = Ссылка Тогда
							ТаблицаНабора[0][Колонка.Имя] = ПравильныйЭлемент;
							Если СтруктураИзмерений.Свойство(Колонка.Имя) Тогда
								НаборЗаписей.Отбор[Колонка.Имя].Установить(ПравильныйЭлемент);
							КонецЕсли;
							
						КонецЕсли;
					КонецЦикла;
					
					НаборЗаписей.Загрузить(ТаблицаНабора);
					НаборЗаписей.Записать();
									
				Исключение
					
					ОбщегоНазначенияУХ.СообщитьОбОшибке(ОписаниеОшибки(),,,СтатусСообщения.Внимание);
					ОтменитьТранзакцию();
					Возврат Ложь;
								
				КонецПопытки;
			КонецЕсли;
		Иначе
			ТекстСообщения = НСтр("ru = 'Ссылки типа %Метаданные% не заменяются'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Метаданные%", Строка(СтрокаТаблицы.Метаданные));
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Внимание);
		КонецЕсли;
			
	КонецЦикла;
	
	Если ПараметрыОбъектов.Объект <> Неопределено Тогда
		ПараметрыОбъектов.Объект.ОбменДанными.Загрузка = Истина;
		Попытка
			ПараметрыОбъектов.Объект.Записать();
		Исключение
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ОписаниеОшибки(),,,СтатусСообщения.Внимание);
			ОтменитьТранзакцию();
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если УдалятьДубли Тогда
		
		Для Каждого Элемент ИЗ МассивДублей Цикл
			
			ОбъектДубль=Элемент.ПолучитьОбъект();
			ОбъектДубль.ПометкаУдаления=Истина;
			ОбъектДубль.ОбменДанными.Загрузка=Истина;
			
			Попытка
				
				ОбъектДубль.Записать();
				
			Исключение
				
				ТекстСообщения = НСтр("ru = 'Не удалось записать объект %ОбъектДубль%:
                                       |				%ОписаниеОшибки%'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОбъектДубль%", Строка(ОбъектДубль));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОписаниеОшибки%", ОписаниеОшибки());
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Внимание);
				
				ОтменитьТранзакцию();
				Возврат Ложь;
				
			КонецПопытки;
			
		КонецЦикла;	
		
	КонецЕсли;
	
	ЗафиксироватьТранзакцию();
	Возврат Истина;
	
КонецФункции
	
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРОЩЕННЫМ РЕЖИМОМ ВВОДА ФОРМУЛ

Процедура ОбновитьАдресаЭлементовСтруктуры(БланкОтчета) Экспорт
	
	СправочникОбъект=БланкОтчета.ПолучитьОбъект();
	ТаблДок=СправочникОбъект.Макет.Получить();
	
	Если ТипЗнч(ТаблДок)=Тип("ТабличныйДокумент") Тогда
		
		Попытка
			
			Справочники.БланкиОтчетов.СохранитьАдресаЭлементовСтруктуры(СправочникОбъект,ТаблДок);
			СправочникОбъект.ОбменДанными.Загрузка=Истина;
			СправочникОбъект.Записать();
			
		Исключение
			
			СообщитьОбОшибке(СтрШаблон(Нстр("ru = 'Не удалось обновить адреса элементов структуры вида отчета %1
			|:%2'"), 
			                 	СправочникОбъект.Владелец, ОписаниеОшибки()),,,СтатусСообщения.Внимание);
			
		КонецПопытки;
		
	КонецЕсли;
		
КонецПроцедуры // ОбновитьАдресаЭлементовСтруктуры() 

Функция ПолучитьАдресаЭлементовСтруктуры(ВидОтчета,ЭлементСтруктуры,Элемент=Неопределено) Экспорт
	
	БланкОтображенияПоУмолчанию=УправлениеОтчетамиУХ.НайтиПараметрОтчета(Перечисления.ЭлементыНастройкиОтчета.БланкДляОтображения,ВидОтчета);
	
	АдресаЭлементов=Новый Соответствие;
	
	Если НЕ ЗначениеЗаполнено(БланкОтображенияПоУмолчанию) Тогда
		
		Возврат АдресаЭлементов;
		
	КонецЕсли;
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ ПЕРВЫЕ 1
	|	БланкиОтчетовАдресаЭлементовСтруктурыОтчета.СтрокаНомер
	|ИЗ
	|	Справочник.БланкиОтчетов.АдресаЭлементовСтруктурыОтчета КАК БланкиОтчетовАдресаЭлементовСтруктурыОтчета
	|ГДЕ
	|	БланкиОтчетовАдресаЭлементовСтруктурыОтчета.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка",БланкОтображенияПоУмолчанию);
	Результат=Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		
		ОбновитьАдресаЭлементовСтруктуры(БланкОтображенияПоУмолчанию);
		
	КонецЕсли;		
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	БланкиОтчетовАдресаЭлементовСтруктурыОтчета.Элемент,
	|	БланкиОтчетовАдресаЭлементовСтруктурыОтчета.АдресС1К1
	|ИЗ
	|	Справочник.БланкиОтчетов.АдресаЭлементовСтруктурыОтчета КАК БланкиОтчетовАдресаЭлементовСтруктурыОтчета
	|ГДЕ
	|	БланкиОтчетовАдресаЭлементовСтруктурыОтчета.Ссылка = &Ссылка
	|	И БланкиОтчетовАдресаЭлементовСтруктурыОтчета.ТипЭлемента = &ТипЭлемента";
	
	Если Не Элемент=Неопределено Тогда
		
		Запрос.Текст=Запрос.Текст+"
		|И БланкиОтчетовАдресаЭлементовСтруктурыОтчета.Элемент=&Элемент";
		
		Запрос.УстановитьПараметр("Элемент",Элемент);
		
	КонецЕсли;
	
	Запрос.УстановитьПараметр("Ссылка",БланкОтображенияПоУмолчанию);
	Запрос.УстановитьПараметр("ТипЭлемента",ЭлементСтруктуры);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		АдресаЭлементов.Вставить(Результат.Элемент,Результат.АдресС1К1);
		
	КонецЦикла;
	
	Возврат АдресаЭлементов;
				 	
КонецФункции // ПолучитьАдресаЭлементовСтруктуры() 

Функция ПолучитьЭлементСтруктурыПоАдресу(ВидОтчета,ЭлементСтруктуры,АдресЭлемента) Экспорт
	
	БланкОтображенияПоУмолчанию=УправлениеОтчетамиУХ.НайтиПараметрОтчета(Перечисления.ЭлементыНастройкиОтчета.БланкДляОтображения,ВидОтчета);
	
	Если БланкОтображенияПоУмолчанию=Неопределено Тогда
		
		СообщитьОбОшибке(СтрШаблон(Нстр("ru = 'Не удалось определить бланк отображения, используемый по умолчанию для вида отчета %1'"), 
		                 	ВидОтчета),,,СтатусСообщения.Внимание);	
		Возврат Неопределено;
		
	КонецЕсли;
	
	Если БланкОтображенияПоУмолчанию.АдресаЭлементовСтруктурыОтчета.Количество()=0 Тогда
		
		ОбновитьАдресаЭлементовСтруктуры(БланкОтображенияПоУмолчанию);
		
	КонецЕсли;
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	БланкиОтчетовАдресаЭлементовСтруктурыОтчета.Элемент
	|ИЗ
	|	Справочник.БланкиОтчетов.АдресаЭлементовСтруктурыОтчета КАК БланкиОтчетовАдресаЭлементовСтруктурыОтчета
	|ГДЕ
	|	БланкиОтчетовАдресаЭлементовСтруктурыОтчета.Ссылка = &Ссылка
	|	И БланкиОтчетовАдресаЭлементовСтруктурыОтчета.ТипЭлемента = &ТипЭлемента
	|	И БланкиОтчетовАдресаЭлементовСтруктурыОтчета.АдресС1К1 = &АдресС1К1";
	
	Запрос.УстановитьПараметр("Ссылка"		,БланкОтображенияПоУмолчанию);
	Запрос.УстановитьПараметр("ТипЭлемента"	,ЭлементСтруктуры);
	Запрос.УстановитьПараметр("АдресС1К1"	,АдресЭлемента);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Если Результат.Следующий() Тогда
		
		Возврат Результат.Элемент;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
		
КонецФункции // ПолучитьЭлементСтруктурыПоАдресу() 

Функция ПолучитьТекстВидаИтогаДляФормулы(ВидИтога,ДтКт) Экспорт
	
	Если (ВидИтога="СН#" ИЛИ ВидИтога="НачальныйОстаток#") Тогда
		
		Если ДтКт="Дт" ИЛИ ДтКт="Д" Тогда
			
			Возврат "СНД";
			
		ИначеЕсли ДтКт="СВ" Тогда 
			
			Возврат "СНС";
			
		Иначе 
			
			Возврат "СНК";
			
		КонецЕсли;
			
	ИначеЕсли (ВидИтога="СК#" ИЛИ ВидИтога="КонечныйОстаток#") Тогда
		
		Если ДтКт="Дт" ИЛИ ДтКт="Д" Тогда
			
			Возврат "СКД";
			
		ИначеЕсли ДтКт="СВ" Тогда
			
			Возврат "СКС";
			
		Иначе
			
			Возврат "СКК";
			
		КонецЕсли;
		
	ИначеЕсли (ВидИтога="СН#РС" ИЛИ ВидИтога="НачальныйРазвернутыйОстаток#") Тогда
		
		Если ДтКт="Дт" ИЛИ ДтКт="Д" Тогда
			
			Возврат "СНДРС";
						
		Иначе
			
			Возврат "СНКРС";
			
		КонецЕсли;
		
	ИначеЕсли (ВидИтога="СК#РС" ИЛИ ВидИтога="КонечныйРазвернутыйОстаток#") Тогда
		
		Если ДтКт="Дт" ИЛИ ДтКт="Д" Тогда
			
			Возврат "СКДРС";
			
		Иначе
			
			Возврат "СККРС";
			
		КонецЕсли;
		
	ИначеЕсли (ВидИтога="#О" ИЛИ ВидИтога="Оборот#") Тогда
		
		Если ДтКт="Дт" ИЛИ ДтКт="Д" Тогда
			
			Возврат "ДО";
			
		ИначеЕсли ДтКт="СВ" Тогда
			
			Возврат "СО";
			
		Иначе
			
			Возврат "КО";
			
		КонецЕсли;
		
	ИначеЕсли (ВидИтога="КорДО" ИЛИ ВидИтога="Оборот") Тогда
		
		Возврат "ОБ";
		
	КонецЕсли;
			
КонецФункции // ПолучитьТекстВидаИтогаДляФормулы()

Функция ПолучитьВидИтогаДтКт(ТекстВидаИтога,Использование77=Ложь) Экспорт
	
	Если ТекстВидаИтога="СНД" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СН#","Д"),Новый Структура("ВидИтога,ДтКт","НачальныйОстаток#","Дт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.СНД);
		
	ИначеЕсли ТекстВидаИтога="СНК" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СН#","К"),Новый Структура("ВидИтога,ДтКт","НачальныйОстаток#","Кт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.СНК);
		
	ИначеЕсли ТекстВидаИтога="СНС" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СН#","СВ"),Новый Структура("ВидИтога,ДтКт","НачальныйОстаток#","СВ"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету");
		
	ИначеЕсли ТекстВидаИтога="СКД" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СК#","Д"),Новый Структура("ВидИтога,ДтКт","КонечныйОстаток#","Дт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.СКД);
		
	ИначеЕсли ТекстВидаИтога="СКК" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СК#","К"),Новый Структура("ВидИтога,ДтКт","КонечныйОстаток#","Кт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.СКК);
		
	ИначеЕсли ТекстВидаИтога="СКС" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СК#","СВ"),Новый Структура("ВидИтога,ДтКт","КонечныйОстаток#","СВ"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету");
		
	ИначеЕсли ТекстВидаИтога="СНДРС" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СН#РС","Д"),Новый Структура("ВидИтога,ДтКт","НачальныйРазвернутыйОстаток#","Дт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.СНД);
		
	ИначеЕсли ТекстВидаИтога="СНКРС" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СН#РС","К"),Новый Структура("ВидИтога,ДтКт","НачальныйРазвернутыйОстаток#","Кт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.СНК);
		
	ИначеЕсли ТекстВидаИтога="СКДРС" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СК#РС","Д"),Новый Структура("ВидИтога,ДтКт","КонечныйРазвернутыйОстаток#","Дт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.СКД);
		
	ИначеЕсли ТекстВидаИтога="СККРС" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","СК#РС","К"),Новый Структура("ВидИтога,ДтКт","КонечныйРазвернутыйОстаток#","Кт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.СКК);
		
	ИначеЕсли ТекстВидаИтога="ДО" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","#О","Д"),Новый Структура("ВидИтога,ДтКт","Оборот#","Дт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.ДО);
		
	ИначеЕсли ТекстВидаИтога="КО" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","#О","К"),Новый Структура("ВидИтога,ДтКт","Оборот#","Кт"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету",Перечисления.ВидыБухгалтерскихИтогов.КО);
		
	ИначеЕсли ТекстВидаИтога="СО" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","#О","СВ"),Новый Структура("ВидИтога,ДтКт","Оборот#","СВ"));
		ДанныеИтога.Вставить("ВидИтогаПоСчету");
		
	ИначеЕсли ТекстВидаИтога="ОБ" Тогда
		
		ДанныеИтога = ?(Использование77, Новый Структура("ВидИтога,ДтКт","КорДО",""),Новый Структура("ВидИтога,ДтКт","Оборот",""));
		ДанныеИтога.Вставить("ВидИтогаПоСчету");
		
	Иначе
		
		ДанныеИтога= Неопределено;
		
	КонецЕсли;
	
	Возврат ДанныеИтога;
		
КонецФункции // ПолучитьВидИтогаДтКт()

Функция ПолучитьНастройкиДляРегистраБухгалтерии(НазначениеРасчетов,ТипБД) Экспорт
	
	ДанныеРегистра=Новый Структура("РегистрБД,РесурсРегистра,СпособПолучения,ПланСчетовБД,ВидОтчетаОСВ");
	
	Запрос=Новый Запрос;
	
	Запрос.Текст="ВЫБРАТЬ
	|	ПравилаОбработки.РегистрБухгалтерииПоУмолчанию КАК РегистрБД,
	|	ПравилаОбработки.РесурсРегистраПоУмолчанию КАК РесурсРегистра,
	|	ПравилаОбработки.ВидОтчетаОСВ,
	|	ПравилаОбработки.ПланСчетовПоУмолчанию КАК ПланСчетовБД,
	|	ПравилаОбработки.СпособПолучения
	|ИЗ
	|	Справочник.ПравилаОбработки КАК ПравилаОбработки
	|ГДЕ
	|	ПравилаОбработки.Ссылка = &Ссылка";
	
	
	Запрос.УстановитьПараметр("Ссылка",НазначениеРасчетов);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Если Результат.Следующий() Тогда
		
		ЗаполнитьЗначенияСвойств(ДанныеРегистра,Результат);
		
	КонецЕсли;
	
	Возврат ДанныеРегистра;
	
КонецФункции // ПолучитьНастройкиДляРегистраБухгалтерии()

Функция ПолучитьНастройкиДляКорректировкиБухгалтерии(НазначениеРасчетов,ПотребительРасчета) Экспорт
	
	Возврат Новый Структура("РегистрБД,РесурсРегистра",НазначениеРасчетов.РегистрБухгалтерии,ПотребительРасчета.РесурсРегистра);
			
КонецФункции // ПолучитьНастройкиДляРегистраБухгалтерии()

Функция ОпределитьТекстВидаИтога(ТекстФормулы,НачальныйИндекс) Экспорт
	
	Если ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,5))="СНДРС" Тогда
		
		Возврат "СНДРС";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,5))="СНКРС" Тогда
		
		Возврат "СНКРС";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,5))="СКДРС" Тогда
		
		Возврат "СКДРС";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,5))="СККРС" Тогда
		
		Возврат "СККРС";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,3))="СНС" Тогда
		
		Возврат "СНС";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,3))="СКС" Тогда
		
		Возврат "СКС";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,3))="СНД" Тогда
		
		Возврат "СНД";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,3))="СНК" Тогда
		
		Возврат "СНК";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,3))="СКД" Тогда
		
		Возврат "СКД";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,3))="СКК" Тогда
		
		Возврат "СКК";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,2))="СО" Тогда
		
		Возврат "СО";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,2))="ДО" Тогда
		
		Возврат "ДО";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,2))="КО" Тогда
		
		Возврат "КО";
		
	ИначеЕсли ВРЕГ(Сред(ТекстФормулы,НачальныйИндекс,2))="ОБ" Тогда
		
		Возврат "ОБ";
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
			
КонецФункции // ОпределитьТекстВидаИтога() 

// Возвращает результат разбора текста формулы в виде массива соответствий
// Ключом соответствия является текст, опознанный, как операнд формулы
// Значением - структура, определяющая вид и необходимые параметры операнда
//  - по упрощенному представлению данных РБ (СНД, СНК...): способ получения, регистр бухгалтерии, счет, корр. счет, вид итога, сдвиг периодов, текст субконто
//  - по упрощенному представлению ссылки на показатель отчета: вид отчета, показатель, сдвиг периодов, текст аналитик
//  - прочие операнды: операнд
//  Исходные настройки: структура
//
Функция ПолучитьРезультатРазбораТекстаФормулы(ТекстФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования,ТипБД, РегистрБД=Неопределено) Экспорт
	
	ДанныеРазбора=Новый Соответствие;
	
	Если ПустаяСтрока(ТекстФормулы) Тогда
		Возврат ДанныеРазбора;
	КонецЕсли;

	ТекстОперанда="";
	ЕстьНачалоОперанда=Ложь;
	
	ЗапросОперанды=Новый Запрос;
	ЗапросОперанды.Текст="ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИсточникиДанныхДляРасчетов.Ссылка,
	|	ИсточникиДанныхДляРасчетов.ПоказательТекущегоОтчета,
	|	ИсточникиДанныхДляРасчетов.ПоказательОтбор.ТипЗначения КАК ТипЗначения,
	|	ИсточникиДанныхДляРасчетов.ЕстьНестандартныеОтборы
	|ИЗ
	|	Справочник.ИсточникиДанныхДляРасчетов КАК ИсточникиДанныхДляРасчетов
	|ГДЕ
	|	ИсточникиДанныхДляРасчетов.Код = &Код
	|	И ИсточникиДанныхДляРасчетов.НазначениеРасчетов = &НазначениеРасчетов
	|	И ИсточникиДанныхДляРасчетов.ПотребительРасчета = &ПотребительРасчета
	|	И ИсточникиДанныхДляРасчетов.СпособИспользования = &СпособИспользования";
	
	//Поиск начала текста формулы. Пропускаем пробелы и "=";
	
	Для Индекс=0 По СтрДлина(ТекстФормулы) Цикл
		
		ТекСимвол=Сред(ТекстФормулы,Индекс,1);
		
		Если НЕ (ТекСимвол=" " ИЛИ ТекСимвол="=") Тогда
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТекстФормулы		= Сред(ТекстФормулы,Индекс);
	РабочийТекстФормулы = ТекстФормулы;
	
	Инд=1;
	ТолькоСуммирование=Истина;
	
	Пока Инд<=СтрДлина(РабочийТекстФормулы) Цикл
		
		ТекСимвол=Сред(РабочийТекстФормулы,Инд,1);
		
		Если ТекСимвол="[" Тогда // Предполагается начало операнда формулы
			
			ЕстьНачалоОперанда=Истина;
			Инд=Инд+1;
			
		ИначеЕсли ТекСимвол="]" И ЕстьНачалоОперанда Тогда // Предполагается, что сформирован текст операнда формулы
			
			ЗапросОперанды.УстановитьПараметр("Код",ТекстОперанда);
			ЗапросОперанды.УстановитьПараметр("НазначениеРасчетов",НазначениеРасчетов);
			ЗапросОперанды.УстановитьПараметр("ПотребительРасчета",ПотребительРасчета);
			ЗапросОперанды.УстановитьПараметр("СпособИспользования",СпособИспользования);
			
			Результат=ЗапросОперанды.Выполнить().Выбрать();
			
			Если Результат.Следующий() Тогда
				
				ДанныеРазбора.Вставить("["+ТекстОперанда+"]",Новый Структура("Код,Ссылка,ТипЗначения,ПоказательТекущегоОтчета,ЕстьНестандартныеОтборы",
					СокрЛП(ТекстОперанда),Результат.Ссылка,Результат.ТипЗначения,Результат.ПоказательТекущегоОтчета,Результат.ЕстьНестандартныеОтборы));
								
			КонецЕсли;
			
			ЕстьНачалоОперанда=Ложь;
			ТекстОперанда="";
			Инд=Инд+1;
			
		ИначеЕсли РусАнгАлфавитВспомогательныеСимволы(ВРЕГ(ТекСимвол)) Тогда
			
			Если ЕстьНачалоОперанда Тогда // Собираем код операнда
				
				ТекстОперанда=ТекстОперанда+ТекСимвол;
				Инд=Инд+1;
				
			Иначе
				
				ТекстИтога=ОпределитьТекстВидаИтога(РабочийТекстФормулы,Инд);
				
				Если Не ТекстИтога=Неопределено Тогда // Работаем с остатками или оборотами по регистру бухгалтерии
					
					СтруктураНастроек=ОпределитьНастройкиОперандаРегистраБухгалтерии(Инд,ТекстИтога,РабочийТекстФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования,ТипБД,РегистрБД);
					
					Если СтруктураНастроек.Свойство("НастройкиОперанда") Тогда
						
						ДанныеРазбора.Вставить(СтруктураНастроек.КодУпрощеннойФормулы,СтруктураНастроек.НастройкиОперанда);
						
					КонецЕсли;
					
					Инд=Инд+СтрДлина(СтруктураНастроек.КодУпрощеннойФормулы);
					
				Иначе // Возможно, начало ссылки на показатель другого отчета
					
					СтруктураНастроек=ОпределитьНастройкиОперандаПоказательОтчета(Инд,РабочийТекстФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования);
					
					Если СтруктураНастроек.Свойство("НастройкиОперанда") Тогда
						
						ДанныеРазбора.Вставить(СтруктураНастроек.КодУпрощеннойФормулы,СтруктураНастроек.НастройкиОперанда);
						
					КонецЕсли;
					
					Инд=Инд+СтрДлина(СтруктураНастроек.КодУпрощеннойФормулы);
					
				КонецЕсли;
				
			КонецЕсли;
			
		ИначеЕсли ТекСимвол="{" Тогда // Начало описания ссылки на показатель текущего отчета
			
			СтруктураНастроек=ОпределитьНастройкиОперандаПоказательОтчета(Инд,РабочийТекстФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования);
			
			Если СтруктураНастроек.Свойство("НастройкиОперанда") Тогда
				
				ДанныеРазбора.Вставить(СтруктураНастроек.КодУпрощеннойФормулы,СтруктураНастроек.НастройкиОперанда);
				
			КонецЕсли;
			
			Инд=Инд+СтрДлина(СтруктураНастроек.КодУпрощеннойФормулы);
			
		Иначе
			
			Если СтрНайти("+",ТекСимвол)=0 Тогда
				
				ТолькоСуммирование=Ложь;
				
			КонецЕсли;
					
			Инд=Инд+1;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ДанныеРазбора.Вставить("ТолькоСуммирование",ТолькоСуммирование);
			
	Возврат ДанныеРазбора;	
	
КонецФункции // ПолучитьРезультатРазбораУпрощеннойФормулы() 

Функция ПолучитьКодУпрощеннойФормулы(РабочийТекстФормулы,ТекстИтога="")
	
	ТекстФормулы="";
	ЕстьОткрывающаяСкобка=Ложь;
	ЕстьЗакрывающаяСкобка=Ложь;
	
	Для Инд=1 ПО СтрДлина(РабочийТекстФормулы) Цикл
		
		ТекСимвол=Сред(РабочийТекстФормулы,Инд,1);
		
		Если РусАнгАлфавитВспомогательныеСимволы(ВРЕГ(ТекСимвол)) 
			ИЛИ ТекСимвол="#" ИЛИ ТекСимвол="." Тогда
			
			ТекстФормулы=ТекстФормулы+ТекСимвол;
			
		ИначеЕсли (ТекСимвол="(" И (НЕ ПустаяСтрока(ТекстИтога))) ИЛИ ТекСимвол="{" Тогда
			
			Если ЕстьОткрывающаяСкобка Тогда
				
				Возврат ТекстФормулы;
				
			Иначе
				
				ЕстьОткрывающаяСкобка=Истина;
				ТекстФормулы=ТекстФормулы+ТекСимвол;
				
			КонецЕсли;
			
		ИначеЕсли (ТекСимвол=")" И (НЕ ПустаяСтрока(ТекстИтога))) ИЛИ ТекСимвол="}" Тогда
			
			Если ЕстьОткрывающаяСкобка Тогда
				
				ТекстФормулы=ТекстФормулы+ТекСимвол;
				ЕстьЗакрывающаяСкобка=Истина;
				
			Иначе
				
				Возврат ТекстФормулы;
				
			КонецЕсли;
			
		ИначеЕсли ТекСимвол="," ИЛИ ТекСимвол=";" ИЛИ ТекСимвол=" " ИЛИ ТекСимвол="-" Тогда
			
			Если (ЕстьОткрывающаяСкобка И (НЕ ЕстьЗакрывающаяСкобка)) ИЛИ (ТекстИтога="ОБ" И СтрНайти(ВРЕГ(ТекстФормулы),"ОБ")>0 И ТекСимвол=",") Тогда
				
				ТекстФормулы=ТекстФормулы+ТекСимвол;
				
			Иначе
				
				Возврат ТекстФормулы;
				
			КонецЕсли;
			
		Иначе
			
			Возврат ТекстФормулы;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекстФормулы;		
	
КонецФункции // ПолучитьКодУпрощеннойФормулы()

Функция ОпределитьКодыСчетов(КодСчета,КодКоррСчета,ТекстСчетов,ТекстИтога)
	
	Если ТекстИтога="ОБ" Тогда
		
		МассивСчетов=ОбщегоНазначенияУХ.РазложитьСтрокуВМассивПодстрок(ТекстСчетов,",");
		
		Если МассивСчетов.Количество() = 2 Тогда
			
			КодСчета		 = МассивСчетов[0];
			КодКоррСчета	 = МассивСчетов[1];
			
		Иначе
			
			ТекстСообщения = НСтр("ru = '%ТекстИтога% %ТекстСчетов%: не удалось определить код корр. счета.'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ТекстИтога%", Строка(ТекстИтога));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ТекстСчетов%", Строка(ТекстСчетов));
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Информация);
			Возврат Ложь;
			
		КонецЕсли;
		
	Иначе
		
		КодСчета = ТекстСчетов;
		
	КонецЕсли;
	
	Возврат Истина;
		
КонецФункции // ОпределитьКодыСчетов() 

Функция ПолучитьДанныеИсточникаПоКодуУпрощеннойФормулы(КодУпрощеннойФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования=Неопределено) Экспорт
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	РеквизитыИсточниковДанныхДляФормул.ИсточникДанных,
	|	РеквизитыИсточниковДанныхДляФормул.КодИсточника,
	|	РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы,
	|	РеквизитыИсточниковДанныхДляФормул.ПоказательТекущегоОтчета,
	|	РеквизитыИсточниковДанныхДляФормул.ЕстьНестандартныеОтборы
	|ИЗ
	|	РегистрСведений.РеквизитыИсточниковДанныхДляФормул КАК РеквизитыИсточниковДанныхДляФормул
	|ГДЕ
	|	РеквизитыИсточниковДанныхДляФормул.НазначениеРасчетов = &НазначениеРасчетов
	|	И РеквизитыИсточниковДанныхДляФормул.ПотребительРасчета = &ПотребительРасчета
	|	И РеквизитыИсточниковДанныхДляФормул.СпособИспользования = &СпособИспользования
	|	И РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы = &КодУпрощеннойФормулы";
	
	Запрос.УстановитьПараметр("НазначениеРасчетов",НазначениеРасчетов);
	Запрос.УстановитьПараметр("ПотребительРасчета",ПотребительРасчета);
	Запрос.УстановитьПараметр("КодУпрощеннойФормулы",КодУпрощеннойФормулы);
	Запрос.УстановитьПараметр("СпособИспользования",?(СпособИспользования=Неопределено,Перечисления.СпособыИспользованияОперандов.ДляФормулРасчета,СпособИспользования));
	
	Результат=Запрос.Выполнить().Выбрать();
	
	ДанныеИсточника=Новый Структура;
	
	Если Результат.Следующий() Тогда
		
		ДанныеИсточника.Вставить("Код",СокрЛП(Результат.КодИсточника));
		ДанныеИсточника.Вставить("Ссылка",Результат.ИсточникДанных);
		ДанныеИсточника.Вставить("КодУпрощеннойФормулы",Результат.КодУпрощеннойФормулы);
		ДанныеИсточника.Вставить("ПоказательТекущегоОтчета",Результат.ПоказательТекущегоОтчета);
		ДанныеИсточника.Вставить("ЕстьНестандартныеОтборы",Результат.ЕстьНестандартныеОтборы);
						
	КонецЕсли;
	
	Возврат ДанныеИсточника;
				 	
КонецФункции // ПолучитьДанныеИсточникаПоКодуУпрощеннойФормулы()

Функция ПолучитьДанныеИсточникаПоКодуПоказателя(КодУпрощеннойФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования=Неопределено) Экспорт
	
	ДанныеИсточника=Новый Структура;
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	РеквизитыИсточниковДанныхДляФормул.ИсточникДанных,
	|	РеквизитыИсточниковДанныхДляФормул.КодИсточника,
	|	РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы,
	|	РеквизитыИсточниковДанныхДляФормул.ПоказательТекущегоОтчета,
	|	РеквизитыИсточниковДанныхДляФормул.ЕстьНестандартныеОтборы
	|ИЗ
	|	РегистрСведений.РеквизитыИсточниковДанныхДляФормул КАК РеквизитыИсточниковДанныхДляФормул
	|ГДЕ
	|	РеквизитыИсточниковДанныхДляФормул.НазначениеРасчетов = &НазначениеРасчетов
	|	И РеквизитыИсточниковДанныхДляФормул.ПотребительРасчета = &ПотребительРасчета
	|	И РеквизитыИсточниковДанныхДляФормул.СпособИспользования = &СпособИспользования
	|	И РеквизитыИсточниковДанныхДляФормул.ВидОтчетаОтбор = &ВидОтчетаОтбор
	|	И РеквизитыИсточниковДанныхДляФормул.КодПоказательОтбор = &КодПоказательОтбор";
	
	Запрос.УстановитьПараметр("НазначениеРасчетов",НазначениеРасчетов);
	Запрос.УстановитьПараметр("ПотребительРасчета",ПотребительРасчета);
	Запрос.УстановитьПараметр("СпособИспользования",?(СпособИспользования=Неопределено,Перечисления.СпособыИспользованияОперандов.ДляФормулРасчета,СпособИспользования));
	
	Если Лев(КодУпрощеннойФормулы,1)="{" Тогда
		ВидОтчетаОтбор=НазначениеРасчетов.Владелец;
	Иначе	
		ВидОтчетаОтбор=Справочники.ВидыОтчетов.НайтиПоКоду(Лев(КодУпрощеннойФормулы, СтрНайти(КодУпрощеннойФормулы,"{")-1));
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ВидОтчетаОтбор) Тогда
		Запрос.УстановитьПараметр("ВидОтчетаОтбор",ВидОтчетаОтбор);
	Иначе	
		Возврат ДанныеИсточника;
	КонецЕсли;

	КодПоказателя=Сред(КодУпрощеннойФормулы, СтрНайти(КодУпрощеннойФормулы,"{")+1);
	КодПоказателя=СтрЗаменить(КодПоказателя,"}","");
	Запрос.УстановитьПараметр("КодПоказательОтбор",КодПоказателя);
		
	Результат=Запрос.Выполнить().Выбрать();
		
	Если Результат.Следующий() Тогда
		
		ДанныеИсточника.Вставить("Код",СокрЛП(Результат.КодИсточника));
		ДанныеИсточника.Вставить("Ссылка",Результат.ИсточникДанных);
		ДанныеИсточника.Вставить("КодУпрощеннойФормулы",Результат.КодУпрощеннойФормулы);
		ДанныеИсточника.Вставить("ПоказательТекущегоОтчета",Результат.ПоказательТекущегоОтчета);
		ДанныеИсточника.Вставить("ЕстьНестандартныеОтборы",Результат.ЕстьНестандартныеОтборы);
						
	КонецЕсли;
	
	Возврат ДанныеИсточника;
				 	
КонецФункции // ПолучитьДанныеИсточникаПоКодуУпрощеннойФормулы()

Функция ПолучитьДанныеИсточникаПоКодуИсточника(КодУпрощеннойФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования=Неопределено) Экспорт
	
	ДанныеИсточника=Новый Структура;
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	РеквизитыИсточниковДанныхДляФормул.ИсточникДанных,
	|	РеквизитыИсточниковДанныхДляФормул.КодИсточника,
	|	РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы,
	|	РеквизитыИсточниковДанныхДляФормул.ПоказательТекущегоОтчета,
	|	РеквизитыИсточниковДанныхДляФормул.ЕстьНестандартныеОтборы
	|ИЗ
	|	РегистрСведений.РеквизитыИсточниковДанныхДляФормул КАК РеквизитыИсточниковДанныхДляФормул
	|ГДЕ
	|	РеквизитыИсточниковДанныхДляФормул.НазначениеРасчетов = &НазначениеРасчетов
	|	И РеквизитыИсточниковДанныхДляФормул.ПотребительРасчета = &ПотребительРасчета
	|	И РеквизитыИсточниковДанныхДляФормул.СпособИспользования = &СпособИспользования
	|	И РеквизитыИсточниковДанныхДляФормул.КодИсточника = &КодПоказательОтбор";
	
	Запрос.УстановитьПараметр("НазначениеРасчетов",НазначениеРасчетов);
	Запрос.УстановитьПараметр("ПотребительРасчета",ПотребительРасчета);
	Запрос.УстановитьПараметр("СпособИспользования",?(СпособИспользования=Неопределено,Перечисления.СпособыИспользованияОперандов.ДляФормулРасчета,СпособИспользования));
	
	КодПоказателя=Сред(КодУпрощеннойФормулы, СтрНайти(КодУпрощеннойФормулы,"{")+1);
	КодПоказателя=СтрЗаменить(КодПоказателя,"}","");
	Запрос.УстановитьПараметр("КодПоказательОтбор",КодПоказателя);
		
	Результат=Запрос.Выполнить().Выбрать();
		
	Если Результат.Следующий() Тогда
		
		ДанныеИсточника.Вставить("Код",СокрЛП(Результат.КодИсточника));
		ДанныеИсточника.Вставить("Ссылка",Результат.ИсточникДанных);
		ДанныеИсточника.Вставить("КодУпрощеннойФормулы",Результат.КодУпрощеннойФормулы);
		ДанныеИсточника.Вставить("ПоказательТекущегоОтчета",Результат.ПоказательТекущегоОтчета);
		ДанныеИсточника.Вставить("ЕстьНестандартныеОтборы",Результат.ЕстьНестандартныеОтборы);
						
	КонецЕсли;
	
	Возврат ДанныеИсточника;
				 	
КонецФункции // ПолучитьДанныеИсточникаПоКодуУпрощеннойФормулы()


Функция ПрочитатьКодУпрощеннойФормулы(ИсточникДанных=Неопределено,КодИсточника=Неопределено,ПотребительРасчета=Неопределено,СпособИспользования=Неопределено) Экспорт
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы
	|ИЗ
	|	РегистрСведений.РеквизитыИсточниковДанныхДляФормул КАК РеквизитыИсточниковДанныхДляФормул
	|ГДЕ";
	
	Если ЗначениеЗаполнено(ИсточникДанных) Тогда
		
		Запрос.Текст=Запрос.Текст+" РеквизитыИсточниковДанныхДляФормул.ИсточникДанных=&ИсточникДанных";
		Запрос.УстановитьПараметр("ИсточникДанных",ИсточникДанных);
		
	ИначеЕсли ЗначениеЗаполнено(КодИсточника) 
		И ЗначениеЗаполнено(ПотребительРасчета)
		И ЗначениеЗаполнено(СпособИспользования) Тогда
		
		Запрос.Текст=Запрос.Текст+" РеквизитыИсточниковДанныхДляФормул.КодИсточника=&КодИсточника
		|И ПотребительРасчета=&ПотребительРасчета
		|И СпособИспользования=&СпособИспользования";
		Запрос.УстановитьПараметр("КодИсточника",КодИсточника);
		Запрос.УстановитьПараметр("ПотребительРасчета",ПотребительРасчета);
		Запрос.УстановитьПараметр("СпособИспользования",СпособИспользования);
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Если Результат.Следующий() Тогда
		
		Возврат СокрЛП(Результат.КодУпрощеннойФормулы);
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
				 				 	
КонецФункции // ПолучитьКодУпрощеннойФормулы()

Функция ПолучитьВозможныйКодУпрощеннойФормулы(ПроектКода,Ссылка,НазначениеРасчетов,ПотребительРасчета) Экспорт
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ ПЕРВЫЕ 1
	|	РеквизитыИсточниковДанныхДляФормул.ИсточникДанных
	|ИЗ
	|	РегистрСведений.РеквизитыИсточниковДанныхДляФормул КАК РеквизитыИсточниковДанныхДляФормул
	|ГДЕ
	|	РеквизитыИсточниковДанныхДляФормул.НазначениеРасчетов = &НазначениеРасчетов
	|	И РеквизитыИсточниковДанныхДляФормул.ПотребительРасчета = &ПотребительРасчета
	|	И РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы = &КодУпрощеннойФормулы
	|	И РеквизитыИсточниковДанныхДляФормул.ИсточникДанных <> &Ссылка";
	
	Запрос.УстановитьПараметр("НазначениеРасчетов",НазначениеРасчетов);
	Запрос.УстановитьПараметр("ПотребительРасчета",ПотребительРасчета);
	Запрос.УстановитьПараметр("КодУпрощеннойФормулы",ПроектКода);
	Запрос.УстановитьПараметр("Ссылка",Ссылка);
	
	Результат=Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		
		Возврат ПроектКода;
		
	КонецЕсли;
	
	Запрос.Текст="ВЫБРАТЬ
	|	РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы КАК КодУпрощеннойФормулы
	|ИЗ
	|	РегистрСведений.РеквизитыИсточниковДанныхДляФормул КАК РеквизитыИсточниковДанныхДляФормул
	|ГДЕ
	|	РеквизитыИсточниковДанныхДляФормул.НазначениеРасчетов = &НазначениеРасчетов
	|	И РеквизитыИсточниковДанныхДляФормул.ПотребительРасчета = &ПотребительРасчета
	|	И РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы ПОДОБНО &ПроектКода
	|	И РеквизитыИсточниковДанныхДляФормул.ИсточникДанных <> &Ссылка";
	
	Запрос.УстановитьПараметр("ПроектКода",ПроектКода+"%");
		
	ТаблицаКодов=Запрос.Выполнить().Выгрузить();
	
	Индекс=1;
	
	Пока Истина Цикл
		
		Если ТаблицаКодов.Найти(ПроектКода+Формат(Индекс,"ЧРГ="),"КодУпрощеннойФормулы")=Неопределено Тогда
			
			Возврат ПроектКода+Формат(Индекс,"ЧРГ=");
			
		Иначе
			
			Индекс=Индекс+1;
			
		КонецЕсли;
		
	КонецЦикла;
							 				 	
КонецФункции // ПолучитьВозможныйКодУпрощеннойФормулы()
		
Функция ОпределитьНастройкиОперандаРегистраБухгалтерии(Инд,ТекстИтога,РабочийТекстФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования,ТипБД,РегистрБД)
	
	КодУпрощеннойФормулы=ПолучитьКодУпрощеннойФормулы(Сред(РабочийТекстФормулы,Инд),ТекстИтога);
	ВидИтогаДтКт=ОбщегоНазначенияУХ.ПолучитьВидИтогаДтКт(ТекстИтога,ТипБД.ВерсияПлатформы=Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие77);
	
	СтруктураНастроек=Новый Структура;
	СтруктураНастроек.Вставить("КодУпрощеннойФормулы",КодУпрощеннойФормулы);
	
	СуществующийИсточник=ПолучитьДанныеИсточникаПоКодуУпрощеннойФормулы(ВРЕГ(КодУпрощеннойФормулы),НазначениеРасчетов,ПотребительРасчета,СпособИспользования);
	
	Если СуществующийИсточник.Свойство("Код") Тогда
		
		СтруктураНастроек.Вставить("НастройкиОперанда",СуществующийИсточник);	
		Возврат СтруктураНастроек;
		
	КонецЕсли;
		
	Если СтрНайти(КодУпрощеннойФормулы,"#")>0 Тогда // Не производим никаких действий, операнд редактируется в форме элемента
		Возврат СтруктураНастроек;
	КонецЕсли;
	
	НастройкиОперанда=Новый Структура;			
	ДанныеРегистра=ОбщегоНазначенияУХ.ПолучитьНастройкиДляРегистраБухгалтерии(НазначениеРасчетов,ТипБД);
		
			
	////////////////////////////////////////////////////////////////////////////
	// Проверим наличие необходимых исходных параметров
		
	Если ЗначениеЗаполнено(ДанныеРегистра.РесурсРегистра) Тогда
				
		НастройкиОперанда.Вставить("РесурсРегистра",ДанныеРегистра.РесурсРегистра);
				
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДанныеРегистра.РегистрБД) Тогда
		
		НастройкиОперанда.Вставить("РегистрБД",ДанныеРегистра.РегистрБД);
		
	КонецЕсли;
		
	// Определим способ получения данных	
	Если ЗначениеЗаполнено(ДанныеРегистра.СпособПолучения) Тогда
		
		СпособПолучения=ДанныеРегистра.СпособПолучения;
		
	ИначеЕсли ТипБД=Справочники.ТипыБазДанных.ТекущаяИБ Тогда
		
		СпособПолучения=Перечисления.СпособыПолученияОперандов.ВнутренниеДанныеРегистрБухгалтерии;
		
	ИначеЕсли ТипБД.ВерсияПлатформы=Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие77 Тогда
		
		СпособПолучения=Перечисления.СпособыПолученияОперандов.ВнешниеДанныеОстаткиИОборотыИзПланаСчетов
		
	Иначе
		
		СпособПолучения=Перечисления.СпособыПолученияОперандов.ВнешниеДанныеРегистрБухгалтерии;
		
	КонецЕсли;
	
	НастройкиОперанда.Вставить("СпособПолучения",СпособПолучения);
	НастройкиОперанда.Вставить("СпособИспользования",?(ЗначениеЗаполнено(СпособИспользования),СпособИспользования,Перечисления.СпособыИспользованияОперандов.ДляФормулРасчета));
	НастройкиОперанда.Вставить("ТипБД",ТипБД);
		
	Если ЗначениеЗаполнено(ДанныеРегистра.ПланСчетовБД) Тогда
		
		ПланСчетовБД=ДанныеРегистра.ПланСчетовБД;
		
	ИначеЕсли ЗначениеЗаполнено(РегистрБД) И ТипЗнч(РегистрБД)=Тип("СправочникСсылка.РегистрыБухгалтерииБД") Тогда
		
		ПланСчетовБД=РегистрБД.ПланСчетов;
		
	ИначеЕсли НастройкиОперанда.Свойство("РегистрБД") Тогда
		
		ПланСчетовБД=НастройкиОперанда.РегистрБД.ПланСчетов;
		
	Иначе
		
		ТекстСообщения = НСтр("ru = 'Не удалось определить план счетов регистра бухгалтерии.'");
		ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Информация);
		Возврат СтруктураНастроек;
		
	КонецЕсли;
	
	НастройкиОперанда.Вставить("ПланСчетовБД",ПланСчетовБД);
		
	/// Разберем текст упрощенной формулы по функциональным блокам.
	
	РабочийТекст=СтрЗаменить(ВРЕГ(КодУпрощеннойФормулы),ТекстИтога,"");
	
	СдвигПериодов=0;
	ТекстАналитик="";
	КодСчета="";
	КодКоррСчета="";
	
	Если СтрНайти(РабочийТекст,"(")=0 Тогда
		
		Если НЕ ОпределитьКодыСчетов(КодСчета,КодКоррСчета,РабочийТекст,ТекстИтога) Тогда
			
			Возврат СтруктураНастроек;

		КонецЕсли;	
				
	Иначе
		
		ТекстСчета=Лев(РабочийТекст, СтрНайти(РабочийТекст,"(")-1);
		
		Если НЕ ОпределитьКодыСчетов(КодСчета,КодКоррСчета,ТекстСчета,ТекстИтога) Тогда
			
			Возврат СтруктураНастроек;

		КонецЕсли;
		
		ТекстНастройки=Сред(РабочийТекст, СтрНайти(РабочийТекст,"(")+1);
		ТекстНастройки=СтрЗаменить(ТекстНастройки,")","");
		МассивНастроек=ОбщегоНазначенияУХ.РазложитьСтрокуВМассивПодстрок(ТекстНастройки,";");
				
		Если МассивНастроек.Количество()=2 Тогда
			
			СдвигПериодов=Число(СтрЗаменить(МассивНастроек[0]," ",""));
			ТекстАналитик=СтрЗаменить(МассивНастроек[1]," ","");
			
		ИначеЕсли МассивНастроек.Количество()=1 Тогда
			
			Если Лев(СтрЗаменить(МассивНастроек[0]," ",""),1)="С" 
				ИЛИ Лев(СтрЗаменить(МассивНастроек[0]," ",""),1)="К"
				ИЛИ Лев(СтрЗаменить(МассивНастроек[0]," ",""),1)="А" Тогда
				
				ТекстАналитик=СтрЗаменить(МассивНастроек[0]," ","");
				
			Иначе
				
				СдвигПериодов=Число(СтрЗаменить(МассивНастроек[0]," ",""));
				
			КонецЕсли;
						
		КонецЕсли;
		
	КонецЕсли;
			
	//Настроим источник по результату разбора формулы
	
	Счет=ПолучитьСчет(КодСчета,ПланСчетовБД);
	
	Если Не ЗначениеЗаполнено(Счет) Тогда
		
		ТекстСообщения = НСтр("ru = 'На плане счетов %ПланСчетов% не найден счет с кодом %КодСчета%.'");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПланСчетов%", Строка(ПланСчетовБД));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КодСчета%", Строка(КодСчета));
		ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Внимание);
		Возврат СтруктураНастроек;
		
	Иначе
		
		НастройкиОперанда.Вставить("Счет", Счет);
		
	КонецЕсли;
	
	Если ТекстИтога="ОБ" Тогда
		
		КоррСчет=ПолучитьСчет(КодКоррСчета,ПланСчетовБД);
		
		Если Не ЗначениеЗаполнено(КоррСчет) Тогда
			
			ТекстСообщения = НСтр("ru = 'На плане счетов %ПланСчетов% не найден счет с кодом %КодКоррСчета%.'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПланСчетов%", Строка(ПланСчетовБД));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КодКоррСчета%", Строка(КодКоррСчета));
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Внимание);
			Возврат СтруктураНастроек;
			
		Иначе
			
			НастройкиОперанда.Вставить("КоррСчет",КоррСчет);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если НастройкиОперанда.СпособПолучения=Перечисления.СпособыПолученияОперандов.ВнутренниеДанныеПоказательОтчета Тогда
		
		ПоказательОтбор=Справочники.ВидыОтчетов.ПолучитьПоказательОСВ(Счет,ВидИтогаДтКт.ВидИтогаПоСчету,КоррСчет,НазначениеРасчетов);
		
		Если НЕ ЗначениеЗаполнено(ПоказательОтбор) Тогда
			
			ТекстСообщения = НСтр("ru = 'Не найден показатель %ВидИтогаПоСчету% оборотно-сальдовой ведомости для счета %Счет% плана счетов %ПланСчетов%'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ВидИтогаПоСчету%", Строка(ВидИтогаДтКт.ВидИтогаПоСчету));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Счет%", Строка(Счет));
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПланСчетов%", Строка(ПланСчетовБД));
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Внимание);
			
			Возврат СтруктураНастроек;
			
		Иначе
			
			НастройкиОперанда.Вставить("ПоказательОтбор",ПоказательОтбор);
			
		КонецЕсли;
		
		НастройкиОперанда.Вставить("ВидОтчетаОтбор",ПоказательОтбор.Владелец);
		
	Иначе
		
		НастройкиОперанда.Вставить("ВидИтога",ВидИтогаДтКт.ВидИтога);
		НастройкиОперанда.Вставить("ДтКт",ВидИтогаДтКт.ДтКт);
		
	КонецЕсли;
	
	НастройкиОперанда.Вставить("СдвигПериодов",СдвигПериодов);
	НастройкиОперанда.Вставить("ТекстАналитик",ТекстАналитик);
	
	СтруктураНастроек.Вставить("НастройкиОперанда",НастройкиОперанда);
	
	Возврат СтруктураНастроек;		
КонецФункции // ОпределитьНастройкиОперандаРегистраБухгалтерии()

Функция ПолучитьСчет(КодСчета,ПланСчетов) Экспорт
	
	Если ПустаяСтрока(КодСчета) Тогда
		
		Возврат "";
		
	КонецЕсли;
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	СчетаБД.Ссылка
	|ИЗ
	|	Справочник.СчетаБД КАК СчетаБД
	|ГДЕ
	|	СчетаБД.Владелец = &Владелец
	|	И СчетаБД.Код = &Код";
	
	Запрос.УстановитьПараметр("Код",КодСчета);
	Запрос.УстановитьПараметр("Владелец",ПланСчетов);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Если Результат.Следующий() Тогда
		
		Возврат Результат.Ссылка;
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
		
КонецФункции // ПолучитьСчет()

Функция ОпределитьНастройкиОперандаПоказательОтчета(Инд,РабочийТекстФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования)
	
	КодУпрощеннойФормулы=ПолучитьКодУпрощеннойФормулы(Сред(РабочийТекстФормулы,Инд));
	
	СтруктураНастроек=Новый Структура;
	СтруктураНастроек.Вставить("КодУпрощеннойФормулы",КодУпрощеннойФормулы);
	
	Если СтрНайти(КодУпрощеннойФормулы,"{")>0 И СтрНайти(КодУпрощеннойФормулы,"}")>0 Тогда
		
		СуществующийИсточник=ПолучитьДанныеИсточникаПоКодуУпрощеннойФормулы(КодУпрощеннойФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования);
		
		Если НЕ СуществующийИсточник.Свойство("Код") Тогда
			
			СуществующийИсточник=ПолучитьДанныеИсточникаПоКодуПоказателя(КодУпрощеннойФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования);
			
		КонецЕсли;
				
	Иначе
		
		СуществующийИсточник=ПолучитьДанныеИсточникаПоКодуПоказателя(КодУпрощеннойФормулы,НазначениеРасчетов,ПотребительРасчета,СпособИспользования);
		
	КонецЕсли;
	
	Если СуществующийИсточник.Свойство("Код") Тогда
		
		СтруктураНастроек.Вставить("НастройкиОперанда",СуществующийИсточник);	
		Возврат СтруктураНастроек;
		
	КонецЕсли;
	
	НастройкиОперанда=Новый Структура;
	
	Если СтрНайти(КодУпрощеннойФормулы,"{")=0 Тогда
		Возврат СтруктураНастроек;
	КонецЕсли;
		
	Если Лев(КодУпрощеннойФормулы,1)="{" Тогда
		ВидОтчетаОтбор=НазначениеРасчетов.Владелец;
	Иначе	
		ВидОтчетаОтбор=Справочники.ВидыОтчетов.НайтиПоКоду(Лев(КодУпрощеннойФормулы, СтрНайти(КодУпрощеннойФормулы,"{")-1));
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ВидОтчетаОтбор) Тогда
		Возврат СтруктураНастроек;
	Иначе
		НастройкиОперанда.Вставить("ВидОтчетаОтбор",ВидОтчетаОтбор);
	КонецЕсли;
	
	НастройкиОперанда.Вставить("СпособПолучения",Перечисления.СпособыПолученияОперандов.ВнутренниеДанныеПоказательОтчета);
	НастройкиОперанда.Вставить("СпособИспользования",?(ЗначениеЗаполнено(СпособИспользования),СпособИспользования,Перечисления.СпособыИспользованияОперандов.ДляФормулРасчета));
	
	СдвигПериодов=0;
	ТекстАналитик="";
	
	/// Разберем текст управляемой формулы по функциональным блокам.
	
	ТекстНастройки=Сред(КодУпрощеннойФормулы, СтрНайти(КодУпрощеннойФормулы,"{")+1);
	ТекстНастройки=СтрЗаменить(ТекстНастройки,"}","");
	МассивНастроек=ОбщегоНазначенияУХ.РазложитьСтрокуВМассивПодстрок(ТекстНастройки,";");
	
	/// Определим показатель для отбора
	
	АдресПоказателя=СтрЗаменить(МассивНастроек[0]," ","");
	
	/// Определим сдвиг периодов
	
	Если МассивНастроек.Количество()=2 Тогда
		
		ТекстАналитики=ВРЕГ(МассивНастроек[1]);
		
		Если Лев(СтрЗаменить(ТекстАналитики," ",""),1)="А" Тогда
			
			ТекстАналитик=СтрЗаменить(ТекстАналитики," ","");
			
		Иначе
			
			СдвигПериодов=Число(СтрЗаменить(ТекстАналитики," ",""));
			
		КонецЕсли;
		
	ИначеЕсли МассивНастроек.Количество()=3 Тогда
		
		СдвигПериодов=Число(СтрЗаменить(МассивНастроек[1]," ",""));
		ТекстАналитик=СтрЗаменить(ВРЕГ(МассивНастроек[2])," ","");
		
	КонецЕсли;
	
	// Настроим источник по результату разбора формулы
	
	Если ПереданАдресПоказателя(АдресПоказателя) Тогда
		
		ПоказательОтбор=ПолучитьЭлементСтруктурыПоАдресу(ВидОтчетаОтбор,Перечисления.ЭлементыСтруктурыОтчета.Показатель,ВРЕГ(АдресПоказателя));
		
		Если Не ЗначениеЗаполнено(ПоказательОтбор) Тогда // Попытка найти по коду
			
			ПоказательОтбор=Справочники.ПоказателиОтчетов.НайтиПоКоду(АдресПоказателя,,,ВидОтчетаОтбор);
			
			Если Не ЗначениеЗаполнено(ПоказательОтбор) Тогда
				
				ТекстСообщения = НСтр("ru = 'Для вида отчета %ВидОтчетаОтбор% не найден показатель по адресу %АдресПоказателя%.'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ВидОтчетаОтбор%", Строка(ВидОтчетаОтбор));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%АдресПоказателя%", Строка(АдресПоказателя));
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Внимание);
				Возврат СтруктураНастроек;
				
			Иначе
				
				НастройкиОперанда.Вставить("ПоказательОтбор",ПоказательОтбор);
				
			КонецЕсли;
			
		Иначе
			
			НастройкиОперанда.Вставить("ПоказательОтбор",ПоказательОтбор);
			
		КонецЕсли;
		
	Иначе
		
		Если СтрЧислоВхождений(АдресПоказателя,".")=1 Тогда   //Это представление операнда по абсолютному пути  
			
			 тМассивСтруктурыКода 	= СтрРазделить(АдресПоказателя,"."); 
			 тВидОтчета 			= Справочники.ВидыОтчетов.НайтиПоКоду(тМассивСтруктурыКода[0],,,);
			 ПоказательОтбор		= Справочники.ПоказателиОтчетов.НайтиПоКоду(тМассивСтруктурыКода[1],,,тВидОтчета);
			 Если Не ЗначениеЗаполнено(ПоказательОтбор) Тогда
				
				ТекстСообщения = НСтр("ru = 'Для вида отчета %ВидОтчетаОтбор% не найден показатель с кодом %АдресПоказателя%.'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ВидОтчетаОтбор%", Строка(ВидОтчетаОтбор));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%АдресПоказателя%", Строка(АдресПоказателя));
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Внимание);
				Возврат СтруктураНастроек;
				
				
			Иначе
				
				НастройкиОперанда.Вставить("ПоказательОтбор",ПоказательОтбор);
				
			КонецЕсли;

		 Иначе	
			
			ПоказательОтбор=Справочники.ПоказателиОтчетов.НайтиПоКоду(АдресПоказателя,,,ВидОтчетаОтбор);
			
			Если Не ЗначениеЗаполнено(ПоказательОтбор) Тогда
				
				ТекстСообщения = НСтр("ru = 'Для вида отчета %ВидОтчетаОтбор% не найден показатель с кодом %АдресПоказателя%.'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ВидОтчетаОтбор%", Строка(ВидОтчетаОтбор));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%АдресПоказателя%", Строка(АдресПоказателя));
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения, , , СтатусСообщения.Внимание);
				Возврат СтруктураНастроек;
				
				
			Иначе
				
				НастройкиОперанда.Вставить("ПоказательОтбор",ПоказательОтбор);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
		
	НастройкиОперанда.Вставить("СдвигПериодов",СдвигПериодов);
	НастройкиОперанда.Вставить("ТекстАналитик",ТекстАналитик);
	
	СтруктураНастроек.Вставить("НастройкиОперанда",НастройкиОперанда);
	
	Возврат СтруктураНастроек;
		
КонецФункции // ОпределитьНастройкиОперандаПоказательОтчета()

Функция ПереданАдресПоказателя(СтрокаАдрес)
	
	ЕстьСтрока=Ложь;
	ЕстьКолонка=Ложь;
	
	РабочаяСтрока=ВРЕГ(СтрокаАдрес);
	ТекстЦифры="0123456789";
	
	Если НЕ (Лев(РабочаяСтрока,1)="С" И СтрНайти(ТекстЦифры,Сред(РабочаяСтрока,2,1))>0) Тогда
		
		Возврат Ложь;
		
	Иначе
		
		ЕстьСтрока=Истина;
		
	КонецЕсли;
	
	Для Инд = 3 По СтрДлина(РабочаяСтрока) Цикл
		
		ТекСимвол=Сред(РабочаяСтрока, Инд, 1);
		
		Если ТекСимвол="К" Тогда
			
			Если НЕ ЕстьКолонка Тогда
				
				ЕстьКолонка=Истина;
				
			Иначе
				
				Возврат ЛОжь;
				
			КонецЕсли;
			
		ИначеЕсли СтрНайти(ТекстЦифры,ТекСимвол)=0 Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат ЕстьСтрока И ЕстьКолонка;
	
КонецФункции // ПереданАдресПоказателя()

Функция ЗаменитьКодыВТекстеФормулы(ТекстПроцедуры, НазначениеРасчетов,ПотребительРасчета,НаКодыИсточников=Ложь) Экспорт
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	ИсточникиДанныхДляРасчетов.Код,
	|	РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы
	|ИЗ
	|	Справочник.ИсточникиДанныхДляРасчетов КАК ИсточникиДанныхДляРасчетов
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.РеквизитыИсточниковДанныхДляФормул КАК РеквизитыИсточниковДанныхДляФормул
	|		ПО ИсточникиДанныхДляРасчетов.Ссылка = РеквизитыИсточниковДанныхДляФормул.ИсточникДанных
	|ГДЕ
	|	ИсточникиДанныхДляРасчетов.НазначениеРасчетов = &НазначениеРасчетов
	|	И ИсточникиДанныхДляРасчетов.ПотребительРасчета = &ПотребительРасчета
	|	И (ИсточникиДанныхДляРасчетов.СпособИспользования = ЗНАЧЕНИЕ(Перечисление.СпособыИспользованияОперандов.ДляФормулРасчета)
	|			ИЛИ ИсточникиДанныхДляРасчетов.СпособИспользования = ЗНАЧЕНИЕ(Перечисление.СпособыИспользованияОперандов.ДляТрансформационныхКорректировок))";
	
	Запрос.УстановитьПараметр("НазначениеРасчетов",НазначениеРасчетов);
	Запрос.УстановитьПараметр("ПотребительРасчета",ПотребительРасчета);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		Если НаКодыИсточников Тогда
			
			ТекстПроцедуры=СтрЗаменить(ТекстПроцедуры,СокрЛП(Результат.КодУпрощеннойФормулы),"["+СокрЛП(Результат.Код)+"]");
			
		Иначе
			
			ТекстПроцедуры=СтрЗаменить(ТекстПроцедуры,"["+СокрЛП(Результат.Код)+"]",СокрЛП(Результат.КодУпрощеннойФормулы));
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекстПроцедуры;	
	
КонецФункции // ЗаменитьКодыИсточниковНаУпрощенные()

Функция ЗаполнитьФормулуРасчетаПоказателяПоУмолчанию(НазначениеРасчетов,ПотребительРасчета) Экспорт
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	ИсточникиДанныхДляРасчетов.Код,
	|	ИсточникиДанныхДляРасчетов.Ссылка,
	|	ИсточникиДанныхДляРасчетов.НеИспользуется
	|ИЗ
	|	Справочник.ИсточникиДанныхДляРасчетов КАК ИсточникиДанныхДляРасчетов
	|ГДЕ
	|	ИсточникиДанныхДляРасчетов.НазначениеРасчетов = &НазначениеРасчетов
	|	И ИсточникиДанныхДляРасчетов.ПотребительРасчета = &ПотребительРасчета
	|	И ИсточникиДанныхДляРасчетов.СпособИспользования = ЗНАЧЕНИЕ(Перечисление.СпособыИспользованияОперандов.ДляФормулРасчета)
	|	И НЕ ИсточникиДанныхДляРасчетов.ПометкаУдаления";
	
	Запрос.УстановитьПараметр("НазначениеРасчетов",НазначениеРасчетов);
	Запрос.УстановитьПараметр("ПотребительРасчета",ПотребительРасчета);
	
	Результат=Запрос.Выполнить().Выбрать();
	ТекстФормулы="";
	
	Пока Результат.Следующий() Цикл
		
		Если Результат.НеИспользуется Тогда
			
			ИсточникОбъект=Результат.Ссылка.ПолучитьОбъект();
			ИсточникОбъект.НеИспользуется=Ложь;
			ИсточникОбъект.Записать();
			
		КонецЕсли;
		
		ТекстФормулы=ТекстФормулы+" + ["+СокрЛП(Результат.Код)+"]";
		
	КонецЦикла;

	СтруктураПараметров=Новый Структура("НазначениеРасчетов,ПотребительРасчета,Процедура,ПроизвольныйКод",НазначениеРасчетов,ПотребительРасчета,Сред(ТекстФормулы,4),Ложь);
	
	Если НЕ УправлениеОтчетамиУХ.ПроверитьФормулуПоказателя(СтруктураПараметров) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	УправлениеОтчетамиУХ.ЗаписатьПроцедуруРасчета(СтруктураПараметров);
	
	Возврат Сред(ТекстФормулы,4);
	
КонецФункции // ЗаполнитьФормулуРасчетаПоказателяПоУмолчанию()
	
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С НАСТРОЙКАМИ


Функция ИнициализироватьТаблицуКонтроляЛимитов() Экспорт
	
	ТабличноеПолеЛимиты = Новый ТаблицаЗначений;
	
	ТабличноеПолеЛимиты.Колонки.Добавить("ПорядковыйНомер"       , ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(1, 0));
	ТабличноеПолеЛимиты.Колонки.Добавить("КонтролируемоеЗначение", ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(100));
	ТабличноеПолеЛимиты.Колонки.Добавить("Контролировать",         ОбщегоНазначенияУХ.ПолучитьОписаниеТиповБулево());
	ТабличноеПолеЛимиты.Колонки.Добавить("ВидОтклонения",          ОбщегоНазначенияУХ.ПолучитьОписаниеТиповБулево());
	ТабличноеПолеЛимиты.Колонки.Добавить("Значение",               ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(15, 2));
	
	НоваяСтрока = ТабличноеПолеЛимиты.Добавить();
	НоваяСтрока.КонтролируемоеЗначение = Нстр("ru = 'Остатки денежных средств'");
	НоваяСтрока.ПорядковыйНомер        = 1;
	
	НоваяСтрока = ТабличноеПолеЛимиты.Добавить();
	НоваяСтрока.КонтролируемоеЗначение = Нстр("ru = 'Планы ДДС'");
	НоваяСтрока.ПорядковыйНомер        = 2;
	
	НоваяСтрока = ТабличноеПолеЛимиты.Добавить();
	НоваяСтрока.КонтролируемоеЗначение = "Взаиморасчеты";
	НоваяСтрока.ПорядковыйНомер        = 3;
	
	ТабличноеПолеЛимиты.ЗаполнитьЗначения(Ложь, "Контролировать, ВидОтклонения");
	ТабличноеПолеЛимиты.ЗаполнитьЗначения(0   , "Значение");
	
	Возврат ТабличноеПолеЛимиты;
	
КонецФункции
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С COM/OLE

// Функция, которая создает COM/OLE соединение с сервером и записывает в таблицу
// подключений. Если запись о соединении уже есть в таблице, возвращает суще-
// ствующее значение.
// Параметры:
//  ТаблицаПодключений - Таблица значений, таблица, в которой хранится информация о
//                    подключениях.
//  ВИБ             - Справочники.ВнешниеИнформационныеБазы.Ссылка, Элемент справочника внешних
//                    информационных баз, по данным из которого создается соединение.
//  ТипПодключения  - Перечисление, указывает по какой технологии подключаться к 
//                    серверу. (OLE или COM)
// Возвращаемое значение:
// 	- COMОбъект, в котором хранится подключение к серверу.
//
Функция ПолучитьСоединение(ТаблицаПодключений=Неопределено, ВИБ, ТипПодключения, ПроверкаСоединения = Ложь) Экспорт
	
	//Если ВИБ = Неопределено Тогда
	//	Возврат Неопределено;
	//КонецЕсли;
	//
	//Если НЕ ВИБ.ИспользоватьWS Тогда
	//	Если ТипПодключения = Неопределено Тогда
	//		Возврат Неопределено;
	//	Иначе
	//		Использование77 = ВИБ.ТипБД.ВерсияПлатформы  = Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие77;
	//	КонецЕсли;
	//Иначе
	//	Использование77 = Ложь;
	//	ТипПодключения = 2; // Подключение по Web-сервису.
	//КонецЕсли;
	//
	//Если Использование77 Тогда
	//	ТипПодключения = 0;
	//КонецЕсли;
	//
	//Если ТаблицаПодключений = Неопределено Тогда
	//	ТаблицаПодключений = Новый ТаблицаЗначений;
	//	ТаблицаПодключений.Колонки.Добавить("ВИБ");
	//	ТаблицаПодключений.Колонки.Добавить("COMСоединение");
	//	ТаблицаПодключений.Колонки.Добавить("ТипПодключения");
	//	ТаблицаПодключений.Колонки.Добавить("ВремяПоследнегоПодключения");
	//	ТаблицаПодключений.Индексы.Добавить("ВИБ, ТипПодключения");
	//КонецЕсли;
	//
	//СтрокиТаблицы = ТаблицаПодключений.НайтиСтроки(Новый Структура("ВИБ, ТипПодключения", ВИБ, ТипПодключения));
	//Если СтрокиТаблицы.Количество() >0 И Не ПроверкаСоединения Тогда
	//	Соединение = СтрокиТаблицы[0].COMСоединение;
	//	СтрокиТаблицы[0].ВремяПоследнегоПодключения = ТекущаяДата();
	//	Возврат Соединение;
	//Иначе
	//	Если ВИБ.ИспользоватьWS Тогда
	//		
	//	//	WSПрокси = ПолучитьСоединениеПоWebСервису(ВИБ);
	//		
	//		Если WSПрокси = Неопределено Тогда
	//			Возврат НЕопределено;
	//		КонецЕсли;
	//		
	//		Если Не ПроверкаСоединения Тогда
	//			
	//			СтрокаТаблицы = ТаблицаПодключений.Добавить();
	//			СтрокаТаблицы.ВИБ = ВИБ;
	//			СтрокаТаблицы.COMСоединение = WSПрокси;
	//			СтрокаТаблицы.ТипПодключения = ТипПодключения;
	//			СтрокаТаблицы.ВремяПоследнегоПодключения = ТекущаяДата();
	//			Возврат СтрокаТаблицы.COMСоединение;
	//		Иначе
	//			Сообщить("Соединение с Web-сервисом " + ВИБ.Наименование + " прошло успешно");
	//			Возврат Неопределено;
	//		КонецЕсли;
	//		
	//	Иначе
	//		
	//		Если ПустаяСтрока(ВИБ) Тогда
	//			СообщитьОбОшибке("При попытке соедиения с COM-сервером ИБ произошла следующая ошибка:" + Символы.ПС
	//			+ "Не указана внешняя информационная база.");
	//			Возврат Неопределено;
	//		КонецЕсли;
	//		
	//		// Очистим кэш полученных ранее из ВИБ COM - объектов
	//		
	//		#Если Клиент ИЛИ ВнешнееСоединение Тогда
	//			
	//			СтруктураПоиска=Новый Структура("ВИБ,ТипПодключения",ВИБ,ТипПодключения);
	//			МассивУстаревшихЗначений=ОбщегоНазначенияУХ.ПолучитьЗначениеПеременной("глКэшЗначенийЭлементовВИБ").НайтиСтроки(СтруктураПоиска);
	//			
	//			Для Каждого СтрУстаревшееЗначение ИЗ МассивУстаревшихЗначений Цикл
	//				ОбщегоНазначенияУХ.ПолучитьЗначениеПеременной("глКэшЗначенийЭлементовВИБ").Удалить(СтрУстаревшееЗначение);
	//			КонецЦикла;
	//			
	//		#КонецЕсли
	//		
	//		СтрокаОшибки = "При попытке соедиения с COM-сервером ИБ " + ВИБ.Наименование + " произошла следующая ошибка:" + Символы.ПС;
	//		
	//		Если ПустаяСтрока(ВИБ.ТипБД)Тогда
	//			СообщитьОбОшибке(СтрокаОшибки + "Не указан тип внешней информационной базы.");
	//			Возврат Неопределено;
	//		КонецЕсли;
	//		Если ПустаяСтрока(ВИБ.ТипБД.ВерсияПлатформы)Тогда
	//			СообщитьОбОшибке(СтрокаОшибки + "Не указан тип платформы у элемента справочника Тип внешних информационных баз");
	//			Возврат Неопределено;
	//		КонецЕсли;
	//		
	//		ФайловыйРежим   = ВИБ.РазмещениеВнешнейИБ <> Перечисления.ВидыРазмещенияИБ.КлиентСерверный;
	//		
	//		
	//		Если ФайловыйРежим ИЛИ Использование77 Тогда
	//			СтрокаПодключения = ?(Использование77, "/D""", "File=""") + СокрЛП(ВИБ.КаталогИБ) + """";
	//		Иначе
	//			СтрокаПодключения = "Srvr = """ + СокрЛП(ВИБ.ИмяСервера) + """; Ref = """ + СокрЛП(ВИБ.ИмяИБНаСервере) + """";
	//		КонецЕсли;
	//		
	//		Если Не ВИБ.АутентификацияWindows Тогда
	//			Если НЕ ПустаяСтрока(ВИБ.Пользователь) Тогда
	//				СтрокаПодключения = СтрокаПодключения + ?(Использование77, " /N""", ";Usr = """) + СокрЛП(ВИБ.Пользователь) + """";
	//			КонецЕсли;
	//			Если НЕ ПустаяСтрока(ВИБ.Пароль) Тогда
	//				СтрокаПодключения = СтрокаПодключения + ?(Использование77, " /P""", ";Pwd = """) + СокрЛП(ВИБ.Пароль) + """";
	//			КонецЕсли;
	//		КонецЕсли;
	//		
	//		ИспользоватьCOMКоннектор = Истина;
	//		
	//		Если  ВИБ.ТипБД.ВерсияПлатформы = Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие8 Тогда
	//			ОбъектПодключения = "V8";
	//		ИначеЕсли  ВИБ.ТипБД.ВерсияПлатформы = Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие81 Тогда
	//			ОбъектПодключения = "V81";
	//		ИначеЕсли  ВИБ.ТипБД.ВерсияПлатформы = Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие82 Тогда
	//			ОбъектПодключения = "V82";
	//		ИначеЕсли  ВИБ.ТипБД.ВерсияПлатформы = Перечисления.ПлатформыВнешнихИнформационныхБаз.Предприятие83 Тогда
	//			ОбъектПодключения = "V83";
	//		ИначеЕсли ВИБ.ТипБД.ВерсияПлатформы = Перечисления.ПлатформыВнешнихИнформационныхБаз.ADO Тогда
	//			ОбъектПодключения = ВИБ.СтрокаПодключения;
	//			ИспользоватьCOMКоннектор = Ложь;
	//		Иначе
	//			ОбъектПодключения = "V77";
	//			Если ВИБ.РазмещениеВнешнейИБ = Перечисления.ВидыРазмещенияИБ.ЛокальнаяВерсия Тогда
	//				ОбъектПодключения = ОбъектПодключения + "L";
	//			ИначеЕсли ВИБ.РазмещениеВнешнейИБ = Перечисления.ВидыРазмещенияИБ.КлиентСерверный Тогда
	//				ОбъектПодключения = ОбъектПодключения + "S";
	//			КонецЕсли;
	//		КонецЕсли;
	//		
	//		Попытка
	//			#Если Клиент Тогда
	//				Состояние("Соединение с ИБ " + ВИБ.Наименование + "...");
	//			#КонецЕсли
	//			Если НЕ ИспользоватьCOMКоннектор Тогда
	//				ТекCOMОбъект = Новый COMОбъект("ADODB.Connection");
	//				ТекCOMОбъект.Open(ОбъектПодключения);
	//			ИначеЕсли  ТипПодключения = 0 Тогда
	//				ОбъектПодключения = ОбъектПодключения +".Application";
	//				ТекCOMОбъект = Новый COMОбъект(ОбъектПодключения);
	//				Если Использование77 Тогда
	//					Если ТекCOMОбъект.Initialize(ТекCOMОбъект.RMTrade, СтрокаПодключения, "NO_SPLASH_SHOW") = 0 Тогда
	//						ВызватьИсключение("Ошибка при подключении к приложению 1С:Предприятие 7.7");
	//					КонецЕсли;
	//				Иначе
	//					ТекCOMОбъект.Connect(СтрокаПодключения);
	//				КонецЕсли;
	//			Иначе
	//				ОбъектПодключения = ОбъектПодключения +".COMConnector";
	//				ТекCOMПодключение = Новый COMОбъект(ОбъектПодключения);
	//				ТекCOMОбъект = ТекCOMПодключение.Connect(СтрокаПодключения);
	//			КонецЕсли;
	//			
	//			#Если Клиент Тогда
	//				Состояние("Соединение установлено");
	//				Состояние();
	//			#КонецЕсли
	//			
	//			Если Не ПроверкаСоединения Тогда
	//				СтрокаТаблицы = ТаблицаПодключений.Добавить();
	//				СтрокаТаблицы.ВИБ = ВИБ;
	//				СтрокаТаблицы.COMСоединение = ТекCOMОбъект;
	//				СтрокаТаблицы.ТипПодключения = ТипПодключения;
	//				СтрокаТаблицы.ВремяПоследнегоПодключения = ТекущаяДата();
	//				Возврат СтрокаТаблицы.COMСоединение;
	//			Иначе
	//				Сообщить("Соединение с COM-сервером ИБ " + ВИБ.Наименование + " прошло успешно");
	//				Возврат Неопределено;
	//			КонецЕсли;
	//			
	//		Исключение
	//			
	//			СообщитьОбОшибке(СтрокаОшибки + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	//			#Если Клиент Тогда
	//				Состояние("Соединение установить не удалось");
	//				Состояние();
	//			#КонецЕсли
	//			ОбновитьПовторноИспользуемыеЗначения();
	//			
	//			Возврат Неопределено;
	//				
	//		КонецПопытки;
	//		
	//	КонецЕсли;
	//	
	//КонецЕсли;
	//
КонецФункции

Функция ПолучитьСоединениеСВИБПоУмолчанию(ТипБД,ТипПодключения) Экспорт
	
	Если ЗначениеЗаполнено(ТипБД.ВИБПоУмолчанию) Тогда
		
		База = РасширениеИнтеграцииУХ.ПолучитьСоединение(ТипБД.ВИБПоУмолчанию, ТипПодключения);
					
		Возврат База;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;		
	
КонецФункции // ПолучитьСоединениеСВИБПоУмолчанию()

Функция ПолучитьСписокВИБПоТипу(ТипБД) Экспорт
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	ВнешниеИнформационныеБазы.Ссылка
	|ИЗ
	|	Справочник.ВнешниеИнформационныеБазы КАК ВнешниеИнформационныеБазы
	|ГДЕ
	|	ВнешниеИнформационныеБазы.ТипБД = &ТипБД";
	
	Запрос.УстановитьПараметр("ТипБД",ТипБД);
	
	СписокБаз=Новый СписокЗначений;
	СписокБаз.ЗагрузитьЗначения(Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка"));
	
	Возврат СписокБаз;
		
КонецФункции // ПолучитьСписокВИБПоТипу()
	
// Функция для определения наличия соединения в таблице для данной записи
// справочника.
// Параметры:
//  ТаблицаПодключений - Таблица значений, таблица, в которой хранится информация о
//                     подключениях.
//  ВИБ             - Справочники.ВнешниеИнформационныеБазы.Ссылка, Элемент справочника внешних
//                  информационных баз, по данным из которого создается соединение.
// Возвращаемое значение:
//  Строка, в которой указана технология подключения. Если подключения нет, то Неопределено
//
Функция ОпределитьНаличиеСоединения(ТаблицаПодключений=Неопределено, ВИБ) Экспорт
	
	ТипСоединения = Неопределено;
	Если НЕ (ТаблицаПодключений = Неопределено или ВИБ = Неопределено) Тогда
		СтрокиТаблицы = ТаблицаПодключений.НайтиСтроки(Новый Структура("ВИБ", ВИБ));
		Если СтрокиТаблицы.Количество()>0 Тогда
			
			Если СтрокиТаблицы[0].ТипПодключения = 0 Тогда
				ТипСоединения = "OLE";
			ИначеЕсли СтрокиТаблицы[0].ТипПодключения = 2 Тогда
				ТипСоединения = "WEB";
			Иначе
				ТипСоединения = "COM";
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат ТипСоединения;
	
КонецФункции

// Процедура сбрасывает существующие подключения для указанного элемента из справочника
// Параметры:
//  ТаблицаПодключений - Таблица значений, таблица, в которой хранится информация о
//                     подключениях.
//  ВИБ             - Справочники.ВнешниеИнформационныеБазы.Ссылка, Элемент справочника внешних
//                  информационных баз, по данным из которого создается соединение.
//
Процедура СброситьСуществующиеПодключения(ТаблицаПодключений=Неопределено, ВИБ) Экспорт
	Если НЕ (ТаблицаПодключений = Неопределено или ВИБ = Неопределено) Тогда
		СтрокиТаблицы = ТаблицаПодключений.НайтиСтроки(Новый Структура("ВИБ", ВИБ));
		Для Каждого Элемент Из СтрокиТаблицы Цикл
			ТаблицаПодключений.Удалить(Элемент);
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры


// Процедура сбрасывает существующие подключения для которых время простоя превысило
// указываемый интервал в секундах.
// Параметры:
//  ТаблицаПодключений - Таблица значений, таблица, в которой хранится информация о
//                     подключениях.
//  Интервал        - Число, интервал в секундах, при превышении которого происходит разрыв
//                  соединения.
//
Процедура СброситьСоединенияПоТаймАуту(ТаблицаПодключений, Интервал) Экспорт
	Если НЕ (ТаблицаПодключений = Неопределено ИЛИ Тип(Интервал) <> Тип("Число")) Тогда
		Инд = 0;
		Пока Инд<ТаблицаПодключений.Количество() Цикл
			ВремяРаботы = ТекущаяДата() - ТаблицаПодключений[Инд].ВремяПоследнегоПодключения;
			Если ВремяРаботы >= Интервал Тогда
				ТаблицаПодключений[Инд].Удалить();
			Иначе
				Инд = Инд + 1;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры	

///////////////////////////////////////////////////////////////////////////////
//
// ФУНКЦИИ ПРЕОБРАЗОВАНИЯ ИМЕН.

//Функция кэширует поля и их синонимы
Функция ПолучитьСинонимПоля(Поле) Экспорт
	
	//СтруктураВозврата = мСоответствиеПолей[Поле];
	//
	//Если СтруктураВозврата = Неопределено Тогда
	//	
	//	СтруктураВозврата = Синоним(Поле);
	//	мСоответствиеПолей.Вставить(Поле,СтруктураВозврата);
	//	
	//КонецЕсли;
	
	//Возврат СтруктураВозврата;
	Возврат Синоним(Поле);
	
КонецФункции

Функция НайтиСлово(Парам) 
	
	Возвр = "";
	ПредСимвол = "";    
	ПредВерхнийРегистр = Ложь;
	Смещение = 0;
	
	СтрДлина = СтрДлина(Парам);
	Сч = 1;
	
	Пока Сч<=СтрДлина Цикл
		
		Символ = Сред(Парам,сч,1);
		ВерхнийРегистр = (Символ = ВРег(Символ));
		
		Если Возвр = "" Тогда
			// Первый символ
			Возвр =  Символ;
		ИначеЕсли Символ = "_" Тогда
			// если разделитель то остаток должен быть без разделителя
			Смещение = 1;
			Прервать;
		ИначеЕсли КодСимвола(Символ)<58 Тогда
			// если цифра
			Если КодСимвола(ПредСимвол)<58 Тогда
				// если предыдущий символ тоже цифра - продолжаем слово
				Возвр = Возвр + Символ;
			Иначе
				Прервать;
			КонецЕсли;
		ИначеЕсли ВерхнийРегистр и НЕ ПредВерхнийРегистр или (КодСимвола(Символ)>57 и КодСимвола(ПредСимвол)<58) Тогда
			// если заглавная буква и предыдущая маленькая 
			// или буква после цифры
			Прервать;
		ИначеЕсли НЕ ВерхнийРегистр И ПредВерхнийРегистр И Сч>2 Тогда
			// если встретили маленькую после большой и это не второй символ
			Возвр = Лев(Возвр,Сч-2);
			Прервать;
		Иначе
			Возвр = Возвр + Символ;
		КонецЕсли;
		
		Сч = Сч + 1;
		
		ПредСимвол = Символ;
		ПредВерхнийРегистр = ВерхнийРегистр;
	КонецЦикла;
	
	Парам = Прав(Парам,СтрДлина - СтрДлина(Возвр)-Смещение); 
	Возврат Возвр;
	
КонецФункции

//Возвращает синоним для параметра
Функция Синоним(Парам) Экспорт
	
	Возвр = "";
	Стр = Парам;
	
	Слово = НайтиСлово(Стр);
	
	Пока Слово <> "" Цикл
		Если Возвр = "" Тогда
			// первое слово - как есть
			Возвр = Слово;
		ИначеЕсли ВРЕГ(Слово) = Слово И СтрДлина(Слово)>1 Тогда
			// если 2 и более заглавных - считаем аббревиатурой
			Возвр = Возвр + " " + Слово;
		Иначе
			// иначе - обычное слово с маленькой буквы
			Возвр = Возвр + " " + НРЕГ(Слово); 
		КонецЕсли;
		
		Слово = НайтиСлово(Стр);
	КонецЦикла;
	
	Возврат Возвр;
КонецФункции

// Функция проверяет, является ли Символ алфавитно-цифровым и если является, возвращает символ
// иначе пустой символ.
// Параметры:
//  Символ         - Строка, Символ для проверки.
// Результат:
//  Строка, Символ, если он алфавитноцифровой, иначе пустая строка.
Функция ПроверитьНаПравильностьСимвол(Символ)
	СтрокаЭталон = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
	Возврат ?(СтрНайти(СтрокаЭталон, ВРег(Символ)) = 0, "", Символ);
КонецФункции

Функция УдалитьИзСтрокиЗарезервированныеСлова(ЗНАЧ РедактируемыйТекст,ИмяСправочника="") Экспорт
	
	ТекстПроверка=СтрЗаменить(РедактируемыйТекст," ","");
	
	Если НЕ УправлениеОтчетамиУХ.СтрокаМожетИспользоватьсяВКачествеКода(Лев(ТекстПроверка,1)) Тогда
		
		РедактируемыйТекст=?(ПустаяСтрока(ИмяСправочника),"Э",Лев(ИмяСправочника,1))+РедактируемыйТекст;
		
	КонецЕсли;
		
	РедактируемыйТекст = СтрЗаменить(РедактируемыйТекст, "Строка", "СТРК");
	РедактируемыйТекст = СтрЗаменить(РедактируемыйТекст, "Колонка", "КЛНК");
	РедактируемыйТекст = СтрЗаменить(РедактируемыйТекст, "Показатель", "ПКЗ");
	РедактируемыйТекст = СтрЗаменить(РедактируемыйТекст, "Аналитика", "АНЛТ");
	
	Возврат РедактируемыйТекст;
	
КонецФункции
// Функция формирует код на основании наименования.
//
Функция СформироватьКодНаОснованииНаименования(Вн_Наименование,Знач ДлинаКода=0,ИмяСправочника="",Владелец=Неопределено) Экспорт
	
	Наименование = УдалитьИзСтрокиЗарезервированныеСлова(Вн_Наименование,ИмяСправочника);
	
	ТаблицаСлов=Новый ТаблицаЗначений;
	ТаблицаСлов.Колонки.Добавить("Слово");
	ТаблицаСлов.Колонки.Добавить("ПорядокСлова");
	ТаблицаСлов.Колонки.Добавить("ДлинаСлова");
	ТаблицаСлов.Колонки.Добавить("ЧастьСлова");
	ТаблицаСлов.Колонки.Добавить("ДлинаЧастиСлова");
	
	Если ДлинаКода=0 Тогда
		
		Если ПустаяСтрока(ИмяСправочника) Тогда
			ДлинаКода=20;
		Иначе	
			ДлинаКода=Метаданные.Справочники[ИмяСправочника].ДлинаКода;
		КонецЕсли;
		
	КонецЕсли;
	
	ТекБуфер = "";
	ЗаполнениеСлова = Ложь;
	ПорядокСлова=1;
	
	Для Инд = 1 По СтрДлина(Наименование) Цикл
		ТекСимвол = ПроверитьНаПравильностьСимвол(Сред(Наименование, Инд, 1));
		Если ПустаяСтрока(ТекСимвол) Тогда
			Если ЗаполнениеСлова Тогда
				Если НЕ ПустаяСтрока(ТекБуфер) Тогда
					
					НоваяСтрока=ТаблицаСлов.Добавить();
					НоваяСтрока.Слово=ТекБуфер;
					НоваяСтрока.ДлинаСлова=СтрДлина(ТекБуфер);
					НоваяСтрока.ПорядокСлова=ПорядокСлова;
					
					ПорядокСлова=ПорядокСлова+1;
					
				КонецЕсли;
				ЗаполнениеСлова = Ложь;
				ТекБуфер = "";
				
			КонецЕсли;
		Иначе
			Если НЕ ЗаполнениеСлова Тогда
				ЗаполнениеСлова = Истина;
			КонецЕсли;
			
			ТекБуфер = ТекБуфер + ТекСимвол;
		КонецЕсли;
		
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(ТекБуфер) Тогда
		НоваяСтрока=ТаблицаСлов.Добавить();
		НоваяСтрока.Слово=ТекБуфер;
		НоваяСтрока.ДлинаСлова=СтрДлина(ТекБуфер);
		НоваяСтрока.ПорядокСлова=ПорядокСлова;
	КонецЕсли;
	
	Если ТаблицаСлов.Количество()=0 Тогда
		Возврат "";
	КонецЕсли;
	
	СредДлина=Окр(ДлинаКода/ТаблицаСлов.Количество(),0,РежимОкругления.Окр15как10);
	ОсталосьСимволов=ДлинаКода;
	
	ТаблицаСлов.Сортировать("ДлинаСлова");
	
	Для Индекс=1 По ТаблицаСлов.Количество() Цикл
		
		ТекСлово=ТаблицаСлов[Индекс-1];
		
		Если ТекСлово.ДлинаСлова<СредДлина Тогда 	// Свободный остаток от слова, 
			//длина которых меньше текущего среднего, передается на последующие слова.
			
			ТекСлово.ЧастьСлова=ТекСлово.Слово;

		Иначе
			
			ТекСлово.ЧастьСлова=Лев(ТекСлово.Слово,СредДлина);
			
		КонецЕсли;
		
		ОсталосьСимволов=ОсталосьСимволов-СтрДлина(ТекСлово.ЧастьСлова);
		
		Если НЕ Индекс=ТаблицаСлов.Количество() Тогда
			
			СредДлина=Окр(ОсталосьСимволов/(ТаблицаСлов.Количество()-Индекс),0,РежимОкругления.Окр15как10);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТаблицаСлов.Сортировать("ПорядокСлова");
	
	ТекКод = "";
	
	Для Каждого Слово ИЗ ТаблицаСлов Цикл
		
		ТекКод=ТекКод+ВРЕГ(ЛЕВ(Слово.ЧастьСлова,1))+Сред(Слово.ЧастьСлова,2);
		
	КонецЦикла;
	
	ПроектКода=ОбщегоНазначенияУХ.ВернутьАлфавитноЦифровоеПредставление(ТекКод);
	
	Если ПустаяСтрока(ИмяСправочника) Тогда
		Возврат ПроектКода;
	Иначе
		Возврат ПолучитьВозможныйКодСправочника(ПроектКода,ДлинаКода,ИмяСправочника,Владелец);
	КонецЕсли;
	
КонецФункции

Функция ПолучитьВозможныйКодСправочника(Знач ПроектКода, Знач ДлинаКода, ИмяСправочника, Владелец = Неопределено) Экспорт
	
	ПРОТОКОЛИРУЕМОЕ_СОБЫТИЕ = "ОбщийМодуль.ОбщегоНазначенияУХ.ПолучитьВозможныйКодСправочника";
	
	ПроектКода=ВернутьАлфавитноЦифровоеПредставление(ПроектКода);	
	
	Если ЗначениеЗаполнено(ПроектКода) Тогда
		Если ЗначениеЗаполнено(Владелец) Тогда
			Если НЕ ЗначениеЗаполнено(Справочники[ИмяСправочника].НайтиПоКоду(ПроектКода,,,Владелец)) Тогда
				Возврат ПроектКода;
			КонецЕсли;
		Иначе
			Если НЕ ЗначениеЗаполнено(Справочники[ИмяСправочника].НайтиПоКоду(ПроектКода)) Тогда
				Возврат ПроектКода;
			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ПроектКода) Тогда
		Возврат "";
	КонецЕсли;
	
	Если ДлинаКода = 0 Тогда
		ДлинаКода = Метаданные.Справочники[ИмяСправочника].ДлинаКода;
		Если ДлинаКода = 0 Тогда
			Возврат "";
		КонецЕсли;
	КонецЕсли;
	
	Код = СокрЛП(ПроектКода);
	Код = СтрЗаменить(ПроектКода, " ", "");
	
	КодСимвола0 = КодСимвола(0);
	КодСимвола9 = КодСимвола(9);
	
	СтрДлинаКод = СтрДлина(Код);
	
	Если СтрДлинаКод > 0 Тогда
		КодПоследнегоСимвола = КодСимвола(Код, СтрДлинаКод);
		Если КодСимвола0 <= КодПоследнегоСимвола И КодПоследнегоСимвола <= КодСимвола9 Тогда
			Код = Код + "_";
			СтрДлинаКод = СтрДлинаКод + 1;
		КонецЕсли;
	КонецЕсли;
	
	Пробелы = СтрЗаменить(Формат(0, "ЧЦ=" + Формат(ДлинаКода, "ЧГ=") + "; ЧН=; ЧВН=; ЧГ="), "0", " ");
	
	Запрос = Новый Запрос;
	
	ТекстЗапроса =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Т.Код КАК Код,
	|	ВЫБОР";
	
	ТекстУсловия = "";
	ТекстФункции = "";
	
	МаксимальнаяРазрядность = Мин(ДлинаКода, 5); // = ДлинаКода;
	
	ШаблонЧисла = "";
	Для Индекс = -МаксимальнаяРазрядность По -1 Цикл
		
		Разрядность = МаксимальнаяРазрядность + Индекс + 1;
		
		ИмяПараметра = "Префикс" + Формат(Разрядность, "ЧГ=");
		ШаблонЧисла = ШаблонЧисла + "[0-9]";
		
		ДлинаНачалаШаблона = Мин(ДлинаКода - Разрядность, СтрДлинаКод);
		НачалоШаблона = Лев(Код, ДлинаНачалаШаблона);
		Если ДлинаНачалаШаблона > 0 Тогда
			КодПоследнегоСимвола = КодСимвола(НачалоШаблона, ДлинаНачалаШаблона);
			Если КодСимвола0 <= КодПоследнегоСимвола И КодПоследнегоСимвола <= КодСимвола9 Тогда
				НачалоШаблона = Лев(НачалоШаблона, ДлинаНачалаШаблона - 1) + "_";
			КонецЕсли;
		КонецЕсли;
		
		Запрос.УстановитьПараметр(ИмяПараметра, НачалоШаблона + ШаблонЧисла + Лев(Пробелы, ДлинаКода - СтрДлина(НачалоШаблона) - Разрядность));
		
		ТекстФункции = "
		|		КОГДА Т.Код ПОДОБНО &" + ИмяПараметра + " ТОГДА " + Формат(Разрядность, "ЧГ=") + ТекстФункции;
		
		ТекстУсловия = ТекстУсловия + "
		|		ИЛИ Т.Код ПОДОБНО &" + ИмяПараметра;
		
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапроса + ТекстФункции;
	
	ИмяПараметра = "Префикс0";
	
	Запрос.УстановитьПараметр(ИмяПараметра, Лев(Код, Мин(ДлинаКода, СтрДлинаКод)));
	
	ТекстЗапроса = ТекстЗапроса + "
	|		КОГДА Т.Код = &" + ИмяПараметра + " ТОГДА 0
	|		ИНАЧЕ NULL
	|	КОНЕЦ КАК Разрядность
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Т
	|ГДЕ";
	
	Если ЗначениеЗаполнено(Владелец) Тогда
		
		Запрос.УстановитьПараметр("Владелец",Владелец);
		ТекстЗапроса = ТекстЗапроса + "
		|	Т.Владелец = &Владелец
		|	И";
	КонецЕсли;
	
	ТекстЗапроса = ТекстЗапроса + " 
		|	(Т.Код = &Префикс0
		|" + ТекстУсловия + ")";
		
	ТекстЗапроса = ТекстЗапроса + "
	|
	|УПОРЯДОЧИТЬ ПО
	|	Разрядность УБЫВ,
	|	Код УБЫВ";
	
	Запрос.Текст = ТекстЗапроса;
	
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		Код = Лев(Код, Мин(ДлинаКода, СтрДлинаКод));
	Иначе
		
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		
		Если Выборка.Разрядность = 0 Тогда
			Номер = "1";
		Иначе
			
			Номер = Число(Прав(СокрП(Выборка.Код), Выборка.Разрядность)) + 1;
			
			Если Номер = 1 ИЛИ Цел(Log10(Номер - 1)) = Цел(Log10(Номер)) Тогда
				Номер = Формат(Номер, "ЧЦ=" + Формат(Выборка.Разрядность, "ЧГ=") + "; ЧВН=; ЧГ=");
			Иначе
				Номер = Формат(Номер, "ЧЦ=" + Формат(Выборка.Разрядность + 1, "ЧГ=") + "; ЧВН=; ЧГ=");
			КонецЕсли;
			
		КонецЕсли;
		
		НачалоКода = Лев(Код, Мин(ДлинаКода - СтрДлина(Номер), СтрДлинаКод));
		Если НЕ НачалоКода = "" Тогда
			ДлинаНачалоКода = СтрДлина(НачалоКода);
			КодПоследнегоСимвола = КодСимвола(НачалоКода, ДлинаНачалоКода);
			Если КодСимвола0 <= КодПоследнегоСимвола И КодПоследнегоСимвола <= КодСимвола9 Тогда
				НачалоКода = Лев(НачалоКода, ДлинаНачалоКода - 1) + "_";
			КонецЕсли;
		КонецЕсли;
		
		Код = НачалоКода + Номер;
		
	КонецЕсли;
	
	Возврат Код;
	
КонецФункции // ПолучитьВозможныйКодСправочника() 

Функция ПолучитьВозможныйКодПВХ(ПроектКода,Знач ДлинаКода,ИмяПВХ) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ПланыВидовХарактеристик[ИмяПВХ].НайтиПоКоду(ПроектКода)) Тогда
		Возврат ПроектКода;
	КонецЕсли;
	
	Если ДлинаКода=0 Тогда
		
		Если ПустаяСтрока(ИмяПВХ) Тогда
			ДлинаКода=20;
		Иначе
			ДлинаКода=Метаданные.ПланыВидовХарактеристик[ИмяПВХ].ДлинаКода;
		КонецЕсли;
		
	КонецЕсли;
	
	Если СтрДлина(СокрЛП(ПроектКода)) - ДлинаКода < -2 Тогда
		ТекПрефикс2 = СокрЛП(ПроектКода);
		ТекПрефикс3 = СокрЛП(ПроектКода);
	Иначе
		ТекПрефикс2 = Лев(СокрЛП(ПроектКода), ДлинаКода - 2);
		ТекПрефикс3 = Лев(СокрЛП(ПроектКода), ДлинаКода - 3);
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	ТекстЗапроса = "ВЫБРАТЬ
	|	ТекПВХ.Код КАК Код,
	|	ВЫБОР
	|		КОГДА ТекПВХ.Код ПОДОБНО &Префикс3
	|			ТОГДА 3
	|		ИНАЧЕ 2
	|	КОНЕЦ КАК РазрядностьНомера
	|ИЗ
	|	ПланВидовХарактеристик."+ИмяПВХ+" КАК ТекПВХ
	|ГДЕ
	|(ТекПВХ.Код ПОДОБНО &Префикс2
	|			ИЛИ ТекПВХ.Код ПОДОБНО &Префикс3)";
	
	ТекстЗапроса=ТекстЗапроса+"
	|УПОРЯДОЧИТЬ ПО
	|	РазрядностьНомера УБЫВ,
	|	Код УБЫВ";
	
	Запрос.УстановитьПараметр("Префикс2" , ТекПрефикс2 + "[0-9][0-9]%");
	Запрос.УстановитьПараметр("Префикс3" , ТекПрефикс3 + "[0-9][0-9][0-9]%");
	
	Запрос.Текст=ТекстЗапроса;
	
	Результат= Запрос.Выполнить().Выбрать();
	
	Если НЕ Результат.Следующий() Тогда
		Код = ТекПрефикс2 + "01";
		Возврат Код;
	КонецЕсли;
	
	МаксЗапись  = Результат.Код;
	
	Если ЗначениеЗаполнено(МаксЗапись) Тогда
		
		ТекРазрядностьНомера=Результат.РазрядностьНомера;
		МаксЗапись    = СокрЛП(МаксЗапись);
		ЧисловаяЧасть = Прав(МаксЗапись, ТекРазрядностьНомера);
		
		Попытка
			МаксЗначение = Число(ЧисловаяЧасть);
			
			НовоеЗначение=МаксЗначение+1;
			Если НовоеЗначение>=100 Тогда
				
				ТекРазрядностьНомера=3;
				
			КонецЕсли;
			
			Код = Лев(МаксЗапись, СтрДлина(МаксЗапись) - ТекРазрядностьНомера) + Формат(НовоеЗначение, "ЧЦ="+ТекРазрядностьНомера+"; ЧВН=");
		Исключение
			Код = Лев(МаксЗапись, СтрДлина(МаксЗапись) - ТекРазрядностьНомера) + ?(ТекРазрядностьНомера=2,"01","001");
		КонецПопытки;
		
	Иначе
		
		Код = ТекПрефикс2 + "01";
		
	КонецЕсли;
	
	Возврат Код;
	
КонецФункции // ПолучитьВозможныйКодПВХ()

////////////////////////////////////////////////////////////////////////////////
//
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ СОБЫТИЙ ИНТЕРФЕЙСА.

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОбъекта(ИмяРеквизита, Объект) Экспорт
	
	Возврат ?(Объект=Неопределено,Ложь,ЕстьРеквизитОбъектаМД(ИмяРеквизита,Объект.Метаданные()));
	
КонецФункции // ЕстьРеквизитДокумента()

// Возвращает состояние использования элемента состава общего реквизита.
//
// Параметры:
//  ЭлементСостава            - ОбъектМетаданных - элемент состава общего реквизита, использование которого требуется
//                                                 проверить.
//  МетаданныеОбщегоРеквизита - ОбъектМетаданных - объект метаданных общего реквизита, которому принадлежит
//                                                 ЭлементСостава.
//
// Возвращаемое значение:
//  Булево - Истина, если элемент состава используется, иначе Ложь.
//
Функция ЭлементСоставаОбщегоРеквизитаИспользуется(Знач ЭлементСостава, Знач МетаданныеОбщегоРеквизита) Экспорт
	
	Если ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать Тогда
		Возврат Истина;
	ИначеЕсли ЭлементСостава.Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.НеИспользовать Тогда
		Возврат Ложь;
	Иначе
		Возврат МетаданныеОбщегоРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать;
	КонецЕсли;
	
КонецФункции

Функция ЕстьТабличнаяЧастьОбъекта(ИмяТЧ, Объект) Экспорт
	
	Возврат НЕ (Объект=Неопределено ИЛИ Объект.Метаданные().ТабличныеЧасти.Найти(ИмяТЧ) = Неопределено);
	
КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли среди реквизитов объекта метаданных
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОбъектаМД(ИмяРеквизита, ОбъектМД) Экспорт
	
	// Реквизиты
	ЕстьРеквизит=НЕ (ОбъектМД.Реквизиты.Найти(ИмяРеквизита) = Неопределено);
	
	Если НЕ ЕстьРеквизит И ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ОбъектМД, "СтандартныеРеквизиты") Тогда
		// Стандартные реквизиты
		Для Каждого Реквизит ИЗ ОбъектМД.СтандартныеРеквизиты Цикл
			
			Если Реквизит.Имя=ИмяРеквизита Тогда
				ЕстьРеквизит=Истина;
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	Если Не ЕстьРеквизит Тогда
		//Поищем среди общих реквизитов.
		ОбщийРеквизит = Метаданные.ОбщиеРеквизиты.Найти(ИмяРеквизита);
		Если ОбщийРеквизит <> Неопределено Тогда
			ЭлементСоставаОбщегоРеквизита = ОбщийРеквизит.Состав.Найти(ОбъектМД);
			Если ЭлементСоставаОбщегоРеквизита <> Неопределено Тогда
				Если ЭлементСоставаОбщегоРеквизитаИспользуется(ЭлементСоставаОбщегоРеквизита, ОбщийРеквизит) Тогда
					ЕстьРеквизит = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Возврат ЕстьРеквизит;
	
КонецФункции // ЕстьРеквизитОбъектаМД()

// Позволяет определить есть ли среди реквизитов объекта метаданных
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ПолучитьРеквизитОбъектаМД(ИмяРеквизита, ОбъектМД) Экспорт
	
	Для Каждого Реквизит ИЗ ОбъектМД.Реквизиты Цикл
		
		Если Реквизит.Имя=ИмяРеквизита Тогда
			
			Возврат Реквизит;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Стандартные реквизиты
	Для Каждого Реквизит ИЗ ОбъектМД.СтандартныеРеквизиты Цикл
		
		Если Реквизит.Имя=ИмяРеквизита Тогда
			
			Возврат Реквизит;
			
		КонецЕсли;
		
	КонецЦикла;
	
	//Общие реквизиты
	Для каждого Реквизит Из Метаданные.ОбщиеРеквизиты Цикл
		
		Если НЕ Реквизит.Имя=ИмяРеквизита Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ИспользованиеРеквизита = Реквизит.Content.Find(ОбъектМД.Имя);
		АвтоИспользование = (Реквизит.AutoUse = Метаданные.ObjectProperties.CommonAttributeAutoUse.Use);
		
		Если ИспользованиеРеквизита.Use = Метаданные.ObjectProperties.CommonAttributeUse.DontUse Тогда
			Продолжить;				
		ИначеЕсли НЕ АвтоИспользование И (ИспользованиеРеквизита.Use = Метаданные.ObjectProperties.CommonAttributeUse.Auto) Тогда 
			Продолжить;
		КонецЕсли;
		
		Возврат Реквизит;
		
	КонецЦикла;

	Возврат Неопределено;
	
КонецФункции // ПолучитьРеквизитОбъектаМД()


// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Источник - структура шапки или ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа
//
Функция ПредставлениеДокументаПриПроведении(Источник) Экспорт
	
	Если ТипЗнч(Источник) = Тип("Структура") Тогда
		ПредставлениеДокумента = Источник.ПредставлениеДокумента;
		Если Источник.Свойство("ВидОперации") Тогда
			ПредставлениеДокумента = ПредставлениеДокумента + " (" + Источник.ВидОперации + ")";
		КонецЕсли; 
	Иначе
		МетаданныеДокумента = Источник.Метаданные();
		ВидОперацииСтр = "";
		Если МетаданныеДокумента.Реквизиты.Найти("ВидОперации") <> Неопределено Тогда
			ВидОперацииСтр = " (" + Источник.ВидОперации + ")";
		КонецЕсли;
		ПредставлениеДокумента = СокрЛП(Источник) + ВидОперацииСтр;
	КонецЕсли; 
	
	ПредставлениеДокумента = СтрШаблон(Нстр("ru = 'Проведение документа: %1'"), ПредставлениеДокумента);
	
	Возврат ПредставлениеДокумента;
	
КонецФункции // ПредставлениеДокументаПриПроведении

Процедура НаследоватьРеквизитПоРодителю(Объект,ИмяРеквизита,ЗначениеПоУмолчанию=Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(Объект[ИмяРеквизита]) Тогда
		Возврат;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Объект.Родитель) И ЗначениеЗаполнено(Объект.Родитель[ИмяРеквизита]) Тогда
		
		Объект[ИмяРеквизита]=Объект.Родитель[ИмяРеквизита];
		
	Иначе
		
		Объект[ИмяРеквизита]=ЗначениеПоУмолчанию;
		
	КонецЕсли;
		
КонецПроцедуры // НаследоватьРеквизитПоРодителю() 

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

// Функция разбирает строку вида
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//  МетаданныеОбъекта - Объект метаданных
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, МетаданныеОбъекта = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = СтрНайти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = СтрНайти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если МетаданныеОбъекта <> Неопределено Тогда
		Структура.Вставить("Метаданные", МетаданныеОбъекта);
	Иначе
		Если Структура.ТипОбъекта = "Документ" Тогда
			Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
		ИначеЕсли Структура.ТипОбъекта = "ПланВидовХарактеристик" Тогда
			Структура.Вставить("Метаданные", Метаданные.ПланыВидовХарактеристик[Структура.ВидОбъекта]);
		Иначе
			Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
	
	#Если Клиент Тогда
		
		ПоказатьПредупреждение(, ТекстСообщения);
		
	#Иначе
		
		ВызватьИсключение(ТекстСообщения);
		
	#КонецЕсли
	
КонецПроцедуры // ПредупреждениеОбОшибке()

////////////////////////////////////////////////////////////////////////////////
// СИСТЕМНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ 

Функция СоздатьИсточникДанныхПоПараметрам(СтруктураПараметров) Экспорт
	
	ОбъектИсточник=Справочники.ИсточникиДанныхДляРасчетов.СоздатьЭлемент();
	
	ОбъектИсточник.НазначениеРасчетов		= СтруктураПараметров.НазначениеРасчетов;
	ОбъектИсточник.ПотребительРасчета		= СтруктураПараметров.ПотребительРасчета;
	ОбъектИсточник.ТипБД					= СтруктураПараметров.ТипБД;
	ОбъектИсточник.СпособИспользования		= СтруктураПараметров.СпособИспользования;
	ОбъектИсточник.СпособПолучения			= СтруктураПараметров.СпособПолучения;
	
	Если СтруктураПараметров.СпособПолучения=Перечисления.СпособыПолученияОперандов.ВнешниеДанныеРегистр
		ИЛИ СтруктураПараметров.СпособПолучения=Перечисления.СпособыПолученияОперандов.ВнешниеДанныеРегистрНакопления Тогда
		
		ОбъектИсточник.ЗаполнитьНачальныеНастройки();
					
			ИмяРегистраВИБ=СтруктураПараметров.ИмяРегистраВИБ;
			ДанныеРегистра=Справочники.РегистрыНакопленияБД.НайтиПоНаименованию(ИмяРегистраВИБ,Истина,,ОбъектИсточник.ТипБД);
			
			Если НЕ ЗначениеЗаполнено(ДанныеРегистра) Тогда
				
				ОбщегоНазначенияУХ.ЗаполнитьСписокРегистровБД(ОбъектИсточник.ТипБД,,,Истина);
				ДанныеРегистра=Справочники.РегистрыНакопленияБД.НайтиПоНаименованию(ИмяРегистраВИБ,Истина,,ОбъектИсточник.ТипБД);
				
			КонецЕсли;
			
			ОбъектИсточник.РегистрБД=ДанныеРегистра;				
		
		Если Не ЗначениеЗаполнено(ОбъектИсточник.РегистрБД) Тогда
			СообщитьОбОшибке(СтрШаблон(Нстр("ru = 'При создании источника данных для расчетов %1
			|произошла ошибка: не удалось получить информацию по регистру накопления %2.'"), 
			                 	ОбъектИсточник.Наименование, ИмяРегистраВИБ),,,СтатусСообщения.Важное);
			
			Возврат Ложь;
		КонецЕсли;
		
		Если ОбъектИсточник.РегистрБД.Измерения.Количество()=0 Тогда
			
			РегистрОбъект=ОбъектИсточник.РегистрБД.ПолучитьОбъект();
			РегистрОбъект.ЗаполнитьРеквизитыОбъекта();
			РегистрОбъект.Записать();
			
		КонецЕсли;
		
		ОбъектИсточник.ЗаполнитьИзмеренияРегистраБД(Ложь);
				
		// Получим список ресурсов регистра для формирования текста запроса
		
		ОбъектИсточник.СписокРесурсовРегистра=Новый СписокЗначений;
		
		Для Каждого СтрРесурс ИЗ ОбъектИсточник.РегистрБД.Ресурсы Цикл
						
			ОбъектИсточник.СписокРесурсовРегистра.Добавить(СтрРесурс.Имя,СтрРесурс.Синоним);
			
		КонецЦикла;
		
		ОбъектИсточник.СформироватьТаблицуСоответствияБД();
		ОбъектИсточник.ДеревоПолейБД=ОбъектИсточник.ЗаполнитьДеревоЗначенийБД();
		
		ОбъектИсточник.ВидИтога=СтруктураПараметров.ВидИтога;
		ОбъектИсточник.РесурсРегистра=СтруктураПараметров.РесурсРегистра;
		
		// Определение сопоставленных аналитик
		
		ТаблицаСоответствия=СтруктураПараметров.ТаблицаСоответствия;
				
		// Определим поля, сопоставленные с аналитикой отчета
		
		СтрРеквизитыОтчета=ОбъектИсточник.ТаблицаСоответствияБД.НайтиСтроки(Новый Структура("АналитикаОтчета",Истина));
		
		Для Каждого Строка ИЗ СтрРеквизитыОтчета.Строки Цикл
			
			Строка.ПолеБД			="";
			Строка.ПсевдонимВИБ			="";
			Строка.СправочникБД		="";
			Строка.ТипМетаДанных		="";
			Строка.НастройкаСоответствия="";
			Строка.ПолеЗапроса			="";
			Строка.Сопоставлено			=Ложь;
			
		КонецЦикла;
		
		МассивАналитикиОтчета=ТаблицаСоответствия.НайтиСтроки(Новый Структура("АналитикаОтчета,Сопоставлено",Истина,Истина));
		
		Для Каждого СтрАналитика ИЗ МассивАналитикиОтчета Цикл
			
			СтрСопоставлено=СтрРеквизитыОтчета.Строки.Найти(СтрАналитика.АналитикаКонсолидации,"АналитикаКонсолидации");
			
			Если Не СтрСопоставлено=Неопределено Тогда
				
				ЗаполнитьЗначенияСвойств(СтрСопоставлено,СтрАналитика);
				СтрСопоставлено.Сопоставлено = Истина;
				
			КонецЕсли;
			
		КонецЦикла;
		
		// Определим поля, сопоставленные с аналитикой показателя
		
		СтрАналитикаПоказателя=ОбъектИсточник.ТаблицаСоответствияБД.НайтиСтроки(Новый Структура("АналитикаОтчета",Ложь));
		
		Если Не СтрАналитикаПоказателя=Неопределено Тогда
			
			Для Каждого Строка ИЗ СтрАналитикаПоказателя.Строки Цикл
				
				Строка.ПолеБД			="";
				Строка.ПсевдонимВИБ			="";
				Строка.СправочникБД		="";
				Строка.ТипМетаДанных		="";
				Строка.НастройкаСоответствия="";
				Строка.ПолеЗапроса			="";
				Строка.Сопоставлено			=Ложь;
				
			КонецЦикла;
			
			МассивАналитикиПоказателя=ТаблицаСоответствия.НайтиСтроки(Новый Структура("АналитикаОтчета,Сопоставлено",Ложь,Истина));
			
			Для Каждого СтрАналитика ИЗ МассивАналитикиПоказателя Цикл
				
				СтрСопоставлено=СтрАналитикаПоказателя.Строки.Найти(СтрАналитика.ПолеБД,"ПолеБД");
				Если Не СтрСопоставлено=Неопределено Тогда
					
					ЗаполнитьЗначенияСвойств(СтрСопоставлено,СтрАналитика);
					СтрСопоставлено.Сопоставлено = Истина;
					
				Иначе
					
					НоваяСтрока=СтрАналитикаПоказателя.Строки.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрАналитика);
					
					Если СтрНайти(СтрАналитика.ПолеБД,".")>0 Тогда
						
						НоваяСтрока=ОбъектИсточник.мТаблицаПроизводныхБД.Добавить();
						ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрАналитика);
						НоваяСтрока.ПолеБД=СтрАналитика.ПолеБД;
						НоваяСтрока.НаименованиеБД=СтрАналитика.ПсевдонимВИБ;
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
		ОбъектИсточник.ТаблицаПараметровОтбораБД=СтруктураПараметров.ТаблицаПараметровОтбораБД;
		
	КонецЕсли;
	
	ОбъектИсточник.мМодифицированность=Истина;
	ОбъектИсточник.СохранитьНастройкиОперанда();
	
	Если СтруктураПараметров.Свойство("ТекстЗапросаМадуля") Тогда
		ОбъектИсточник.ТекстЗапросаМодуля=СтруктураПараметров.ТекстЗапросаМодуля;
	КонецЕсли;
	
	Попытка
		ОбъектИсточник.Записать();
		Возврат ОбъектИсточник.Ссылка;
	Исключение
		ТекстСообщения = НСтр("ru = 'Не удалось записать источник данных %ОбъектИсточник%
                              |		%ОписаниеОшибки%'");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОбъектИсточник%", Строка(ОбъектИсточник));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОбъектИсточник%", ОписаниеОшибки());
		ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
		Возврат Справочники.ИсточникиДанныхДляРасчетов.ПустаяСсылка();
	КонецПопытки;	
	
КонецФункции // СоздатьИсточникДанныхПоПараметрам()

Функция ПолучитьШаблонНастроекИсточникаДанных() Экспорт
	
	мОписаниеТиповСтрока=ПолучитьОписаниеТиповСтроки(255);
	мОписаниеТиповБулево=ПолучитьОписаниеТиповБулево();
	
	СтруктураНастроек=Новый Структура;
	СтруктураНастроек.Вставить("Наименование");
	СтруктураНастроек.Вставить("НазначениеРасчетов");
	СтруктураНастроек.Вставить("ПотребительРасчета");
	СтруктураНастроек.Вставить("СпособПолучения");
	СтруктураНастроек.Вставить("СпособИспользования");
	СтруктураНастроек.Вставить("ПоказательОтбор");
	СтруктураНастроек.Вставить("ТипБД");
	СтруктураНастроек.Вставить("ИмяРегистраВИБ");
	СтруктураНастроек.Вставить("РесурсРегистра");
	СтруктураНастроек.Вставить("ВидИтога");
	
	ПравилаИспользованияПолей=Новый ТаблицаЗначений;
	ПравилаИспользованияПолей.Колонки.Добавить("Поле"							,мОписаниеТиповСтрока);
	ПравилаИспользованияПолей.Колонки.Добавить("Синоним"						,мОписаниеТиповСтрока);
	ПравилаИспользованияПолей.Колонки.Добавить("РеквизитАналитики"				,мОписаниеТиповСтрока);
	ПравилаИспользованияПолей.Колонки.Добавить("ТаблицаАналитики"				,мОписаниеТиповСтрока);
	ПравилаИспользованияПолей.Колонки.Добавить("ТаблицаАналитикиВИБ"			,мОписаниеТиповСтрока);
	ПравилаИспользованияПолей.Колонки.Добавить("АналитикаОперанда"				,ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСсылка("ПланВидовХарактеристикСсылка.ВидыСубконтоКорпоративные"));	
	ПравилаИспользованияПолей.Колонки.Добавить("СоздаватьНовые"					,мОписаниеТиповБулево);
	ПравилаИспользованияПолей.Колонки.Добавить("РазделятьПоОрганизациям"		,мОписаниеТиповБулево);
	ПравилаИспользованияПолей.Колонки.Добавить("ОбновлятьРеквизитыПриИмпорте"	,мОписаниеТиповБулево);
	ПравилаИспользованияПолей.Колонки.Добавить("НеИспользоватьДляСинхронизации"	,мОписаниеТиповБулево);
	ПравилаИспользованияПолей.Колонки.Добавить("КодАналитики"					,мОписаниеТиповСтрока);
	ПравилаИспользованияПолей.Колонки.Добавить("НастройкаСоответствия"			,ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСсылка("СправочникСсылка.СоответствиеВнешнимИБ"));
	
	СтруктураНастроек.Вставить("ПравилаИспользованияПолейЗапроса",ПравилаИспользованияПолей);
	
	ТаблицаПараметровОтбораБД=Новый ТаблицаЗначений;
	ТаблицаПараметровОтбораБД.Колонки.Добавить("ПолеБД"						,мОписаниеТиповСтрока);
	ТаблицаПараметровОтбораБД.Колонки.Добавить("НаименованиеБД"				,мОписаниеТиповСтрока);
	ТаблицаПараметровОтбораБД.Колонки.Добавить("СпособВычисленияПараметра"	,ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСсылка("ПеречислениеСсылка.СпособыВычисленияПараметровОперандов"));
	ТаблицаПараметровОтбораБД.Колонки.Добавить("УточнениеСпособаОпределения");
	ТаблицаПараметровОтбораБД.Колонки.Добавить("ЗначениеДляПроверки");
	ТаблицаПараметровОтбораБД.Колонки.Добавить("ТипРасчета"					,мОписаниеТиповСтрока);
	ТаблицаПараметровОтбораБД.Колонки.Добавить("Реквизит"					,мОписаниеТиповСтрока);
	ТаблицаПараметровОтбораБД.Колонки.Добавить("СмещениеПериода"			,ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(3));
	ТаблицаПараметровОтбораБД.Колонки.Добавить("НастройкаСоответствия"		,ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСсылка("СправочникСсылка.СоответствиеВнешнимИБ"));

	СтруктураНастроек.Вставить("ТаблицаПараметровОтбораБД",ТаблицаПараметровОтбораБД);
	
	ТаблицаСоответствия = Новый ТаблицаЗначений;
	ТаблицаСоответствия.Колонки.Добавить("АналитикаКонсолидации"				,мОписаниеТиповСтрока);
	ТаблицаСоответствия.Колонки.Добавить("ПолеБД"							,мОписаниеТиповСтрока);
	ТаблицаСоответствия.Колонки.Добавить("ПсевдонимКонсолидации"				,мОписаниеТиповСтрока);
	ТаблицаСоответствия.Колонки.Добавить("ПсевдонимВИБ"							,мОписаниеТиповСтрока);
	ТаблицаСоответствия.Колонки.Добавить("СправочникБД"						,мОписаниеТиповСтрока);
	ТаблицаСоответствия.Колонки.Добавить("ТипМетаДанных"						,мОписаниеТиповСтрока);
	ТаблицаСоответствия.Колонки.Добавить("СправочникКонсолидации"				,мОписаниеТиповСтрока);	
	ТаблицаСоответствия.Колонки.Добавить("НастройкаСоответствия"				,ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСсылка("СправочникСсылка.СоответствиеВнешнимИБ"));	
	ТаблицаСоответствия.Колонки.Добавить("Измерение"							,мОписаниеТиповБулево);
	ТаблицаСоответствия.Колонки.Добавить("Дебетовый"							,мОписаниеТиповБулево);
	ТаблицаСоответствия.Колонки.Добавить("Сопоставлено"							,мОписаниеТиповБулево);
	ТаблицаСоответствия.Колонки.Добавить("АналитикаОтчета"						,мОписаниеТиповБулево);
	ТаблицаСоответствия.Колонки.Добавить("ПолеЗапроса"							,мОписаниеТиповСтрока);
	ТаблицаСоответствия.Колонки.Добавить("ВидСубконто"							,ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСсылка("ПланВидовХарактеристикСсылка.ВидыСубконтоКорпоративные"));
	
	СтруктураНастроек.Вставить("ТаблицаСоответствия",ТаблицаСоответствия);
	
	Возврат СтруктураНастроек;
	
КонецФункции // ПолучитьШаблонНастроекИсточникаДанных()

// Определяет наличие в базе данных операндов, получающих данные из отчета
// по параметрам НазначениеРасчетовВход, ПотребительРасчетаВход, ПоказательОтборВход, 
// СпособИспользованияВход. Возвращает массив структур, содержащих коды таких
// операндов и ссылки на показатели, из которых берутся исходные данные.
Функция ОпределитьНаличиеАналогичныхОперандов(НазначениеРасчетовВход, ПотребительРасчетаВход, ПоказательОтборВход, СпособИспользованияВход) Экспорт
	РезультатФункции = Новый Массив;
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ИсточникиДанныхДляРасчетов.Код,
	|	РеквизитыИсточниковДанныхДляФормул.КодУпрощеннойФормулы,
	|	ИсточникиДанныхДляРасчетов.ПоказательОтбор
	|ИЗ
	|	Справочник.ИсточникиДанныхДляРасчетов КАК ИсточникиДанныхДляРасчетов
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.РеквизитыИсточниковДанныхДляФормул КАК РеквизитыИсточниковДанныхДляФормул
	|		ПО ИсточникиДанныхДляРасчетов.Ссылка = РеквизитыИсточниковДанныхДляФормул.ИсточникДанных
	|ГДЕ
	|	ИсточникиДанныхДляРасчетов.НазначениеРасчетов = &НазначениеРасчетов
	|	И НЕ ИсточникиДанныхДляРасчетов.ПометкаУдаления
	|	И ИсточникиДанныхДляРасчетов.ПотребительРасчета = &ПотребительРасчета
	|	И ИсточникиДанныхДляРасчетов.СпособПолучения = &СпособПолучения
	|	И ИсточникиДанныхДляРасчетов.СпособИспользования = &СпособИспользования
	|	И ИсточникиДанныхДляРасчетов.ПоказательОтбор В(&ПоказательОтбор)";
	Запрос.УстановитьПараметр("НазначениеРасчетов",		 НазначениеРасчетовВход);
	Запрос.УстановитьПараметр("ПотребительРасчета",		 ПотребительРасчетаВход);
	Запрос.УстановитьПараметр("ПоказательОтбор",		 ПоказательОтборВход);
	Запрос.УстановитьПараметр("СпособПолучения",		 Перечисления.СпособыПолученияОперандов.ВнутренниеДанныеПоказательОтчета);
	Запрос.УстановитьПараметр("СпособИспользования",	 СпособИспользованияВход);
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СтруктураРезультата = Новый Структура;
		СтруктураРезультата.Вставить("КодСуществующегоОперанда", СокрЛП(Выборка.Код));
		СтруктураРезультата.Вставить("КодУпрощеннойФормулы", СокрЛП(Выборка.КодУпрощеннойФормулы));
		СтруктураРезультата.Вставить("ПоказательОтбор", Выборка.ПоказательОтбор);
		РезультатФункции.Добавить(СтруктураРезультата);
	КонецЦикла;
	Возврат РезультатФункции;
КонецФункции

Функция СоздатьИсточникДанных(СтруктураДанных) Экспорт
	
	Если СтруктураДанных.Свойство("ТекстПоказатель") Тогда
		
		ТекстПоказатель=СтрЗаменить(СтруктураДанных.ТекстПоказатель,"Показатели.","");
		КодПоказателя=ОбщегоНазначенияУХ.ДополнитьДоЗаданнойДлины(ТекстПоказатель,Метаданные.Справочники.ПоказателиОтчетов.ДлинаКода);
		ИсхПоказатель=Справочники.ПоказателиОтчетов.НайтиПоКоду(КодПоказателя,,,СтруктураДанных.ВидОтчета);
		
	ИначеЕсли СтруктураДанных.Свойство("ИсхПоказатель") Тогда
		
		ИсхПоказатель=СтруктураДанных.ИсхПоказатель;
		КодПоказателя=СтруктураДанных.ИсхПоказатель.Код;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
		
	Если ИсхПоказатель=Справочники.ПоказателиОтчетов.ПустаяСсылка() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПоказательОтбор=ИсхПоказатель;
	
	Если НЕ СтруктураДанных.ЕстьАналогичныйПоказатель Тогда
		
		// Проверим наличие и при необходимости создадим новый операнд
		ТекНазначениеРасчетов = СтруктураДанных.НазначениеРасчетов;
		ТекПотребительРасчета = СтруктураДанных.ПотребительРасчета;
		ТекСпособИспользования = СтруктураДанных.СпособИспользования;
		МассивАналогичных = ОпределитьНаличиеАналогичныхОперандов(ТекНазначениеРасчетов, ТекПотребительРасчета, ПоказательОтбор, ТекСпособИспользования);
		Если МассивАналогичных.Количество() > 0 Тогда
			ПерваяЗаписьАналогичных = МассивАналогичных[0];
			СтруктураДанных.ЕстьАналогичныйПоказатель = Истина;
			СтруктураДанных.КодСуществующегоОперанда = ПерваяЗаписьАналогичных.КодСуществующегоОперанда;
			СтруктураДанных.Вставить("КодУпрощеннойФормулы", ПерваяЗаписьАналогичных.КодУпрощеннойФормулы);
			СтруктураДанных.ПоказательОтбор = ПерваяЗаписьАналогичных.ПоказательОтбор;
			Возврат Ложь;
		Иначе
			// Нет аналогичных. Не изменяем структуру.
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтруктураДанных.КодСуществующегоОперанда) Тогда
		
		УправлениеОтчетамиУХ.ОчиститьЗаписиРегистраПараметрическихНастроек(СтруктураДанных.НазначениеРасчетов);
		
		Элемент=Справочники.ИсточникиДанныхДляРасчетов.СоздатьЭлемент();
		Элемент.НазначениеРасчетов=СтруктураДанных.НазначениеРасчетов;
		
		Если СтруктураДанных.СпособИспользования=Перечисления.СпособыИспользованияОперандов.ДляКонтрольныхСоотношений
			ИЛИ СтруктураДанных.СпособИспользования=Перечисления.СпособыИспользованияОперандов.ДляФормулРасчета
			ИЛИ СтруктураДанных.СпособИспользования=Перечисления.СпособыИспользованияОперандов.ДляПримечаний Тогда
			
			Элемент.ТипБД=СтруктураДанных.НазначениеРасчетов.ТипБД;
			
		КонецЕсли;
		
		Элемент.ПотребительРасчета=СтруктураДанных.ПотребительРасчета;
		Элемент.ПоказательОтбор=ПоказательОтбор;
		Элемент.СпособИспользования = СтруктураДанных.СпособИспользования;
		Элемент.Наименование   = ?(ПустаяСтрока(СокрЛП(ПоказательОтбор.Владелец.ПолноеНаименование)),СокрЛП(ПоказательОтбор.Владелец.Наименование),(СокрЛП(ПоказательОтбор.Владелец.ПолноеНаименование)))+"\стр."+ПоказательОтбор.Строка.ПорядковыйНомер+"\гр."+ПоказательОтбор.Колонка.ПорядковыйНомер; 
		Элемент.СпособПолучения=?(ТипЗнч(ПоказательОтбор.Владелец)=Тип("СправочникСсылка.ШаблоныТрансформационныхКорректировок"),Перечисления.СпособыПолученияОперандов.ПроводкаТрансформационнойКорректировки,Перечисления.СпособыПолученияОперандов.ВнутренниеДанныеПоказательОтчета);
		
		Элемент.ПодготовитьТаблицыСопоставленийИОтборов();

		Элемент.СохранитьНастройкиОперанда();
			
		Если Не СтруктураДанных.СдвигПериодов=0 Тогда
			
			Элемент.УстановитьОтбор("Версия.ПериодОтчета",Перечисления.СпособыВычисленияПараметровОперандов.ПериодОтчетаСоСдвигом,СтруктураДанных.СдвигПериодов);
			СтрокаПериод = Элемент.ДеревоПараметровОтбораБД.Строки.Найти("Версия.ПериодОтчета", "ПолеБД");
							
		КонецЕсли;
		
		ТекКод = ОбщегоНазначенияУХ.ВернутьАлфавитноЦифровоеПредставление(СокрЛП(ПоказательОтбор.Владелец.Код) + "_" + СокрЛП(Элемент.ПоказательОтбор.Код));
		Элемент.СформироватьВозможныйКодОперанда(ТекКод);
				
		Попытка
						
			Элемент.Записать();
			
			Если НЕ (СтруктураДанных.СпособИспользования = Перечисления.СпособыИспользованияОперандов.ДляПримечаний
				ИЛИ СтруктураДанных.СпособИспользования = Перечисления.СпособыИспользованияОперандов.ДляОбратногоРаспределения) Тогда
				
				СтруктураДанных.ВставитьТекстВФормулу=Истина;
				
			КонецЕсли;
			
			СтруктураДанных.Вставить("КодОперанда", СокрЛП(Элемент.Код));
			СтруктураДанных.Вставить("КодУпрощеннойФормулы",СокрЛП(Элемент.КодУпрощеннойФормулы));
			Возврат Истина;
			
		Исключение
			
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
		
	Иначе
		
		СтруктураДанных.Вставить("КодОперанда", СокрЛП(СтруктураДанных.КодСуществующегоОперанда));
		Возврат Истина;
		
	КонецЕсли;
	
	
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ДЛЯ ВЕРСИИ 8.2.
//

// Функция формирует массив имен регистров, по которым документ имеет движения.
// Вызывается при подготовке записей к регистрации движений.
//
Функция ПолучитьМассивИспользуемыхРегистров(Регистратор, Движения, МассивИсключаемыхРегистров = Неопределено) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Регистратор", Регистратор);

	Результат = Новый Массив;
	МаксимумТаблицВЗапросе = 256;

	СчетчикТаблиц   = 0;
	СчетчикДвижений = 0;

	ВсегоДвижений = Движения.Количество();
	ТекстЗапроса  = "";
	Для Каждого Движение Из Движения Цикл

		СчетчикДвижений = СчетчикДвижений + 1;

		ПропуститьРегистр = МассивИсключаемыхРегистров <> Неопределено
							И МассивИсключаемыхРегистров.Найти(Движение.Имя) <> Неопределено;

		Если Не ПропуститьРегистр Тогда

			Если СчетчикТаблиц > 0 Тогда

				ТекстЗапроса = ТекстЗапроса + "
				|ОБЪЕДИНИТЬ ВСЕ
				|";

			КонецЕсли;

			СчетчикТаблиц = СчетчикТаблиц + 1;

			ТекстЗапроса = ТекстЗапроса + 
			"
			|ВЫБРАТЬ ПЕРВЫЕ 1
			|""" + Движение.Имя + """ КАК ИмяРегистра
			|
			|ИЗ " + Движение.ПолноеИмя() + "
			|
			|ГДЕ Регистратор = &Регистратор
			|";

		КонецЕсли;

		Если СчетчикТаблиц = МаксимумТаблицВЗапросе Или СчетчикДвижений = ВсегоДвижений Тогда

			Запрос.Текст  = ТекстЗапроса;
			ТекстЗапроса  = "";
			СчетчикТаблиц = 0;

			Если Результат.Количество() = 0 Тогда

				Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ИмяРегистра");

			Иначе

				Выборка = Запрос.Выполнить().Выбрать();
				Пока Выборка.Следующий() Цикл
					Результат.Добавить(Выборка.ИмяРегистра);
				КонецЦикла;

			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции


// Добавляет в список значений значения из другого списка значений
//
// Параметры:
//  СписокИсточник - список значений, откуда берутся значения.
//  СписокПриемник - список значений, куда добавляются значения.
//
Процедура ЗагрузитьВСписокЗначений(СписокИсточник, СписокПриемник,ОчищатьПриемник=Истина) Экспорт
	
	Если ОчищатьПриемник Тогда
		СписокПриемник.Очистить();
	КонецЕсли;
	
	Для Каждого Элемент ИЗ СписокИсточник Цикл
		
		СписокПриемник.Добавить(Элемент.Значение,Элемент.Представление,Элемент.Пометка,Элемент.Картинка);
		
	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьВСписокЗначенний() 
////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции 

// Проверяет проведенность документов
// Параметры
//  Документы - массив - документы, проведенность которых необходимо проверить
// Возвращаемое значение
//  Массив - непроведенные документы из массива Документы
//
Функция ПроверитьПроведенностьДокументов(знач Документы) Экспорт
	
	ТекстЗапроса = "ВЫБРАТЬ
		|	Документ.Ссылка КАК Ссылка
		|ИЗ
		|	Документ.[ИмяДокумента] КАК Документ
		|ГДЕ
		|	Документ.Ссылка В (&МассивДокументов)
		|	И Не Документ.Проведен";
	
	ИмяДокумента = СтроковыеФункцииКлиентСерверУХ.РазложитьСтрокуВМассивПодстрок(
		Документы[0].Метаданные().ПолноеИмя(), ".")[1];
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяДокумента]", ИмяДокумента);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("МассивДокументов", Документы);
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Процедура выполняет проведение документов перед формированием печатной формы.
//
// Параметры:
//	Документы - Массив - Документы, которые необходимо провести
//
// Возвращаемое значение:
//	Массив - документы, которые провести не удалось
//
Функция ПровестиДокументы(Документы, ТипПроведенныхДокументов) Экспорт
	
	ИмяДокумента = СтроковыеФункцииКлиентСерверУХ.РазложитьСтрокуВМассивПодстрок(
						Документы[0].Метаданные().ПолноеИмя(), ".")[1];
	
	ТипПроведенныхДокументов = ТипЗнч(Документы[0]);
	
	НепроведенныеДокументы = Новый Массив;
	
	Для Каждого ДокументСсылка Из Документы Цикл
		
		ДокументОбъект = ДокументСсылка.ПолучитьОбъект();
		
		ВыполненоУспешно = Ложь;
		
		Если ДокументОбъект.ПроверитьЗаполнение() Тогда
			Попытка
				ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
				ВыполненоУспешно = Истина;
			Исключение
				ПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
				ТекстСообщенияОбОшибке = НСтр("ru = 'Ошибка при попытке проведения документа: %1'");
				ТекстСообщенияОбОшибке = СтроковыеФункцииКлиентСерверУХ.ПодставитьПараметрыВСтроку(ТекстСообщенияОбОшибке, ПредставлениеОшибки);
				ЗаписьЖурналаРегистрации(Нстр("ru = 'Проведение документов при печати'"),
					УровеньЖурналаРегистрации.Информация,
					ДокументОбъект.Метаданные(),
					ДокументСсылка,
					ТекстСообщенияОбОшибке);
			КонецПопытки;
		КонецЕсли;
		
		Если Не ВыполненоУспешно Тогда
			НепроведенныеДокументы.Добавить(ДокументСсылка);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НепроведенныеДокументы;
	
КонецФункции 

// Функция возвращает ссылку на текущего пользователя базы данных,
// установленного по учетной записи пользователя конфигурации.
//
// Возвращаемое значение:
//  СправочникСсылка.Пользователи
//
Функция ТекущийПользователь() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат ПараметрыСеанса.ТекущийПользователь;
	
КонецФункции 

// Выполнить экспортную процедуру без параметров по имени.
//
// Параметры
//  ИмяЭкспортнойПроцедуры – Строка    – имя экспортной процедуры в формате 
//										 <имя объекта>.<имя процедуры>, где <имя объекта> - это
// 										 общий модуль или модуль менеджера объекта.
//
// Пример:
//  ВыполнитьБезопасно("МойОбщийМодуль.МояПроцедура"); 
//
Процедура ВыполнитьБезопасно(Знач ИмяЭкспортнойПроцедуры) Экспорт
	
	// Проверка предусловий на формат ИмяЭкспортнойПроцедуры.
	ЧастиИмени = СтроковыеФункцииКлиентСерверУХ.РазложитьСтрокуВМассивПодстрок(ИмяЭкспортнойПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСерверУХ.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;

	ИмяОбъекта = ЧастиИмени[0];
	Если (Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено)
 		И (Метаданные.Обработки.Найти(ИмяОбъекта) = Неопределено) 
 		И (Метаданные.Документы.Найти(ИмяОбъекта) = Неопределено) 
 		И (Метаданные.Справочники.Найти(ИмяОбъекта) = Неопределено)
 		И (Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) = Неопределено) Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСерверУХ.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неправильный формат параметра ИмяЭкспортнойПроцедуры (%1)'"),
			ИмяЭкспортнойПроцедуры);
	КонецЕсли;

	Выполнить ИмяЭкспортнойПроцедуры + "();";
	
КонецПроцедуры

// Устарела. Следует использовать функцию ОбщегоНазначения.ЗначенияРеквизитовОбъекта 
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	" + ИменаРеквизитов + "
		|ИЗ
		|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	Результат = Новый Структура(ИменаРеквизитов);
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Функция ПолучитьЗначениеРеквизита возвращает значение
// реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции 

// Объединяет две таблицы значений по условию "И".
// Возвращает таблицу значений, полученную в результате объединения двух таблиц по условию "И".
//
// Параметры:
//  Таблица1         - ТаблицаЗначений - первая таблица значений для объединения
//  Таблица2         - ТаблицаЗначений - вторая таблица значений для объединения
//  ПоляТаблицы      - Строка - поля таблицы, перечисленные через запятую, по которым будут выполнятся объединение
//  ИмяПоляИтератора - Строка - имя служебной колонки таблицы значений.
//                              Это имя должно быть уникально во множестве имен колонок первой и второй таблиц.
//                              Переменная ПоляТаблицы не должна содержать этого имени. 
//                              Значение по умолчанию "ИтераторПоляТаблицы"
// 
// Возвращаемое значение:
//  ТаблицаЗначений -  таблица значений, полученная в результате объединения двух таблиц по условию "И"
//
Функция ОбъединитьТаблицыПоУсловиюИ(Таблица1, Таблица2, Знач ПоляТаблицы, ИмяПоляИтератора = "ИтераторПоляТаблицы") Экспорт
	
	Таблица1.Свернуть(ПоляТаблицы);
	Таблица2.Свернуть(ПоляТаблицы);
	
	ДобавитьИтераторТаблице(Таблица1, +1, ИмяПоляИтератора);
	ДобавитьИтераторТаблице(Таблица2, -1, ИмяПоляИтератора);
	
	ТаблицаРезультат = Таблица1.Скопировать();
	
	ОбщегоНазначенияКлиентСерверУХ.ДополнитьТаблицу(Таблица2, ТаблицаРезультат);
	
	ТаблицаРезультат.Свернуть(ПоляТаблицы, ИмяПоляИтератора);
	
	ТаблицаРезультат = ТаблицаРезультат.Скопировать(Новый Структура(ИмяПоляИтератора, 0));
	
	ТаблицаРезультат.Колонки.Удалить(ИмяПоляИтератора);
	
	Возврат ТаблицаРезультат;
	
КонецФункции

// Получает имя значения перечисления как объекта метаданных
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт
	
	ОбъектМетаданных = Значение.Метаданные();
	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);
	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
	
КонецФункции 

// Добавляет колонку в таблицу значений. Заполняет колонку переданным значением
//
// Параметры:
//  Таблица           - ТаблицаЗначений - таблица значений для добавления колонки
//  ЗначениеИтератора - Произвольный - значение, которым будет заполнено новое поле таблицы
//  ИмяПоляИтератора  - Строка - имя добавляемого поля
// 
Процедура ДобавитьИтераторТаблице(Таблица, ЗначениеИтератора, ИмяПоляИтератора)
	
	Таблица.Колонки.Добавить(ИмяПоляИтератора);
	
	Таблица.ЗаполнитьЗначения(ЗначениеИтератора, ИмяПоляИтератора);
	
КонецПроцедуры

// Функция вычисляет кол-во временных таблиц в тексте запроса (создания и удаления)
Функция КолвоВременныхТаблицВТекстеПакетаЗапросов(ТекстЗапроса) Экспорт
	
	Если ТипЗнч(ТекстЗапроса) <> Тип("Строка") Тогда
		Возврат 0;
	КонецЕсли;
	
	Возврат СтрЧислоВхождений(ТекстЗапроса, Символы.ПС+"ПОМЕСТИТЬ ") + СтрЧислоВхождений(ТекстЗапроса, Символы.ПС+"УНИЧТОЖИТЬ ")
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтроковыеФункцииКлиентСерверУХ.РазложитьСтрокуВМассивПодстрок(
		СистемнаяИнфо.ВерсияПриложения, ".");
	Возврат "v" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
	
КонецФункции	

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат СтрНайти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Получить представление информационной базы для отображения пользователю.
//
// Возвращаемое значение:
//   Строка      - Представление информационной базы
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		ПутьКБД = Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	Иначе
		// надо к имени сервера прибавить имя пути информационной базы
		ПозицияПоиска = СтрНайти(Врег(СтрокаСоединенияСБД), "SRVR=");
		
		Если ПозицияПоиска <> 1 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
		НачальнаяПозицияКопирования = 6 + 1;
		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
		
		ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
		
		СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
		
		// позиция имени сервера
		ПозицияПоиска = СтрНайти(Врег(СтрокаСоединенияСБД), "REF=");
		
		Если ПозицияПоиска <> 1 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		НачальнаяПозицияКопирования = 6;
		ПозицияТочкиСЗапятой = СтрНайти(СтрокаСоединенияСБД, ";");
		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
		
		ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
		
		ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
		
	КонецЕсли;
	
	Возврат ПутьКБД;
	
КонецФункции

// Проверить, что описание типа состоит из единственного типа значения и 
// совпадает с нужным типом.
//
// Возвращаемое значение:
//   Булево      - Совпадает или нет
//
Функция ОписаниеТипаСостоитИзТипа(ОписаниеТипа, ТипЗначения) Экспорт
	
	Если ОписаниеТипа.Типы().Количество() = 1
	   И ОписаниеТипа.Типы().Получить(0) = ТипЗначения Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции

// Функция ПрочитатьXMLВТаблицу преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  ТекстXML     - текст формата XML.
//
// Возвращаемое значение:
//  ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(ТекстXML) Экспорт
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(ТекстXML);
	
	// Прочитаем первый узел и проверим его
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение(Нстр("ru = 'Пустой XML'"));
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение(Нстр("ru = 'Ошибка в структуре XML'"));
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение(Нстр("ru = 'Ошибка в структуре XML'"));
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Функция СохранитьФайлНаСервере перемещает двоичные данные из временного
// хранилища в файл на сервере (данные во временном хранилище удаляются).
//
// Параметры:
//  АдресВоВременномХранилище - адрес, указывающий на значение во временном хранилище.
//  ИмяФайла     - Строка, необязательный параметр,
//                 полное имя файла на сервере для сохранения двоичных данных.
//
// Возвращаемое значение:
//  Строка       - полное имя файла на сервере, в который сохранены двоичные данные.
//
Функция СохранитьФайлНаСервере(Знач АдресВоВременномХранилище, Знач ИмяФайла = Неопределено) Экспорт
	
	Если ИмяФайла = Неопределено Тогда
		ИмяФайла = ПолучитьИмяВременногоФайла();
	КонецЕсли;
	
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВоВременномХранилище);
	ДвоичныеДанные.Записать(ИмяФайла);
	
	УдалитьИзВременногоХранилища(АдресВоВременномХранилище);
	
	Возврат ИмяФайла;
	
КонецФункции // СохранитьФайлНаСервере()

// Получает таблицу значений с описанием требуемых свойств всех реквизитов объекта метаданного
// Получает значения свойств стандартных реквизитов и пользовательских реквизитов (созданных в режиме конфигуратора)
//
// Параметры:
//  ОбъектМетаданных  - Объект метаданных конфигурации, для которого необходимо получить значение свойств реквизитов.
//                      Например: Метаданные.Документ.РеализацияТоваровИУслуг
//  Свойства - Строка - свойства реквизитов, перечисленных через запятую, значение которых необходимо получить.
//                      Например: "Имя, Тип, Синоним, Подсказка"
//
// Возвращаемое значение:
//  ТаблицаЗначений - таблица значений с описанием требуемых свойств всех реквизитов объекта метаданного
//
Функция ПолучитьТаблицуОписанияСвойствОбъекта(ОбъектМетаданных, Свойства) Экспорт
	
	МассивСвойств = СтроковыеФункцииКлиентСерверУХ.РазложитьСтрокуВМассивПодстрок(Свойства);
	
	// возвращаемое значение функции
	ТаблицаОписанияСвойствОбъекта = Новый ТаблицаЗначений;
	
	// добавляем в таблицу поля согласно именам переданных свойств
	Для Каждого ИмяСвойства ИЗ МассивСвойств Цикл
		
		ТаблицаОписанияСвойствОбъекта.Колонки.Добавить(СокрЛП(ИмяСвойства));
		
	КонецЦикла;
	
	// заполняем строку таблицы свойствами реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.Реквизиты Цикл
		
		Если СтрНайти(Реквизит.Имя,"НСИ_")>0 Тогда
			Продолжить;
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
		
	КонецЦикла;
	
	// заполняем строку таблицы свойствами стандартных реквизитов объекта метаданных
	Для Каждого Реквизит ИЗ ОбъектМетаданных.СтандартныеРеквизиты Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаОписанияСвойствОбъекта.Добавить(), Реквизит);
		
	КонецЦикла;
	
	Возврат ТаблицаОписанияСвойствОбъекта;
	
КонецФункции

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: ТаблицаЗначений
//	Возвращаемое значение: Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

// Преобразует массив структур в таблицу значений.
// Все структуры должны содеражать одинаковые поля.
// Тип колонок устанавливается по значениям в массиве.
// Проверка полноты заполнения полей в структурах массива
// не производится.
//
// Параметры:
//  МассивСтруктур - Массив(Структура) - массив структур для преобразования.
// 
// Возвращаемое значение:
//   ТаблицаЗначений - колонки соотвествуют полям из самой первой структуры.
//		Строки заполнены созданы и заполнены из всех структур массива.
//
Функция МассивВТаблицуЗначений(МассивСтруктур) Экспорт
	ТЗ = Новый ТаблицаЗначений;
	Если МассивСтруктур.Количество() > 0 Тогда 
		ДобавитьКолонкиТаблицыЗначенийИзСтруктуры(ТЗ, МассивСтруктур);
		Для Каждого ЗначенияСтроки Из МассивСтруктур Цикл
			НоваяСтрока = ТЗ.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ЗначенияСтроки);
		КонецЦикла;
	КонецЕсли;
	Возврат ТЗ;
КонецФункции

// Процедура - Добавить колонки таблицы значений из структуры.
// Тип колонки - либо объединение типов значений в ней,
// либо, если значений нет, то это Число.
//
// Параметры:
//  Таблица - ТаблицаЗначений - таблица значений для добавления
//		колонок.
//  МассивСтруктур - Массив(Структура) - из нее берутся имена колонок.
//
Процедура ДобавитьКолонкиТаблицыЗначенийИзСтруктуры(
											Таблица, 
											МассивСтруктур) Экспорт
	ТипыКолонок = Новый Соответствие;
	Для Каждого ЗначенияСтроки Из МассивСтруктур Цикл
		Для Каждого Колонка Из ЗначенияСтроки Цикл
			Значение = Колонка.Значение;
			Если Значение <> Неопределено 
					И ЗначениеЗаполнено(Значение) Тогда
				ИмяКолонки = Колонка.Ключ;
				мТипов = ТипыКолонок[ИмяКолонки];
				Если мТипов = Неопределено Тогда
					мТипов = Новый Массив;
					ТипыКолонок[ИмяКолонки] = мТипов;
				КонецЕсли;
				мТипов.Добавить(ТипЗнч(Колонка.Значение));
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	Для Каждого Колонка Из МассивСтруктур[0] Цикл
		ИмяКолонки = Колонка.Ключ;
		мТипов = ТипыКолонок[ИмяКолонки];
		Если мТипов = Неопределено ИЛИ мТипов.Количество() = 0 Тогда
			мТипов = ОбщегоНазначенияКлиентСерверУХ.ЗначениеВМассиве(
				Тип("Число"));
		КонецЕсли;
		ОписаниеТипаКолонки = Новый ОписаниеТипов(мТипов);
		Таблица.Колонки.Добавить(ИмяКолонки, ОписаниеТипаКолонки);
	КонецЦикла;
КонецПроцедуры

// Определение внешнее соединение или нет
Функция ЭтоВнешнееСоединение() Экспорт
	#Если ВнешнееСоединение Тогда
		Возврат Истина;
	#Иначе
		Возврат Ложь;
	#КонецЕсли
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции работающие с типами
// и их строковыми представлениями

// Возвращает имя базового типа по переданному значению объекта метаданных
//
// Параметры:
//  ОбъектМетаданных - объект метаданных, по которому необходимо определить базовый тип
// 
// Возвращаемое значение:
//  Строка - имя базового типа по переданному значению объекта метаданных
//
Функция ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	Если Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаДокументы();
		
	ИначеЕсли Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаСправочники();
		
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыСведений();
		
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыНакопления();
		
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыБухгалтерии();
		
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаРегистрыРасчета();
		
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыОбмена();
		
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовХарактеристик();
		
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаБизнесПроцессы();
		
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаЗадачи();
		
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыСчетов();
		
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат ИмяТипаПланыВидовРасчета();
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	
КонецФункции

// Функция МенеджерОбъектаПоПолномуИмени возвращает менеджер объекта
// по полному имени объекта метаданных.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСерверУХ.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ	= ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Справочники[ИмяОМ];
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Документы[ИмяОМ];
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат БизнесПроцессы[ИмяОМ];
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат ПланыВидовХарактеристик[ИмяОМ];
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат ПланыСчетов[ИмяОМ];
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат ПланЫВидовРасчета[ИмяОМ];
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Задачи[ИмяОМ];
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат ПланыОбмена[ИмяОМ];
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Перечисления[ИмяОМ];
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Обработки[ИмяОМ];
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСерверУХ.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции 

// Функция МенеджерОбъектаПоПолномуИмени возвращает менеджер объекта
// по ссылке на объект.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции // МенеджерОбъектаПоСсылке()

// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
//
// Параметры:
//  ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//  Истина - ссылка физически существует;
//  Ложь   - ссылка физически не существует
//
Функция СсылкаСуществует(ЛюбаяСсылка) Экспорт
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Ссылка
	|ИЗ
	|	[ИмяТаблицы]
	|ГДЕ
	|	Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(ЛюбаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ЛюбаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Функция ВидОбъектаПоСсылке возвращает имя вида объектов метаданных
// по ссылке на объект.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоСсылке(Ссылка) Экспорт
	
	Возврат ВидОбъектаПоТипу(ТипЗнч(Ссылка));
	
КонецФункции 

// Функция возвращает имя вида объектов метаданных по типу объекта.
//
// Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Тип       - Тип прикладного объекта, определенный в конфигурации
//
// Возвращаемое значение:
//  Строка       - имя вида объектов метаданных, например, "Справочник", "Документ" ...
// 
Функция ВидОбъектаПоТипу(Тип) Экспорт
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Справочник";
	
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Документ";
	
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцесс";
	
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристик";
	
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетов";
	
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчета";
	
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Задача";
	
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбмена";
	
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "Перечисление";
	
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСерверУХ.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неверный тип значения параметра (%1)'"), Строка(Тип));
	
	КонецЕсли;
	
КонецФункции 

// Возвращает полное имя объекта метаданных по переданному значению ссылки
// Например,
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная"
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - значение ссылки, для которого необходимо получить имя таблицы ИБ
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного значения ссылки
//
Функция ИмяТаблицыПоСсылке(Ссылка) Экспорт
	
	Возврат Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).ПолноеИмя();
	
КонецФункции

Функция ПолучитьСтроковоеПредставлениеТипа(Тип) Экспорт
	
	Представление = "";
	
	Если ТипСсылочногоТипа(Тип) Тогда
	
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ИмяОбъекта = СтроковыеФункцииКлиентСерверУХ.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".")[1];
		
		Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "СправочникСсылка";
		
		ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ДокументСсылка";
		
		ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "БизнесПроцессСсылка";
		
		ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовХарактеристикСсылка";
		
		ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланСчетовСсылка";
		
		ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланВидовРасчетаСсылка";
		
		ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ЗадачаСсылка";
		
		ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПланОбменаСсылка";
		
		ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Представление = "ПеречислениеСсылка";
		
		КонецЕсли;
		
		Результат = ?(Представление = "", Представление, Представление + "." + ИмяОбъекта);
		
	Иначе
		
		Результат = Строка(Тип);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Функция ЗначениеСсылочногоТипа проверяет, что значение имеет ссылочный тип данных
//
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//
// Возвращаемое значение:
//  Булево       - Истина, если тип значения ссылочный.
// 
Функция ЗначениеСсылочногоТипа(Значение) Экспорт
	Возврат ТипСсылочногоТипа(ТипЗнч(Значение));
КонецФункции 

// Проверка того, что тип имеет ссылочный тип данных
//
Функция ТипСсылочногоТипа(Тип) Экспорт

	Возврат Справочники.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Документы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Задачи.ТипВсеСсылки().СодержитТип(Тип)
		ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип);

КонецФункции 

Функция ПолучитьИмяОбъектаМетаданных(ОбъектСсылка) Экспорт
		
	Если ОбъектСсылка=Неопределено Тогда
		
		Возврат "";
		
	Иначе
			
		Возврат ОбъектСсылка.Метаданные().Имя;
		
	КонецЕсли;

КонецФункции // ПолучитьИмяОбъектаМетаданных()

// Является ли объект группой 
// В качестве параметра может принимать только справочник или ПВХ
//
Функция ОбъектЯвляетсяГруппой(Объект) Экспорт
	
	МетаданныеОбъекта = Объект.Метаданные();
	
	Если НЕ (МетаданныеОбъекта.Иерархический И МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ОбщегоНазначенияУХ.ЗначениеСсылочногоТипа(Объект) Тогда
		Возврат Объект.ЭтоГруппа;
	КонецЕсли;
	
	Ссылка = Объект.Ссылка;
	
	Если Не ЗначениеЗаполнено(Ссылка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ОбщегоНазначенияУХ.ПолучитьЗначениеРеквизита(Ссылка, "ЭтоГруппа");
	
КонецФункции

Функция ПолучитьМассивТиповЛюбаяСсылка() Экспорт

	МассивВсеСсылки = Новый Массив;
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, Справочники.ТипВсеСсылки().Типы());
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, Документы.ТипВсеСсылки().Типы());
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, Перечисления.ТипВсеСсылки().Типы());
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, ПланыСчетов.ТипВсеСсылки().Типы());
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, ПланыВидовРасчета.ТипВсеСсылки().Типы());
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, БизнесПроцессы.ТипВсеСсылки().Типы());
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, Задачи.ТипВсеСсылки().Типы());
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, ПланыОбмена.ТипВсеСсылки().Типы());
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, ПланыВидовХарактеристик.ТипВсеСсылки().Типы());
	ДобавитьМассивВСписокЗначений(МассивВсеСсылки, БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().Типы());
	
	Возврат МассивВсеСсылки;
	
КонецФункции

// По тексту навигационной ссылки ТекстСсылкиВход возвращает ссылку на объект
// информационной базы. В случае неудачи преобразования возвращает Неопределено.
Функция СсылкаНаОбъектИзНавигационнойСсылки(ТекстСсылкиВход) Экспорт
	РезультатФункции = Неопределено;
	Если Лев(ТекстСсылкиВход, 4) = "e1c:" Тогда
		Попытка
			ПозицияОтносительнойСсылки = СтрНайти(ТекстСсылкиВход, "e1cib/data/");
			ТекстСсылкиОчищенный = Прав(ТекстСсылкиВход, СтрДлина(ТекстСсылкиВход) - ПозицияОтносительнойСсылки + 1);
			ПозицияПредставленияСсылки = СтрНайти(ТекстСсылкиОчищенный, "?ref=");
			ТипЭлементаСтрока   = Сред(ТекстСсылкиОчищенный, 12, ПозицияПредставленияСсылки - 12);
			ПустаяСсылкаЭлемента = ПредопределенноеЗначение(ТипЭлементаСтрока + ".ПустаяСсылка");
			ВнутрПредставлениеЭлемента = ЗначениеВСтрокуВнутр(ПустаяСсылкаЭлемента);
			ПозицияДвоеточия = СтрНайти(ВнутрПредставлениеЭлемента, ":");
			ЛеваяЧасть = Лев(ВнутрПредставлениеЭлемента, ПозицияДвоеточия);
			ПраваяЧасть = Сред(ТекстСсылкиОчищенный, ПозицияПредставленияСсылки + 5);
			НоваяСсылкаВнутр = ЛеваяЧасть + ПраваяЧасть + "}";
			РезультатФункции = ЗначениеИзСтрокиВнутр(НоваяСсылкаВнутр);
		Исключение
			РезультатФункции = Неопределено;
		КонецПопытки;
	Иначе
		РезультатФункции = Неопределено;
	КонецЕсли;
	Возврат РезультатФункции;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
//  Сохранение и чтение настроек

// Передает с клиента на сервер для записи массив настроек 
//(массив структур с полями Объект Настройка Значение)
Процедура ХранилищеОбщихНастроекСохранитьМассив(МассивСтруктур) Экспорт
	Для Каждого Элемент Из МассивСтруктур Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, Элемент.Настройка, Элемент.Значение);
	КонецЦикла;
КонецПроцедуры

// Передает с клиента на сервер для записи настройку
Процедура ХранилищеОбщихНастроекСохранить(Объект, Настройка, Значение) Экспорт
	ХранилищеОбщихНастроек.Сохранить(Объект, Настройка, Значение);
КонецПроцедуры

// Передает с клиента на сервер для записи
Функция ХранилищеОбщихНастроекЗагрузить(Объект, Настройка) Экспорт
	Возврат ХранилищеОбщихНастроек.Загрузить(Объект, Настройка);
КонецФункции

Процедура ПриЗаписиСчетаПриЗаписи(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеСчета = Источник.Метаданные();
	
	Если ОбщегоНазначения.ЕстьРеквизитОбъекта("ПланСчетовБД", МетаданныеСчета) Тогда //счета МСФО - детализируются
		ДанныеПланаСчетов = Источник.ПланСчетовБД; 
	Иначе //планов счетов без реквизита, например "Хозрасчетный"
		ДанныеПланаСчетов = Справочники.ПланыСчетовБД.ПолучитьПланСчетовБД(МетаданныеСчета.Имя);
	КонецЕсли;
	
	ПометитьСправочникПоРеквизиту("СчетаБД","СчетСсылка",Источник.Ссылка,Источник.ПометкаУдаления,Отказ);
	
	//Если Источник.ПометкаУдаления Тогда
	//	Возврат;
	//КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ДанныеПланаСчетов) Тогда
		
		СправочникОбъект=Справочники.ПланыСчетовБД.СоздатьЭлемент();
		СправочникОбъект.Владелец=Справочники.ТипыБазДанных.ТекущаяИБ;
		СправочникОбъект.Наименование=МетаданныеСчета.Имя;
		СправочникОбъект.ЗаполнитьРеквизитыОбъекта();
		СправочникОбъект.Записать();
		
	Иначе
		
		СправочникОбъект=ДанныеПланаСчетов.ПолучитьОбъект();
		СправочникОбъект.ТекущаяИБ=Истина;
		СправочникОбъект.ПланСчетовБД=Метаданные.ПланыСчетов[Источник.Метаданные().Имя];
		СправочникОбъект.ЗаполнитьПланСчетов(Источник.Ссылка);
		
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьПредставлениеВидаСравнения(ВидСравненияВОтборе) Экспорт
	
	Если ВидСравненияВОтборе = ВидСравнения.Равно Тогда
		Возврат " = ";
	ИначеЕсли ВидСравненияВОтборе = ВидСравнения.Больше Тогда
		Возврат " > ";
	ИначеЕсли ВидСравненияВОтборе = ВидСравнения.БольшеИлиРавно Тогда
		Возврат " >= ";
	ИначеЕсли ВидСравненияВОтборе = ВидСравнения.Меньше Тогда
		Возврат " < ";
	ИначеЕсли ВидСравненияВОтборе = ВидСравнения.МеньшеИлиРавно Тогда
		Возврат " <= ";
	ИначеЕсли ВидСравненияВОтборе = ВидСравнения.НеРавно Тогда
		Возврат " <> ";
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

// Функция возвращает список родителей  для указанной ссылки
Функция ПолучитьРодителей(Ссылка) Экспорт
	
 ИмяМетаданных = Ссылка.Метаданные().Имя;
 Запрос = Новый Запрос;
 Запрос.Текст =
 "ВЫБРАТЬ ПЕРВЫЕ 1
 | #ИМЯ.Ссылка КАК Ссылка
 |ИЗ
 | Справочник.#ИМЯ КАК #ИМЯ
 |ГДЕ
 | #ИМЯ.Ссылка = &Ссылка
 |ИТОГИ ПО
 |   Ссылка ТОЛЬКО ИЕРАРХИЯ ";
 Запрос.Текст = СтрЗаменить(Запрос.Текст, "#ИМЯ", ИмяМетаданных);
 Запрос.УстановитьПараметр("Ссылка", Ссылка);
 
 Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка"); 
 
КонецФункции

// Процедура заполняет колонки табличной части значениями из структуры
Процедура ЗаполнитьКолонкиТабличнойЧасти(ТаблицаЗначений,ДанныеЗаполнения) Экспорт
	
	Для Каждого ТекСтр Из ТаблицаЗначений Цикл
		ЗаполнитьЗначенияСвойств(ТекСтр, ДанныеЗаполнения);
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьКолонкиТаблицыЗначений()

// Возвращает значение из константы с именем ИмяКонстантыВход.
Функция ПолучитьЗначениеКонстанты(ИмяКонстантыВход) Экспорт
	РезультатФункции = Константы[ИмяКонстантыВход].Получить();
	Возврат РезультатФункции;
КонецФункции

// Определяет, включены ли напоминания у текущего пользователя
Функция ВключеныНапоминанияПользователя() Экспорт
	УстановитьПривилегированныйРежим(Истина);
	РезультатФункции = Истина;
	ПервыйЗапуск = (ОбновлениеИнформационнойБазы.ВерсияИБ("УправлениеХолдингом") = "0.0.0.0");
	Если ПервыйЗапуск Тогда
		РезультатФункции = Ложь;
		ТекПользователь = Пользователи.АвторизованныйПользователь();
		Если Не ЗначениеЗаполнено(ТекПользователь) Тогда
			РезультатФункции = Ложь;
		Иначе
			Если ОбщегоназначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ТекПользователь, "ОтображатьНапоминания") Тогда
				РезультатФункции = ТекПользователь.ОтображатьНапоминания;
			Иначе
				РезультатФункции = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	УстановитьПривилегированныйРежим(Ложь);
	Возврат РезультатФункции;
КонецФункции

// Пересчитывает сумму СуммаВход в валюте ВалютаВход в валюту упр учета.
Функция РассчитатьСуммуУпр(ВалютаВход, СуммаВход, ДатаВход = Неопределено) Экспорт
	РезультатФункции = СуммаВход;
	ВалютаУпрУчета = ОбщегоНазначенияПовтИспУХ.ПолучитьВалютуУправленческогоУчета();
	Если ЗначениеЗаполнено(ВалютаВход) И ЗначениеЗаполнено(ВалютаУпрУчета) Тогда
		Если ДатаВход = Неопределено Тогда
			ДатаРабочая = ТекущаяДатаСеанса();
		Иначе	
			ДатаРабочая = ДатаВход;
		КонецЕсли;
		РезультатФункции = РаботаСКурсамиВалютУХ.ПересчитатьВВалюту(СуммаВход, ВалютаВход, ВалютаУпрУчета, ДатаРабочая);
	Иначе
		РезультатФункции = СуммаВход;
	КонецЕсли;
	Возврат РезультатФункции;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// Работа с перечислениями

// Сравнивает два значения перечисления.
// Параметры:
//	Значение1 - ПеречислениеСсылка
//	Значение2 - ПеречислениеСсылка
// Возвращает:
//	Если значения равны, то возвращает 0.
//	Если Значение1 стоить раньше по порядку Значение2, то -1
//	Если Значение1 стоить позже по порядку Значение2, то 1
Функция СравнитьЗначенияПеречисления(Значение1, Значение2) Экспорт
	Если Значение1 = Значение2 Тогда
		Возврат 0;
	КонецЕсли;
	
	ПерчислениеМенеджер = Перечисления[Значение1.Метаданные().Имя];
	Индекс1 = ПерчислениеМенеджер.Индекс(Значение1);
	Индекс2 = ПерчислениеМенеджер.Индекс(Значение2);
	
	Если Индекс1 < Индекс2 Тогда
		Возврат -1;
	ИначеЕсли Индекс1 > Индекс2 Тогда
		Возврат 1;
	КонецЕсли;
	
	Возврат 0;
КонецФункции

Процедура СоздатьНедостающиеПоказателиОСВ(ПланСчетов=Неопределено,Счет=Неопределено,ВидОтчетаОСВ=Неопределено, ОбновитьТР = Истина) Экспорт
	
	Справочники.ВидыОтчетов.СоздатьНедостающиеПоказателиОСВ(ПланСчетов,Счет,ВидОтчетаОСВ, ОбновитьТР,Ложь);
	
КонецПроцедуры // СоздатьНедостающиеПоказателиОСВ() 

// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//	Запрос			- Запрос - запрос, параметры которого предварительно установлены.
//	ТекстыЗапроса	- СписокЗначений - в списке перечислены тексты запросов и их имена.
//	ОбходРезультата - ОбходРезультатаЗапроса - вариант обхода результата запроса.
//	ДобавитьРазделитель - Булево - добавлять разделитель между запросами из ТекстыЗапроса
//	УничтожитьСозданныеВременныеТаблицы - Булево - добавить уничножение временных таблиц, создаваемых в ТекстыЗапроса
//										Для уничтожения таблице должно быть присвоено имя в ТекстыЗапроса
//
// Возвращаемое значение:
//   Структура   - структура в которую помещены полученные таблицы
//
Функция ВыгрузитьРезультатыЗапроса(Запрос,
								 	ТекстыЗапроса,
									ОбходРезультата = Неопределено,
									ДобавитьРазделитель = Ложь,
									УничтожитьСозданныеВременныеТаблицы = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	// Инициализация варианта обхода результата запроса.
	Если ОбходРезультата = Неопределено Тогда
		ОбходРезультата = ОбходРезультатаЗапроса.Прямой;
	КонецЕсли;
	
	ТекстУничтоженияВременныхТаблиц = "";
	
	ТекстИтоговогоЗапроса = "";
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			ТекстИтоговогоЗапроса = ТекстИтоговогоЗапроса 
							+ ?(ТекстИтоговогоЗапроса <> "", Символы.ПС, "")
							+ "// " + ТекстЗапроса.Представление + Символы.ПС;
		КонецЕсли; 
		ТекстИтоговогоЗапроса = ТекстИтоговогоЗапроса + ТекстЗапроса.Значение;
		
		Если ДобавитьРазделитель Тогда
			ТекстИтоговогоЗапроса = ТекстИтоговогоЗапроса + ОбщегоНазначенияБПВызовСервера.ТекстРазделителяЗапросовПакета();
		КонецЕсли;
		
		Если УничтожитьСозданныеВременныеТаблицы
			И ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			Если СтрНайти(ВРег(ТекстЗапроса.Значение), "ПОМЕСТИТЬ") <> 0 Тогда
		    	ТекстУничтоженияВременныхТаблиц = ТекстУничтоженияВременныхТаблиц + "
				|УНИЧТОЖИТЬ " + ТекстЗапроса.Представление;
				ТекстУничтоженияВременныхТаблиц = ТекстУничтоженияВременныхТаблиц + ОбщегоНазначенияБПВызовСервера.ТекстРазделителяЗапросовПакета();
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	// Выполнение запроса.
	
	Если ЗначениеЗаполнено(ТекстУничтоженияВременныхТаблиц) Тогда
		ТекстИтоговогоЗапроса = ТекстИтоговогоЗапроса + ТекстУничтоженияВременныхТаблиц;
	КонецЕсли;
	
	Запрос.Текст = ТекстИтоговогоЗапроса;
	Результат = Запрос.ВыполнитьПакет();

	// Помещение результатов запроса в таблицы
	Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл

		ИмяТаблицы = ТекстЗапроса.Представление;

		Если Не ПустаяСтрока(ИмяТаблицы) Тогда

			Индекс = ТекстыЗапроса.Индекс(ТекстЗапроса);
			Таблицы.Вставить(ИмяТаблицы, Результат[Индекс].Выгрузить(ОбходРезультата));

		КонецЕсли;

	КонецЦикла;

	Возврат Таблицы;
	
КонецФункции

// Возвращает пользовательские настройки отчета с имененем
// ИмяОтчетаВход, куда установлен параметр с именем ИмяПараметраВход 
// и значением ЗначениеПараметраВход.
Функция УстановитьЗначениеПараметраВПользовательскиеНастройки(ИмяОтчетаВход, ИмяПараметраВход, ЗначениеПараметраВход) Экспорт
	РезультатФункции = Неопределено;
	Попытка
		ОтчетОбъект = Отчеты[ИмяОтчетаВход].Создать();
		КомпоновщикНастроек = ОтчетОбъект.КомпоновщикНастроек;
		Настройки = КомпоновщикНастроек.ПолучитьНастройки();
		Настройки.ПараметрыДанных.УстановитьЗначениеПараметра(ИмяПараметраВход, ЗначениеПараметраВход);
		КомпоновщикНастроек.ЗагрузитьНастройки(Настройки);
		РезультатФункции = КомпоновщикНастроек.ПользовательскиеНастройки;
	Исключение
		ТекстСообщения = НСтр("ru = 'При установке параметра %Параметр% в отчет %Отчет% возникли ошибки: %ОписаниеОшибки%'");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Параметр%", Строка(ИмяПараметраВход));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Отчет%", Строка(ИмяОтчетаВход));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОписаниеОшибки%", ОписаниеОшибки());
		ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
		РезультатФункции = Неопределено;
	КонецПопытки;
	Возврат РезультатФункции;
КонецФункции		// УстановитьЗначениеПараметраВПользовательскиеНастройки()

// Устанавливает в существующие пользовательские настройки ПользовательскиеНастройкиВход
// значение ЗначениеОтбораВход отбора ИмяОтбораВход для отчета ИмяОтчетаВход. 
Процедура УстановитьЗначениеОтбораВПользовательскиеНастройкиОтчета(ИмяОтчетаВход, ИмяОтбораВход, ЗначениеОтбораВход, ПользовательскиеНастройкиВход) Экспорт
	РезультатФункции = Неопределено;
	Попытка
		// Получим элементы настроек отчета.
		ПолеОтбора = Новый ПолеКомпоновкиДанных(ИмяОтбораВход);
		ОтчетОбъект = Отчеты[ИмяОтчетаВход].Создать();
		КомпоновщикНастроек = ОтчетОбъект.КомпоновщикНастроек;
		Настройки = КомпоновщикНастроек.ПолучитьНастройки();
		ЭлементыОтбора = Настройки.Отбор.Элементы;
		// Получим идентификатор пользовательской настройки.
		ИдентификаторНастройки = "";
		Для Каждого ТекЭлементыОтбора Из ЭлементыОтбора Цикл
			Если ТекЭлементыОтбора.ЛевоеЗначение = ПолеОтбора Тогда
				ИдентификаторНастройки = ТекЭлементыОтбора.ИдентификаторПользовательскойНастройки;
				Прервать;			// Значение найдено.
			Иначе
				// Выполняем поиск далее.
			КонецЕсли;
		КонецЦикла;	
		// Установим значение отбора в пользовательскую настройка.
		Если ЗначениеЗаполнено(ИдентификаторНастройки) Тогда
			Для Каждого ТекЭлементы Из ПользовательскиеНастройкиВход.Элементы Цикл
				Если ТекЭлементы.ИдентификаторПользовательскойНастройки = ИдентификаторНастройки Тогда
					ТекЭлементы.Использование	 = Истина;
					ТекЭлементы.ВидСравнения	 = ВидСравненияКомпоновкиДанных.Равно;
					ТекЭлементы.ЛевоеЗначение	 = ПолеОтбора;
					ТекЭлементы.ПравоеЗначение	 = ЗначениеОтбораВход;
				Иначе
					// Выполняем поиск далее.
				КонецЕсли;
			КонецЦикла;	
		Иначе
			// Не удалось получить идентификатор настройки. Не устанавливаем значение.
		КонецЕсли;
	Исключение
		ТекстСообщения = НСтр("ru = 'При установке параметра %Параметр% в отчет %Отчет% возникли ошибки: %ОписаниеОшибки%'");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Параметр%", Строка(ИмяОтбораВход));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Отчет%", Строка(ИмяОтчетаВход));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОписаниеОшибки%", ОписаниеОшибки());
		ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
		РезультатФункции = Неопределено;
	КонецПопытки;
КонецПроцедуры		// УстановитьЗначениеОтбораВПользовательскиеНастройкиОтчета()

////////////////////////////////////////////////////////////////////////////////
// УПРАВЛЯЕМЫЙ ИНТЕРФЕЙС

// Размещает на форме в группе ГруппаРодительВход элемент с нименованием НаименованиеЭлементаВход, 
// заголовком ЗаголовокВход и типом элемента формы ТипЭлементаВход. По умолчанию заголовок скрыт. 
// Подключает его к реквизиту НаименованиеРеквизитаВход. Возвращает новый элемент формы.
Функция ДобавитьЭлементФормы(НаименованиеЭлементаВход, ГруппаРодительВход, НаименованиеРеквизитаВход, ЭлементыВход, ТипЭлементаВход = Неопределено, ЗаголовокВход = "", ЗаголовокСкрыт = Истина, ГоризонтальноеПоложениеВход = Неопределено) Экспорт
	Если ТипЭлементаВход = Неопределено Тогда
		ТипЭлементаРабочий = Тип("ПолеФормы");
	Иначе	
		ТипЭлементаРабочий = ТипЭлементаВход;
	КонецЕсли;
	НовыйЭлемент = ЭлементыВход.Вставить(НаименованиеЭлементаВход, ТипЭлементаРабочий, ГруппаРодительВход);
	НовыйЭлемент.ПутьКДанным = НаименованиеРеквизитаВход;
	НовыйЭлемент.Заголовок = ЗаголовокВход;
	Если ЗаголовокСкрыт Тогда
		НовыйЭлемент.ПоложениеЗаголовка = ПоложениеЗаголовкаЭлементаФормы.Нет;
	Иначе
		// Новое положение заголовка будет установлено далее.
	КонецЕсли;
	Если ГоризонтальноеПоложениеВход <> Неопределено Тогда
		НовыйЭлемент.ГоризонтальноеПоложение = ГоризонтальноеПоложениеВход;
	Иначе
		// Не изменяем горизонтальное положение.
	КонецЕсли;
	НовыйЭлемент.ВертикальноеПоложение = ВертикальноеПоложениеЭлемента.Центр;
	Возврат НовыйЭлемент;
КонецФункции

// Добавляет группу элементов формы в родительскую группу ГруппаРодительВход с наименованием
// НаименованиеНовогоРеквизитаВход. ГруппировкаВход задаёт способ размещения (группировку) элементов.
Функция ДобавитьГруппуЭлементов(НаименованиеНовогоРеквизитаВход, ГруппаРодительВход, ГруппировкаВход, ЭлементыВход, ЗаголовокВход = "", ОтображатьЗаголовокВход = Ложь) Экспорт
	НовыйЭлемент									 = ЭлементыВход.Вставить(НаименованиеНовогоРеквизитаВход, Тип("ГруппаФормы"), ГруппаРодительВход);
	НовыйЭлемент.Вид								 = ВидГруппыФормы.ОбычнаяГруппа;
	НовыйЭлемент.ОтображатьЗаголовок				 = ОтображатьЗаголовокВход;
	НовыйЭлемент.Заголовок							 = ЗаголовокВход;
	НовыйЭлемент.ГоризонтальноеПоложениеПодчиненных	 = ГоризонтальноеПоложениеЭлемента.Центр;
	НовыйЭлемент.Объединенная						 = Истина;
	НовыйЭлемент.Отображение						 = ОтображениеОбычнойГруппы.Нет;
	НовыйЭлемент.Группировка						 = ГруппировкаВход;
	НовыйЭлемент.РастягиватьПоГоризонтали			 = Истина;
	Возврат НовыйЭлемент;
КонецФункции

// Возвращает ключ данных для подстановки в сообщение пользователю
// Ключ данных нужен при групповой обработке объектов - если он установлен, то при нажатии пользователем на сообщение
// будет открываться форма объекта.
//
//	Параметры:
//		Объект - Произвольный - объект, для которого нужно получить ключ данных.
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы.
//
Функция КлючДанныхДляСообщенияПользователю(Объект) Экспорт
	
	КлючДанных = Неопределено;
	XMLТипЗнч = XMLТипЗнч(Объект); 
	
	Если XMLТипЗнч <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч.ИмяТипа;
		Если СтрНайти(ТипЗначенияСтрокой, "Object.") > 0 Тогда
			КлючДанных = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат КлючДанных;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// 

// Функция копирует значения свойств Источника в свойства Приемника по СтруктуреПреобразования, в которой в Ключе указано ИмяПоляПриемника, а в Значение указано ИмяПоляИсточника
Процедура ЗаполнитьСвойства(Приемник, Источник, СтруктураПреобразованияПолей = неопределено) Экспорт

	Если СтруктураПреобразованияПолей = неопределено Тогда
		ЗаполнитьЗначенияСвойств(Приемник, Источник);
	КонецЕсли;
	
	Для каждого Поле Из СтруктураПреобразованияПолей Цикл
	
		Приемник[Поле.Ключ] = Источник[Поле.Значение];
	
	КонецЦикла; 

КонецПроцедуры

// Функция возвращает Истину, если в структуре есть такое свойство и оно заполнено. Иначе Ложь.
Функция СвойствоЗаполнено(Структура, ИмяСвойства) Экспорт
	Возврат Структура.Свойство(ИмяСвойства) И ЗначениеЗаполнено(Структура[ИмяСвойства]);
КонецФункции

//

////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ВРЕМЕННЫМИ ТАБЛИЦАМИ ЗАПРОСА

// Функция возвращает структуру, в которой имя временной таблицы находится в ключе, а в занчении содержимое временной таблицы (таблица значений)
Функция СтруктураВТ(Запрос) Экспорт
	
	Рез = Новый Структура;
	
	Для каждого ВТ Из Запрос.МенеджерВременныхТаблиц.Таблицы Цикл
	
		Рез.Вставить(ВТ.ПолноеИмя, ВТ.ПолучитьДанные().Выгрузить());
	
	КонецЦикла; 
	
	Возврат Рез;
	
КонецФункции // СтруктураВТ()

//Процедура помещает таблицу значений в виртуальную таблицу запроса 
Процедура ЗагрузитьТаблицуВоВременнуюТаблицуЗапроса(Запрос, ИмяВТ, Таблица) Экспорт
	
	Если Запрос.МенеджерВременныхТаблиц = неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	КонецЕсли;
	
	Запрос.Текст = 
	"ВЫБРАТЬ * ПОМЕСТИТЬ "+ИмяВТ+" ИЗ &Таблица КАК Таблица";
	Запрос.УстановитьПараметр("Таблица", Таблица);
	Запрос.Выполнить();
	
КонецПроцедуры

Функция ВыполнитьЗапрос(ТекстЗапроса, Параметры = неопределено) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	
	Если ТипЗнч(Параметры) = Тип("Структура") Тогда
		
		Для Каждого КлючЗначение Из Параметры Цикл
			Запрос.УстановитьПараметр(КлючЗначение.Ключ, КлючЗначение.Значение);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Запрос.Выполнить();
	
КонецФункции

// Функция возвращает разделитель запросов в пакете запросов
Функция ТекстРазделителяЗапросовПакета() Экспорт

	ТекстРазделителя =
	"
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";

	Возврат ТекстРазделителя;

КонецФункции

// ОПК

// Функция возвращает тип из определяемого типа по номеру
Функция ТипОпределяемогоТипа(ОпределяемыйТип, НомерТипа = 0) Экспорт
	Возврат ОпределяемыйТип.Тип.Типы()[НомерТипа];
КонецФункции

// Функция возвращает пустое значение по определяемому типу
Функция ПустоеЗначениеОпределяемогоТипа(ОпределяемыйТип, НомерТипа = 0) Экспорт
	Возврат ПустоеЗначениеОписанияТипа(ОпределяемыйТип.Тип, НомерТипа);
КонецФункции

// Функция возвращает пустое значение по определяемому типу
Функция ПустоеЗначениеОписанияТипа(ОписаниеТипа, НомерТипа = 0) Экспорт
	Возврат Новый (ОписаниеТипа.Типы()[НомерТипа]);
КонецФункции

// Конец ОПК
