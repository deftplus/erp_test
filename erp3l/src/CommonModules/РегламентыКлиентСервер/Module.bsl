
#Область ПрограммныйИнтерфейс

Процедура ОбработатьСтрокуТЧ(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения = Неопределено) Экспорт 
	
	ЗаполнитьВалюты(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);//ОсновнаяВалюта, ДополнительныеВалюты
	ЗаполнитьДочерние(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);//после валют - чтобы заполнить валюты подчиненных	
	ЗаполнитьРеквизитыОрганизации(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);//ПометкаУдаления, ВидОрганизационнойЕдиницы, ИностранныйНалоговыйРезидент, ЭлиминирующаяОрганизация	
	ЗаполнитьЯвляетсяКонсолидирующей(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);
	ЗаполнитьЯвляетсяЦФО(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);
	ЗаполнитьЭффективнуюДолю(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);
	ЗаполнитьОтношениеКГруппе(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);
	ЗаполнитьМетодИсключенияВГО(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);
	ЗаполнитьЕстьУтвержденные(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);//ТолькоПросмотр - т.е. есть утвержденные
	ЗаполнитьКартинкуСтрок(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);
		
КонецПроцедуры	

Процедура ОбработатьСтрокиТЧ(СтрокиТЧ, СтруктураДействий, КэшируемыеЗначения) Экспорт

	Перем РеквизитыДействия;
	
	Если СтруктураДействий.Свойство("ЗаполнитьОбъектыИнвестирования", РеквизитыДействия) Тогда
		
		КэшСервера = РегламентыВызовСервера.ПолучитьКешируемыеЗначения(СтруктураДействий, КэшируемыеЗначения);
		
		КэшСтрок = Новый Соответствие;
		Для каждого СтрокаТЧ Из СтрокиТЧ Цикл
			КэшСтрок.Вставить(СтрокаТЧ.ОрганизационнаяЕдиница, СтрокаТЧ);		
		КонецЦикла;
		
		ЕстьДопКолонки = (ТипЗнч(СтрокиТЧ) = Тип("ДанныеФормыКоллекцияЭлементовДерева"));
		
		Для каждого СтрокаОбъектИнвестирования Из КэшСервера.ОбъектыИнвестирования Цикл			
			Если КэшСтрок.Получить(СтрокаОбъектИнвестирования.Ключ) = Неопределено Тогда					
				
				НоваяСтрока = СтрокиТЧ.Добавить();
				НоваяСтрока.ОрганизационнаяЕдиница = СтрокаОбъектИнвестирования.Ключ;
				Если ЕстьДопКолонки Тогда
					НоваяСтрока.КонсолидирующаяОрганизацияОтображение = НоваяСтрока.ПолучитьРодителя().ОрганизационнаяЕдиница;				
				КонецЕсли;		
				
			КонецЕсли;			
		КонецЦикла;
		
		Для каждого ЭлементКэша Из КэшСервера Цикл
			КэшируемыеЗначения.Вставить(ЭлементКэша.Ключ, ЭлементКэша.Значение);	
		КонецЦикла;
		
		Если РеквизитыДействия.Свойство("ВыводитьСообщения") И (КэшСервера.ОбъектыИнвестирования.Количество() = 0) Тогда
			
			ШаблонСообщения = Нстр("ru = 'По материнской компании (%1) не найдены объекты инвестирования на дату <%2> по сценарию <%3>'");
			
			Если ЗначениеЗаполнено(ШаблонСообщения) тогда
				ОбщегоНазначенияУХ.СообщитьОбОшибке(СтрШаблон(ШаблонСообщения, СтрСоединить(РеквизитыДействия.Инвестор, ", "), 
					РеквизитыДействия.Период, РеквизитыДействия.Сценарий));
			КонецЕсли;									
			
		КонецЕсли;
		
	КонецЕсли;
	
	СтруктураДействий.Удалить("ЗаполнитьОбъектыИнвестирования");// циклически не выполняем
	
	Для каждого СтрокаТЧ Из СтрокиТЧ Цикл
		ОбработатьСтрокуТЧ(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения);		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбновитьНаименованиеЗаголовок(Объект, Форма = Неопределено) Экспорт

	Форма.Заголовок = СтрШаблон("%1 %2 %3", Объект.Наименование, 
				?(ЗначениеЗаполнено(Объект.МеткаВремени), СтрШаблон(НСтр("ru = ' от %1'"), Формат(Объект.МеткаВремени, "Л=ru_RU; ДФ=dd.MM.yy")), ""), 
				?(Форма.Параметры.Ключ.Пустая(), НСтр("ru = ' (Создание)'"), НСтр("ru = ' (Регламент подготовки отчетности)'")));
	
КонецПроцедуры

Функция ПолучитьОтношениеКГруппеПоДоле(ЭффективнаяДоля, КэшОтношенийКГруппе = Неопределено) Экспорт

	Если КэшОтношенийКГруппе = Неопределено Тогда
		КэшОтношенийКГруппе = РегламентыВызовСервера.ПолучитьОсновныеОтношенияКГруппе();
	КонецЕсли;
	
	Если ЭффективнаяДоля < 20 Тогда	
		Результат = КэшОтношенийКГруппе.Получить(ПредопределенноеЗначение("Перечисление.ВидыОтношенийКГруппе.ТретьиСтороны"));
	ИначеЕсли ЭффективнаяДоля < 50 Тогда	
		Результат = КэшОтношенийКГруппе.Получить(ПредопределенноеЗначение("Перечисление.ВидыОтношенийКГруппе.Ассоциированное"));
	Иначе	
		Результат = КэшОтношенийКГруппе.Получить(ПредопределенноеЗначение("Перечисление.ВидыОтношенийКГруппе.Дочернее"));
	КонецЕсли;
	
	Возврат ?(Результат = Неопределено, ПредопределенноеЗначение("Справочник.ГруппыКонтрагентов.ПустаяСсылка"), Результат);
	
КонецФункции

#КонецОбласти

#Область Перетаскивание

Функция ПолучитьЗначениеПеретаскивания(ИдентификаторыУзлов, СтруктураГруппы = Неопределено, ШаблонУзла) Экспорт
		
	КэшПеретаскивания = Новый Структура;	
	КэшПеретаскивания.Вставить("ОрганизацииИсточники",	Новый Соответствие);	
	КэшПеретаскивания.Вставить("Дерево", 				Новый Массив);
	КэшПеретаскивания.Вставить("Элиминирующие", 		Новый Соответствие);
	
	Если ИдентификаторыУзлов.Количество() = 0 Тогда
		Возврат КэшПеретаскивания;
	КонецЕсли;
	
	//Источник
	
	Для каждого ИдентификаторУзла Из ИдентификаторыУзлов Цикл
		
		Если СтруктураГруппы = Неопределено Тогда
		    УзелИсточник = ИдентификаторУзла;
		Иначе	
			УзелИсточник = СтруктураГруппы.НайтиПоИдентификатору(ИдентификаторУзла);
		КонецЕсли;
		ЗаполнитьРекурсивноКэшПеретаскивания(КэшПеретаскивания.Дерево, КэшПеретаскивания, УзелИсточник, Неопределено, ШаблонУзла);
		
	КонецЦикла;	
	
	Возврат КэшПеретаскивания;

КонецФункции

Функция ПроверкаПеретаскивания(СтруктураГруппы, ЗначениеПеретаскивания, ИдентификаторСтрокиИсточника, ТекстОтказа) Экспорт
	
	ОрганизацииИсточники = ЗначениеПеретаскивания.ОрганизацииИсточники;
	Элиминирующие = ЗначениеПеретаскивания.Элиминирующие;		
	
	ТекущаяСтрокаПриемник = ПолучитьСтрокуПриемникПеретаскивания(СтруктураГруппы, ИдентификаторСтрокиИсточника);
	
	Если ТекущаяСтрокаПриемник = Неопределено Тогда
		
		Если Не ПроверитьПовторОрганизаций(СтруктураГруппы.ПолучитьЭлементы(), ОрганизацииИсточники, ТекущаяСтрокаПриемник, ТекстОтказа) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Для каждого УзелПеретаскивания Из ЗначениеПеретаскивания.Дерево Цикл			
			Если УзелПеретаскивания.ЭлиминирующаяОрганизация Тогда
				ТекстОтказа = Нстр("ru = 'Элиминирующая организация не может находится на первом уровне'");	
				Возврат Ложь;
			КонецЕсли;		
		КонецЦикла;
		       		
	Иначе 
		
		Если ТекущаяСтрокаПриемник.ЭлиминирующаяОрганизация Тогда
			ТекстОтказа = Нстр("ru = 'Элиминирующая организация не может иметь консолидируемые компании'");
			Возврат Ложь;
		КонецЕсли;
		
		Если Не ПроверитьПовторОрганизаций(ТекущаяСтрокаПриемник.ПолучитьЭлементы(), ОрганизацииИсточники, ТекущаяСтрокаПриемник, ТекстОтказа) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Если Не ПроверкаЗацикливанияКонсолидируемых(СтруктураГруппы, ОрганизацииИсточники, ТекущаяСтрокаПриемник, ТекстОтказа) Тогда		
			Возврат Ложь;
		КонецЕсли;
	
	КонецЕсли;
	
	Если Не ПроверкаЭлиминирующих(СтруктураГруппы, Элиминирующие, ТекстОтказа) Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат Истина;

КонецФункции

Функция ПроверитьПовторОрганизаций(ОбъектыИнвестированияПриемника, ОрганизацииИсточники, ТекущаяСтрокаПриемник = Неопределено, ТекстОтказа = Неопределено)
	
	Для каждого УзелОбъектИнвестирования Из ОбъектыИнвестированияПриемника Цикл
		
		Если ОрганизацииИсточники.Получить(УзелОбъектИнвестирования.ОрганизационнаяЕдиница) = Истина Тогда
			
			СтрокаШаблона = НСтр("ru = 'В группе <%1> уже содержится организация <%2>'");
			
			ТекстОтказа = "";
			Если ЗначениеЗаполнено(СтрокаШаблона) тогда	
				ТекстОтказа = СтрШаблон(СтрокаШаблона, ?(ТекущаяСтрокаПриемник = Неопределено, НСтр("ru = 'верхнего уровня'"), ТекущаяСтрокаПриемник.ОрганизационнаяЕдиница), УзелОбъектИнвестирования.ОрганизационнаяЕдиница);
			КонецЕсли;
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;

КонецФункции

Функция ПроверкаЭлиминирующих(СтруктураГруппы, Элиминирующие, ТекстОтказа)
	
	ОтборСтрок = Новый Структура("ЭлиминирующаяОрганизация", Истина);
	УзлыЭлиминации = ПолучитьУзлыДерева(СтруктураГруппы, ОтборСтрок);
	Для каждого УзелЭлиминация Из УзлыЭлиминации Цикл
		
		КонсолидирующаяИсточник = Элиминирующие.Получить(УзелЭлиминация.ОрганизационнаяЕдиница);
		Если КонсолидирующаяИсточник = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если КонсолидирующаяИсточник <> УзелЭлиминация.ПолучитьРодителя().ОрганизационнаяЕдиница Тогда
			
			СтрокаШаблона = НСтр("ru = 'Для добавляемой элиминирующей организации <%1> уже указана консолидирующая <%2>'");
			
			ТекстОтказа = "";
			Если ЗначениеЗаполнено(СтрокаШаблона) тогда
				ТекстОтказа = СтрШаблон(СтрокаШаблона, УзелЭлиминация.ОрганизационнаяЕдиница, УзелЭлиминация.ПолучитьРодителя().ОрганизационнаяЕдиница);
			КонецЕсли;
			
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина; 

КонецФункции

Функция ПроверкаЗацикливанияКонсолидируемых(СтруктураГруппы, ОрганизацииИсточники, ТекущаяСтрокаПриемник = Неопределено, ТекстОтказа = Неопределено)
	
	ОтборСтрок = Новый Структура("ОрганизационнаяЕдиница", ТекущаяСтрокаПриемник.ОрганизационнаяЕдиница);
	УзлыПриемники = ПолучитьУзлыДерева(СтруктураГруппы, ОтборСтрок);
	
	Для каждого СтрокаПриемник Из УзлыПриемники Цикл
		
		ТекущийРодитель = СтрокаПриемник;
		
		Пока Истина Цикл
			
			Если ОрганизацииИсточники.Получить(ТекущийРодитель.ОрганизационнаяЕдиница) <> Неопределено Тогда
				
				СтрокаШаблона = НСтр("ru = 'Зацикливание организации: %1'");
				
				ТекстОтказа = "";
				Если ЗначениеЗаполнено(СтрокаШаблона) тогда
					ТекстОтказа = СтрШаблон(СтрокаШаблона, ТекущийРодитель.ОрганизационнаяЕдиница);
				КонецЕсли;
								
				Возврат Ложь;
				
			КонецЕсли;
			
			ТекущийРодитель = ТекущийРодитель.ПолучитьРодителя();
			Если ТекущийРодитель = Неопределено Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Истина;

КонецФункции

Процедура ЗаполнитьРекурсивноКэшПеретаскивания(УзелДерева, КэшПеретаскивания, УзелИсточник, УзелРодитель = Неопределено, ШаблонУзла)
	
	КэшПеретаскивания.ОрганизацииИсточники.Вставить(УзелИсточник.ОрганизационнаяЕдиница, УзелРодитель = Неопределено);
	Если УзелИсточник.ЭлиминирующаяОрганизация И (УзелРодитель <> Неопределено) Тогда
		КэшПеретаскивания.Элиминирующие.Вставить(УзелИсточник.ОрганизационнаяЕдиница, УзелРодитель.ОрганизационнаяЕдиница);
	КонецЕсли;
		
	ДочерниеУзлы = Новый Массив;
	
	Если ТипЗнч(УзелИсточник) = Тип("ДанныеФормыЭлементДерева") Тогда		
		ДочерниеИсточники = УзелИсточник.ПолучитьЭлементы();		
	ИначеЕсли ТипЗнч(УзелИсточник) = Тип("СтрокаТаблицыЗначений") Тогда
		ДочерниеИсточники = УзелИсточник.Владелец().НайтиСтроки(Новый Структура("Родитель", УзелИсточник.ОрганизационнаяЕдиница));
	Иначе
		ДочерниеИсточники = УзелИсточник.ПолучитьЭлементы();
	КонецЕсли;
	
	Для каждого ДочернийИсточник Из ДочерниеИсточники Цикл
		ЗаполнитьРекурсивноКэшПеретаскивания(ДочерниеУзлы, КэшПеретаскивания, ДочернийИсточник, УзелИсточник, ШаблонУзла)
	КонецЦикла;
	
	РеквизитыУзла = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(ШаблонУзла);
	ЗаполнитьЗначенияСвойств(РеквизитыУзла, УзелИсточник);	
	РеквизитыУзла.Вставить("Строки", ДочерниеУзлы);	
	
	УзелДерева.Добавить(РеквизитыУзла);

КонецПроцедуры

Функция ПолучитьСтруктуруУзла(СтруктураГруппы)

	СтруктураУзла = Новый Структура;
	
	Для каждого КолонкаИсточник Из СтруктураГруппы.Колонки Цикл	
		СтруктураУзла.Вставить(КолонкаИсточник.Имя);	
	КонецЦикла;
	
	Возврат СтруктураУзла;	 

КонецФункции

Функция ПолучитьСтрокуПриемникПеретаскивания(СтруктураГруппы, ИдентификаторСтроки) 

	Если ИдентификаторСтроки = Неопределено Тогда
		Возврат Неопределено;
	Иначе
		
		СтрокаДерева = СтруктураГруппы.НайтиПоИдентификатору(ИдентификаторСтроки);
		Если СтрокаДерева.ЭлиминирующаяОрганизация Тогда
			Возврат СтрокаДерева;//.ПолучитьРодителя();
		Иначе
			Возврат СтрокаДерева;
		КонецЕсли;
		
	КонецЕсли;

КонецФункции

Функция ПолучитьЗеркальныеСтрокиПриемники(СтруктураГруппы, СтрокаПриемник)

	МассивСтрокПриемников = Новый Массив;
	Если СтрокаПриемник = Неопределено Тогда
		МассивСтрокПриемников.Добавить(СтруктураГруппы);
	Иначе
		МассивСтрокПриемников = ПолучитьМассивСтрокОрганизационнойЕдиницы(СтрокаПриемник.ОрганизационнаяЕдиница, СтруктураГруппы);
	КонецЕсли;

	Возврат МассивСтрокПриемников;
	
КонецФункции

Функция ПолучитьУзлыДерева(Дерево, Отбор, ТолькоТекущийУровень = Ложь)

	СтрокиПриемники = Новый Массив;	
	ОбщегоНазначенияКлиентСерверУХ.МножественныйПоискПоДеревуЗначений(СтрокиПриемники, Дерево, Отбор, ТолькоТекущийУровень);	
	Возврат СтрокиПриемники;
	
КонецФункции

Функция ЕстьПодчиненныеТолькоПросмотр(ЭлементДерева) Экспорт 
	
	Для Каждого Элемент Из ЭлементДерева.ПолучитьЭлементы() Цикл
		Если Элемент.ТолькоПросмотр Тогда
			Возврат Истина;
		ИначеЕсли ЕстьПодчиненныеТолькоПросмотр(Элемент) Тогда
			Возврат Истина; 
		КонецЕсли;
	КонецЦикла; 
	
	Возврат Ложь;
	
КонецФункции

Процедура УдалитьСтрокуСтруктурыГруппы(СтруктураГруппы, Строка) Экспорт
	
	Если Строка = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ОрганизационнаяЕдиница = Строка.ОрганизационнаяЕдиница;
	ТекущиеДанныеРодитель = Строка.ПолучитьРодителя();
	
	Если ТекущиеДанныеРодитель = Неопределено Тогда
		СтруктураГруппы.ПолучитьЭлементы().Удалить(Строка);
	Иначе
		
		УзлыПоРодителю = ТекущиеДанныеРодитель.ПолучитьЭлементы();
		УзлыПоРодителю.Удалить(Строка);
		
		ОбработатьСтрокуТЧ(ТекущиеДанныеРодитель, Новый Структура("ЗаполнитьКартинкуСтрок,ЗаполнитьЯвляетсяКонсолидирующей"));
		
		МассивСтрок = ПолучитьМассивСтрокОрганизационнойЕдиницы(ОрганизационнаяЕдиница, СтруктураГруппы, ТекущиеДанныеРодитель.ОрганизационнаяЕдиница);
		Для Каждого Узел Из МассивСтрок Цикл
			
			УзелРодитель = Узел.ПолучитьРодителя();
			УзлыРодителя = УзелРодитель.ПолучитьЭлементы();
			УзлыРодителя.Удалить(Узел);			
			ОбработатьСтрокуТЧ(УзелРодитель, Новый Структура("ЗаполнитьКартинкуСтрок,ЗаполнитьЯвляетсяКонсолидирующей"));
			
		КонецЦикла;
		
	КонецЕсли;
		
КонецПроцедуры

Процедура ПереместитьСтрокуСтруктуруГруппы(СтруктураГруппы, Строка, Количество) Экспорт
	
	Если Строка = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Родитель = Строка.ПолучитьРодителя();
	Если Родитель = Неопределено Тогда
		
		ТекущиеЭлементы = СтруктураГруппы.ПолучитьЭлементы();
		Попытка
			ТекущиеЭлементы.Сдвинуть(ТекущиеЭлементы.Индекс(Строка), Количество);
		Исключение
		КонецПопытки;
		
	Иначе
		
		ТекущиеЭлементы = Родитель.ПолучитьЭлементы();
		Индекс = ТекущиеЭлементы.Индекс(Строка);
		Если НЕ (Индекс + Количество < 0 ИЛИ Индекс + Количество > ТекущиеЭлементы.Количество() - 1) Тогда
			
			МассивСтрок = РегламентыКлиентСервер.ПолучитьМассивСтрокОрганизационнойЕдиницы(Строка.ОрганизационнаяЕдиница, СтруктураГруппы, Родитель.ОрганизационнаяЕдиница);
			Для Каждого Элемент Из МассивСтрок Цикл
				Элемент.ПолучитьРодителя().ПолучитьЭлементы().Сдвинуть(Индекс, Количество);
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
		
КонецПроцедуры

#КонецОбласти

#Область ДополнитьСтруктуруГруппы

Функция ДополнитьСтруктуруГруппы(СтруктураГруппы, ИдентификаторСтрокаПриемник, ПараметрыПеретаскивания, 
									КэшПеретаскивания = Неопределено) Экспорт

	Перем РеквизитыОрганизаций;
	
	СтрокаПриемник = ПолучитьСтрокуПриемникПеретаскивания(СтруктураГруппы, ИдентификаторСтрокаПриемник);
	УзлыПриемники = ПолучитьЗеркальныеСтрокиПриемники(СтруктураГруппы, СтрокаПриемник);
	
	ЗаполнитьОтношениеКГруппе = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(КэшПеретаскивания, "ЗаполнитьОтношениеКГруппе");

	Если Не КэшПеретаскивания.Свойство("РеквизитыОрганизаций", РеквизитыОрганизаций) Тогда
		
		Организации = Новый Массив;
		Для каждого Узел Из КэшПеретаскивания.Дерево Цикл
			ПолучитьОрганизацииДерева(Организации, Узел, Истина);
		КонецЦикла;
		
		РеквизитыОрганизаций = РегламентыВызовСервера.ПолучитьРеквизитыОрганизаций(
				Организации, КэшПеретаскивания.Сценарий, КэшПеретаскивания.Период);
		КэшПеретаскивания.Вставить("РеквизитыОрганизаций", РеквизитыОрганизаций);
	
	КонецЕсли;
	
	Для Каждого УзелПриемник Из УзлыПриемники Цикл		
		ДобавитьУзелРекурсивно(УзелПриемник, КэшПеретаскивания.Дерево, , ЗаполнитьОтношениеКГруппе, КэшПеретаскивания);
	КонецЦикла;
	
	КэшПеретаскивания = Неопределено;
	
КонецФункции

Процедура ДобавитьУзелРекурсивно(УзелПриемник, УзлыИсточники, Источник = Неопределено, 
			ЗаполнитьОтношениеКГруппе = Неопределено, КэшируемыеЗначения = Неопределено)
	
	КоллекцияПриемник = УзелПриемник.ПолучитьЭлементы();
	
	Для Каждого УзелИсточник Из УзлыИсточники Цикл
		
		НоваяСтрока = КоллекцияПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, УзелИсточник, , "ДополнительныеВалюты");
		НоваяСтрока.ДополнительныеВалюты.ЗагрузитьЗначения(УзелИсточник.ДополнительныеВалюты.ВыгрузитьЗначения());		
		Если НоваяСтрока.ПолучитьРодителя() <> Неопределено Тогда
			НоваяСтрока.КонсолидирующаяОрганизацияОтображение = НоваяСтрока.ПолучитьРодителя().ОрганизационнаяЕдиница;
		КонецЕсли;
		
		СтруктураДействий = Новый Структура("ЗаполнитьВалюты,ЗаполнитьРеквизитыОрганизации", Новый Структура("ОбновитьДочерние", Ложь));
		Если ЗначениеЗаполнено(ЗаполнитьОтношениеКГруппе) Тогда
			СтруктураДействий.Вставить("ЗаполнитьОтношениеКГруппе", ЗаполнитьОтношениеКГруппе);
		КонецЕсли;
		
		КэшируемыеЗначенияСтроки = ?(КэшируемыеЗначения = Неопределено, Новый Структура, КэшируемыеЗначения);
		КэшируемыеЗначенияСтроки.Вставить("ТекущийРодитель", УзелПриемник);
		ОбработатьСтрокуТЧ(НоваяСтрока, СтруктураДействий, КэшируемыеЗначенияСтроки);
		
		ДобавитьУзелРекурсивно(НоваяСтрока, УзелИсточник.Строки,, ЗаполнитьОтношениеКГруппе, КэшируемыеЗначенияСтроки);
						
	КонецЦикла;
	
	Если ТипЗнч(УзелПриемник) <> Тип("ДанныеФормыДерево") Тогда
		ОбработатьСтрокуТЧ(УзелПриемник, Новый Структура("ЗаполнитьЯвляетсяКонсолидирующей, ЗаполнитьКартинкуСтрок, ЗаполнитьЯвляетсяЦФО"));
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьМатеринские(ТекущаяСтрока, ОтношенияМатеринское) Экспорт
	
	Материнские = Новый Массив;	
	Для каждого СтрокаТаб Из ТекущаяСтрока.ПолучитьЭлементы() Цикл		
		Если ОтношенияМатеринское.Найти(СтрокаТаб.ОтношениеКГруппе) <> Неопределено Тогда
			Материнские.Добавить(СтрокаТаб.ОрганизационнаяЕдиница);
		КонецЕсли;		
	КонецЦикла;
	
	Возврат Материнские; 

КонецФункции

#КонецОбласти

#Область ЗаполнитьСтрокуРегламента

Процедура ЗаполнитьВалюты(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения)

	Перем ТекущийРодитель, РеквизитыОрганизаций, РеквизитыДействия;
	
	Если Не СтруктураДействий.Свойство("ЗаполнитьВалюты", РеквизитыДействия) Тогда
		Возврат;
	КонецЕсли;
	
	Если Не КэшируемыеЗначения.Свойство("ТекущийРодитель", ТекущийРодитель) 
		Или (ТипЗнч(ТекущийРодитель) = Тип("ДанныеФормыДерево")) Тогда
		ТекущийРодитель = Новый Структура("ОсновнаяВалюта,ДополнительныеВалюты", , Новый СписокЗначений);
	КонецЕсли;
	
	ОбновитьДочерние = (РеквизитыДействия <> Неопределено) И РеквизитыДействия.Свойство("ОбновитьДочерние") 
							И (РеквизитыДействия.ОбновитьДочерние = Истина);
	
	Если Не КэшируемыеЗначения.Свойство("РеквизитыОрганизаций", РеквизитыОрганизаций) Тогда
		
		Организации = СтрокаТЧ.ОрганизационнаяЕдиница;
		Если ОбновитьДочерние Тогда
			
			КореньДерева = ПолучитьКореньДерева(КэшируемыеЗначения, СтрокаТЧ);	
			Организации = ПолучитьОрганизацииДерева(Новый Массив, КореньДерева, ОбновитьДочерние);
		
		КонецЕсли;
		
		РеквизитыОрганизаций = РегламентыВызовСервера.ПолучитьРеквизитыОрганизаций(
				Организации, КэшируемыеЗначения.Сценарий, КэшируемыеЗначения.Период);
		КэшируемыеЗначения.Вставить("РеквизитыОрганизаций", РеквизитыОрганизаций);
		
	КонецЕсли;	
    
	ОбновитьВалютыРекурсивно(СтрокаТЧ, ТекущийРодитель, РеквизитыОрганизаций, ОбновитьДочерние);
	
КонецПроцедуры

Функция ПолучитьКореньДерева(КэшируемыеЗначения, СтрокаТЧ)
	
	КореньДерева = СтрокаТЧ;	
	
	Если КэшируемыеЗначения.Свойство("ТекущийРодитель") И ТипЗнч(КэшируемыеЗначения.ТекущийРодитель) = Тип("ДанныеФормыДерево") Тогда
		Возврат КэшируемыеЗначения.ТекущийРодитель;
	КонецЕсли;	
	
	Пока Истина Цикл
		
		Если КореньДерева.ПолучитьРодителя() = Неопределено Тогда
			Возврат КореньДерева;		
		КонецЕсли;
		
		КореньДерева = КореньДерева.ПолучитьРодителя();
			
	КонецЦикла;

КонецФункции

Функция ПолучитьОрганизацииДерева(Организации, УзелДереваДляПолученияДочерних, Рекурсивно = Истина)
	
	Если ТипЗнч(УзелДереваДляПолученияДочерних) <> Тип("ДанныеФормыДерево") Тогда
		Организации.Добавить(УзелДереваДляПолученияДочерних.ОрганизационнаяЕдиница);
	КонецЕсли;
	
	Если Не Рекурсивно Тогда
		Возврат Организации;
	КонецЕсли;
	
	Если ТипЗнч(УзелДереваДляПолученияДочерних) = Тип("Структура") Тогда
		Дочерние = УзелДереваДляПолученияДочерних.Строки;
	Иначе	
		Дочерние = УзелДереваДляПолученияДочерних.ПолучитьЭлементы();
	КонецЕсли;
	
	Для каждого Дочерний Из Дочерние Цикл
		ПолучитьОрганизацииДерева(Организации, Дочерний);
	КонецЦикла;
	
	Возврат Организации;

КонецФункции

Процедура ОбновитьВалютыРекурсивно(СтрокаТЧ, ТекущийРодитель, РеквизитыОрганизаций, ОбновитьДочерние = Истина, КэшируемыеЗначения = Неопределено)
	
	РеквизитыОрганизации = РеквизитыОрганизаций.Получить(СтрокаТЧ.ОрганизационнаяЕдиница);
	Если РеквизитыОрганизации = Неопределено Тогда
		
		Рекв = ОбщегоНазначенияУХ.ПолучитьЗначенияРеквизитов(СтрокаТЧ.ОрганизационнаяЕдиница, "ФункциональнаяВалюта");
		РеквизитыОрганизации = Новый Структура("ОсновнаяВалюта, ДополнительнаяВалюта", 
				Рекв.ФункциональнаяВалюта, Рекв.ФункциональнаяВалюта);
		
	КонецЕсли;
	
	РеквизитыОрганизации.Вставить("ОсновнаяВалюта", ОбщегоНазначенияСерверУХ.ПолучитьВалютуРегламентированногоУчета(РеквизитыОрганизации.ОсновнаяВалюта));
	РеквизитыОрганизации.Вставить("ДополнительнаяВалюта", ОбщегоНазначенияСерверУХ.ПолучитьВалютуУправленческогоУчета(РеквизитыОрганизации.ДополнительнаяВалюта));
			
	ИсточникДерево = Ложь;
	
	СтрокаТЧ.ОсновнаяВалюта = РеквизитыОрганизации.ОсновнаяВалюта;
	
	ДопВалютаКУдалению = СтрокаТЧ.ДополнительныеВалюты.НайтиПоЗначению(СтрокаТЧ.ОсновнаяВалюта);
	Если ДопВалютаКУдалению <> неопределено тогда
		СтрокаТЧ.ДополнительныеВалюты.Удалить(ДопВалютаКУдалению);
	КонецЕсли;
	
	МассивРодителей = Новый Массив;
	МассивРодителей.Добавить(ТекущийРодитель);
	
	Если ТипЗнч(ТекущийРодитель) = Тип("ДанныеФормыЭлементДерева") тогда
		
		РодительЭлемента = ТекущийРодитель.ПолучитьРодителя();
		
		Пока РодительЭлемента <> неопределено Цикл
			Если МассивРодителей.Найти(РодительЭлемента) = неопределено тогда
				МассивРодителей.Добавить(РодительЭлемента);
				РодительЭлемента = РодительЭлемента.ПолучитьРодителя();
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Для Каждого ТекущийРодитель Из МассивРодителей Цикл
		
		ЕстьРодитель = Не (ТипЗнч(ТекущийРодитель) = Тип("ДанныеФормыДерево"));
		
		#Если Сервер Тогда
			
			ИсточникДерево = (ТипЗнч(ТекущийРодитель) = Тип("ДеревоЗначений")) 
				Или (ТипЗнч(ТекущийРодитель) = Тип("СтрокаДереваЗначений")) 
				Или (ТипЗнч(ТекущийРодитель) = Тип("КоллекцияСтрокДереваЗначений"));
			ЕстьРодитель = ЕстьРодитель И Не (ТипЗнч(ТекущийРодитель) = Тип("ДеревоЗначений")) ;
			
		#КонецЕсли
				
		ДобавитьДополнительнуюВалюту(СтрокаТЧ.ДополнительныеВалюты, СтрокаТЧ.ОсновнаяВалюта, РеквизитыОрганизации.ДополнительнаяВалюта);
		
		Если ЕстьРодитель Тогда
			
			ДобавитьДополнительнуюВалюту(СтрокаТЧ.ДополнительныеВалюты, СтрокаТЧ.ОсновнаяВалюта, ТекущийРодитель.ОсновнаяВалюта);
			Для каждого ЭлементВалюта Из ТекущийРодитель.ДополнительныеВалюты Цикл
				ДобавитьДополнительнуюВалюту(СтрокаТЧ.ДополнительныеВалюты, СтрокаТЧ.ОсновнаяВалюта, ЭлементВалюта.Значение);
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ОбновитьДочерние Тогда
		Возврат;
	КонецЕсли;
			
	СтрокиДочерние = ?(ИсточникДерево, СтрокаТЧ.Строки, СтрокаТЧ.ПолучитьЭлементы());
	Для каждого ДочерняяСтрока Из СтрокиДочерние Цикл
		ОбновитьВалютыРекурсивно(ДочерняяСтрока, СтрокаТЧ, РеквизитыОрганизаций, ОбновитьДочерние)	
	КонецЦикла;	

КонецПроцедуры

Процедура ЗаполнитьРеквизитыОрганизации(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения)

	Перем РеквизитыОрг;
	
	Если Не СтруктураДействий.Свойство("ЗаполнитьРеквизитыОрганизации") Тогда
		Возврат;
	КонецЕсли;
	
	ТекстРеквизиты = "ПометкаУдаления,ВидОрганизацииПоУмолчанию,ИспользоватьВРегламентированномУчете,ИностранныйНалоговыйРезидент,ЭлиминирующаяОрганизация";
	
	Если КэшируемыеЗначения.Свойство("РеквизитыОрганизаций") Тогда
		РеквизитыОрг = КэшируемыеЗначения.РеквизитыОрганизаций.Получить(СтрокаТЧ.ОрганизационнаяЕдиница);	
	КонецЕсли;
	
	Если РеквизитыОрг = Неопределено Тогда
		РеквизитыОрг = ОбщегоНазначенияУХ.ЗначенияРеквизитовОбъекта(СтрокаТЧ.ОрганизационнаяЕдиница, ТекстРеквизиты);
	Иначе 
		РеквОрг = Новый Структура(ТекстРеквизиты + ", ВидОрганизационнойЕдиницы");
		ЗаполнитьЗначенияСвойств(РеквОрг, РеквизитыОрг);
		РеквизитыОрг = РеквОрг;		
	КонецЕсли;
	
	Если Не РеквизитыОрг.Свойство("ВидОрганизационнойЕдиницы") И РеквизитыОрг.Свойство("ВидОрганизацииПоУмолчанию") Тогда
		РеквизитыОрг.Вставить("ВидОрганизационнойЕдиницы", РеквизитыОрг.ВидОрганизацииПоУмолчанию);
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(СтрокаТЧ, РеквизитыОрг);
		
КонецПроцедуры

Процедура ЗаполнитьДочерние(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения)

	Если Не СтруктураДействий.Свойство("ЗаполнитьДочерние") Тогда
		Возврат;
	КонецЕсли;

	Если ТипЗнч(СтрокаТЧ) = Тип("ДанныеФормыДерево") Или ТипЗнч(СтрокаТЧ) = Тип("ДанныеФормыЭлементДерева") Тогда
		ОбработатьСтрокиТЧ(СтрокаТЧ.ПолучитьЭлементы(), СтруктураДействий, КэшируемыеЗначения);
	Иначе 
		ОбработатьСтрокиТЧ(СтрокаТЧ.Строки, СтруктураДействий, КэшируемыеЗначения);	
	КонецЕсли;	

КонецПроцедуры

Процедура ЗаполнитьЕстьУтвержденные(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения)

	Если Не СтруктураДействий.Свойство("ЗаполнитьЕстьУтвержденные") Тогда
		Возврат;
	КонецЕсли;
	
	СтрокаТЧ.ТолькоПросмотр = (КэшируемыеЗначения.УтвержденныеЭкземпляры.Найти(СтрокаТЧ.ОрганизационнаяЕдиница) <> Неопределено);
		
КонецПроцедуры

Процедура ЗаполнитьЯвляетсяКонсолидирующей(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения)

	Если Не СтруктураДействий.Свойство("ЗаполнитьЯвляетсяКонсолидирующей") Тогда
		Возврат;
	КонецЕсли;
	
	СтрокаТЧ.ЯвляетсяКонсолидирующей = ЯвляетсяКонсолидирующей(СтрокаТЧ);

КонецПроцедуры

Процедура ЗаполнитьЭффективнуюДолю(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения) Экспорт

	Если Не СтруктураДействий.Свойство("ЗаполнитьЭффективнуюДолю") Тогда
		Возврат;
	КонецЕсли;		
		
	СтрокаТЧ.ЭффективнаяДоля = 0;
		
	Статусы = КэшируемыеЗначения.ОбъектыИнвестирования.Получить(СтрокаТЧ.ОрганизационнаяЕдиница);
	Если Статусы = Неопределено Тогда
		Возврат;	
	КонецЕсли;			
	
	СтрокаТЧ.ЭффективнаяДоля = Статусы.ЭффективнаяДоля;
	
КонецПроцедуры

Процедура ЗаполнитьОтношениеКГруппе(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения) Экспорт

	Перем СпособЗаполнения;
	
	Если Не СтруктураДействий.Свойство("ЗаполнитьОтношениеКГруппе", СпособЗаполнения) Тогда
		Возврат;
	КонецЕсли;
	
	Если СпособЗаполнения = "ВсеДочки" Тогда
		
		Если Не КэшируемыеЗначения.Свойство("ОтношениеКГруппе_Дочернее") Тогда
			КэшируемыеЗначения.Вставить("ОтношениеКГруппе_Дочернее", РегламентыВызовСервера.ПолучитьСтатусДочернее());
		КонецЕсли;
		
		СтрокаТЧ.ЭффективнаяДоля = 100;
		СтрокаТЧ.ОтношениеКГруппе = КэшируемыеЗначения.ОтношениеКГруппе_Дочернее;
		
		Возврат;
		
	ИначеЕсли СпособЗаполнения = "ПоУмолчанию" Тогда	
		
		СтрокаТЧ.ОтношениеКГруппе = ОбщегоНазначенияУХ.ПолучитьЗначениеРеквизита(СтрокаТЧ.ОрганизационнаяЕдиница, "ГруппаКонтрагента");
		СтрокаТЧ.ЭффективнаяДоля = 100;
		
		Если Не ЗначениеЗаполнено(СтрокаТЧ.ОтношениеКГруппе) Тогда
			
			Если Не КэшируемыеЗначения.Свойство("ОтношениеКГруппе_Дочернее") Тогда
				КэшируемыеЗначения.Вставить("ОтношениеКГруппе_Дочернее", РегламентыВызовСервера.ПолучитьСтатусДочернее());
			КонецЕсли;
			СтрокаТЧ.ОтношениеКГруппе = КэшируемыеЗначения.ОтношениеКГруппе_Дочернее;
			
		КонецЕсли;
		
		Возврат;
		
	КонецЕсли;
	
	Если Не КэшируемыеЗначения.Свойство("ОтношенияМатеринское") Тогда
		Возврат;// нет параметров для расчета
	КонецЕсли;
	
	Если КэшируемыеЗначения.ОтношенияМатеринское.Найти(СтрокаТЧ.ОтношениеКГруппе) <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если КэшируемыеЗначения.Свойство("ОбъектыИнвестирования") Тогда
		
		Статусы = КэшируемыеЗначения.ОбъектыИнвестирования.Получить(СтрокаТЧ.ОрганизационнаяЕдиница);
		Если Статусы = Неопределено Тогда
			Возврат;	
		КонецЕсли;			
	
	КонецЕсли;
	
	Если СпособЗаполнения = "ВсеДочки" Тогда
		//**СтрокаТЧ.ОтношениеКГруппе = ;		
	Иначе 
		СтрокаТЧ.ОтношениеКГруппе = Статусы.ОтношениеКГруппе;
	КонецЕсли;
	
	
	Если Статусы.Свойство("МетодИсключенияВГО") Тогда
		СтрокаТЧ.МетодИсключенияВГО = Статусы.МетодИсключенияВГО;
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьМетодИсключенияВГО(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения) Экспорт

	Если Не СтруктураДействий.Свойство("ЗаполнитьМетодИсключенияВГО") Тогда
		Возврат;
	КонецЕсли;
	
	Если КэшируемыеЗначения.Свойство("ОбъектыИнвестирования") Тогда
	
		Статусы = КэшируемыеЗначения.ОбъектыИнвестирования.Получить(СтрокаТЧ.ОрганизационнаяЕдиница);
		Если (Статусы <> Неопределено) И Статусы.Свойство("МетодИсключенияВГО") Тогда
			СтрокаТЧ.МетодИсключенияВГО = Статусы.МетодИсключенияВГО;
			Возврат;
		КонецЕсли;		
	
	КонецЕсли;
	
	РеквизитыОрганизации = ОбщегоНазначенияУХ.ПолучитьЗначенияРеквизитов(СтрокаТЧ.ОрганизационнаяЕдиница, "ИспользоватьВРегламентированномУчете,ИностранныйНалоговыйРезидент");
	
	Если РеквизитыОрганизации.ИспользоватьВРегламентированномУчете Или РеквизитыОрганизации.ИностранныйНалоговыйРезидент Тогда
		
		ВидОтношенияКГруппе = ОбщегоНазначенияУХ.ПолучитьЗначениеРеквизита(СтрокаТЧ.ОтношениеКГруппе, "ВидОтношенияКГруппе");
		
		Если (ВидОтношенияКГруппе = ПредопределенноеЗначение("Перечисление.ВидыОтношенийКГруппе.Материнское")) 
			Или (ВидОтношенияКГруппе = ПредопределенноеЗначение("Перечисление.ВидыОтношенийКГруппе.Материнское")) Тогда
		
			СтрокаТЧ.МетодИсключенияВГО = ПредопределенноеЗначение("Перечисление.МетодыИсключенияВГО.ОстаткиИОбороты");
			
		Иначе
			
			СтрокаТЧ.МетодИсключенияВГО = ПредопределенноеЗначение("Перечисление.МетодыИсключенияВГО.Обороты");
		
		КонецЕсли;
		
	Иначе // Элиминирующая,ЦФО, консолидирующая	
		СтрокаТЧ.МетодИсключенияВГО = ПредопределенноеЗначение("Перечисление.МетодыИсключенияВГО.ОстаткиИОбороты");	
	КонецЕсли;
			
КонецПроцедуры

Процедура ЗаполнитьЯвляетсяЦФО(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения)
	
	Перем РеквизитыОрганизации;
	
	Если Не СтруктураДействий.Свойство("ЗаполнитьЯвляетсяЦФО") Тогда
		Возврат;
	КонецЕсли;

	Если СтрокаТЧ.ПолучитьЭлементы().Количество() Тогда// консолидирующая
		СтрокаТЧ.ЯвляетсяЦФО = Ложь;
	Иначе 
		
		СтрокаТЧ.ЯвляетсяЦФО = Не СтрокаТЧ.ИспользоватьВРегламентированномУчете 
								И Не СтрокаТЧ.ИностранныйНалоговыйРезидент
								И Не СтрокаТЧ.ЭлиминирующаяОрганизация;
		
	КонецЕсли;
		
КонецПроцедуры

Процедура ЗаполнитьКартинкуСтрок(СтрокаТЧ, СтруктураДействий, КэшируемыеЗначения) Экспорт
		
	Если Не СтруктураДействий.Свойство("ЗаполнитьКартинкуСтрок") Тогда
		Возврат;
	КонецЕсли;
		
	СтрокаТЧ.КартинкаСтрок = ПолучитьКартинкуСтрокиОрганизации(
									СтрокаТЧ.ЭлиминирующаяОрганизация,
									СтрокаТЧ.ЯвляетсяКонсолидирующей,
									СтрокаТЧ.ПометкаУдаления
								);
	
КонецПроцедуры

#КонецОбласти

#Область ФункцииЗаполненияСтрок

Процедура ДобавитьДополнительнуюВалюту(ДополнительныеВалюты, ОсновнаяВалюта, ДобавляемаяВалюта)

	Если ОсновнаяВалюта = ДобавляемаяВалюта Тогда
		Возврат;
	ИначеЕсли Не ЗначениеЗаполнено(ДобавляемаяВалюта) Тогда
		Возврат;	
	ИначеЕсли ДополнительныеВалюты.НайтиПоЗначению(ДобавляемаяВалюта) <> Неопределено Тогда
		Возврат;		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ОсновнаяВалюта) Тогда
		ДополнительныеВалюты.Добавить(ДобавляемаяВалюта);
	Иначе	
		ОсновнаяВалюта = ДобавляемаяВалюта;
	КонецЕсли;	
	
КонецПроцедуры

Функция ЯвляетсяКонсолидирующей(УзелДерева)
	Возврат (УзелДерева.ПолучитьЭлементы().Количество() > 0) Или (УзелДерева.ПолучитьРодителя() = Неопределено);	
КонецФункции

Функция ПолучитьКартинкуСтрокиОрганизации(Элиминирующая = Ложь, Консолидирующая = Ложь, ПометкаУдаления = Ложь) Экспорт
	
	Если Элиминирующая Тогда
		Результат = 2;
	ИначеЕсли Консолидирующая  Тогда
		Результат = 0;	
	Иначе
		Результат = 1;
	КонецЕсли;
	
	Результат = Результат + ?(ПометкаУдаления, 3, 0);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ДополнительныеВалюты

Функция ПолучитьМассивСтрокОрганизационнойЕдиницы(ОрганизационнаяЕдиница, СтруктураГруппы, Родитель = Неопределено) Экспорт 
	
	МассивСтрок = Новый Массив;
		
	ОбщегоНазначенияКлиентСерверУХ.МножественныйПоискПоДеревуЗначений(МассивСтрок, СтруктураГруппы, Новый Структура("ОрганизационнаяЕдиница", ОрганизационнаяЕдиница));
	
	Если НЕ Родитель = Неопределено Тогда
		
		Количество = МассивСтрок.Количество();
		Для сч = 1 По Количество Цикл
			
			Индекс = Количество-сч;
			
			Строка = МассивСтрок[Количество-сч];
			Если Строка.ПолучитьРодителя() = Неопределено Тогда
				Если НЕ Родитель.Пустая() Тогда
					МассивСтрок.Удалить(Индекс);
				КонецЕсли;
			ИначеЕсли НЕ Родитель = Строка.ПолучитьРодителя().ОрганизационнаяЕдиница Тогда
				МассивСтрок.Удалить(Индекс);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат МассивСтрок;
	
КонецФункции

#КонецОбласти
