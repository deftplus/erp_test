#Область ПроцедурыКроссТаблиц


// Преобразование Таблицы в Кросс-таблицу с переносом значений реквизитов периода в колонки кросс-таблицы.
//
// Параметры:
//  КроссТаблица - ДанныеФормы.Коллекция - Кросс-таблица в форме
//  Таблица      - ДанныеФормы.Коллекция - Табличная часть объекта
//  Параметры    - Структура - Дополнительные настройки, передаваемые в процедуру:
//                            ТаблицаПериоды, Периодичность, СтруктураРеквизитовПериода, СтруктураРеквизитов, 
//                            ПоляГруппировки
//
Процедура ЗаполнитьКроссТаблицуИзТаблицы(КроссТаблица, Таблица, Параметры) Экспорт
	
	ТаблицаПериоды             = Параметры.ТаблицаПериоды;
	Периодичность              = Параметры.Периодичность;
	СтруктураРеквизитовПериода = Параметры.СтруктураРеквизитовПериода;
	СтруктураРеквизитов        = Параметры.СтруктураРеквизитов;
	ПоляГруппировки            = Параметры.ПоляГруппировки;
	флЕстьСтарыйКоэффициент	   = Параметры.флЕстьСтарыйКоэффициент;
	
	СтруктураИтоговыхРеквизитов = Неопределено;
	Если НЕ Параметры.Свойство("СтруктураИтоговыхРеквизитов", СтруктураИтоговыхРеквизитов) Тогда
		СтруктураИтоговыхРеквизитов = Новый Структура;
	КонецЕсли;
	
	КроссТаблица.Очистить();
	
	СтрокаИсключений = "";
	Для каждого ИтоговыйРеквизит Из СтруктураИтоговыхРеквизитов Цикл
		СтрокаИсключений = СтрокаИсключений + ?(ПустаяСтрока(СтрокаИсключений), "", ", ") + ИтоговыйРеквизит.Ключ;
	КонецЦикла;
	
	Для каждого СтрокаТаблицы Из Таблица Цикл
		Отбор = Новый Структура;
		Отбор.Вставить("Активная", Истина);
		Для каждого Элемент Из СтруктураРеквизитовПериода Цикл
			Отбор.Вставить(Элемент.Ключ, СтрокаТаблицы[Элемент.Значение]);
		КонецЦикла;
		
		НайденныеСтрокиПериодов = ТаблицаПериоды.НайтиСтроки(Отбор);
		
		Если НЕ ПустаяСтрока(ПоляГруппировки) Тогда
			Отбор = Новый Структура(ПоляГруппировки);
			ЗаполнитьЗначенияСвойств(Отбор, СтрокаТаблицы);
			НаденныеСтроки = КроссТаблица.НайтиСтроки(Отбор);
			Если НаденныеСтроки.Количество()=0 Тогда
				НоваяСтрока = КроссТаблица.Добавить();
			Иначе
				НоваяСтрока = НаденныеСтроки[0];
			КонецЕсли;
		Иначе
			НоваяСтрока = КроссТаблица.Добавить();
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы,,СтрокаИсключений);
		
		Если флЕстьСтарыйКоэффициент Тогда
			НоваяСтрока.СтарыйКоэффициент = НоваяСтрока.Коэффициент;
		КонецЕсли;
		
		Если НайденныеСтрокиПериодов.Количество() = 0 Тогда 
			Продолжить;
		КонецЕсли;
		СтрокаПериода = НайденныеСтрокиПериодов[0];
		
		Для каждого Элемент Из СтруктураРеквизитов Цикл
			Если СтруктураИтоговыхРеквизитов.Свойство(Элемент.Значение) Тогда
				НоваяСтрока[Элемент.Ключ + СтрокаПериода.ИмяКолонки] = НоваяСтрока[Элемент.Ключ + СтрокаПериода.ИмяКолонки] + СтрокаТаблицы[Элемент.Значение];
			Иначе
				НоваяСтрока[Элемент.Ключ + СтрокаПериода.ИмяКолонки] = СтрокаТаблицы[Элемент.Значение];
			КонецЕсли;
		КонецЦикла;
		
		Для каждого Элемент Из СтруктураИтоговыхРеквизитов Цикл
			НоваяСтрока[Элемент.Значение] = НоваяСтрока[Элемент.Значение] + СтрокаТаблицы[Элемент.Ключ];
		КонецЦикла;
		
	КонецЦикла;
			
КонецПроцедуры

// Заполнить таблицу из кросс-таблицы с переносом значений из колонок
//  кросс-таблицы в реквизиты таблицы.
//
// Параметры:
//  КроссТаблица         - ДанныеФормы.Коллекция - Кросс-таблица в форме
//  Таблица              - ДанныеФормы.Коллекция - Табличная часть объекта
//  Параметры            - Структура - Дополнительные настройки, передаваемые в процедуру:
//                                     ТаблицаПериоды, СтруктураРеквизитовПериода, СтруктураРеквизитов
//  СтруктураДействий    - Структура - Структура действий, выполняемых со строками ТЧ.
//  ЗаменаИменРеквизитов - Структура, Соответствие - {Имя реквизита типового объекта:
//													  Имя реквизита в переданном объекте}.
//
Процедура ЗаполнитьТаблицуИзКроссТаблицы(
							Объект, 
							ИмяТаблицы, 
							КроссТаблица, 
							Параметры, 
							СтруктураДействий = Неопределено,
							ЗаменаИменРеквизитов=Неопределено) Экспорт
	ТаблицаПериоды = Параметры.ТаблицаПериоды;
	СтруктураРеквизитовПериода = Параметры.СтруктураРеквизитовПериода;
	СтруктураРеквизитов = Параметры.СтруктураРеквизитов;
	Если СтруктураДействий = Неопределено Тогда
		СтруктураДействий = Новый Структура;
	КонецЕсли;
	Таблица = Объект[ИмяТаблицы];
	Таблица.Очистить();
	Для каждого СтрокаКроссТаблицы Из КроссТаблица Цикл
		Для каждого СтрокаПериод Из ТаблицаПериоды Цикл
			Если НЕ СтрокаПериод.Активная 
					ИЛИ СтрокаПериод.НомерКолонки <= 0 Тогда 
				Продолжить 
			КонецЕсли;
			НоваяСтрока = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаКроссТаблицы);
			Для каждого Элемент Из СтруктураРеквизитовПериода Цикл
			    НоваяСтрока[Элемент.Значение] = СтрокаПериод[Элемент.Ключ];
			КонецЦикла;
			Для каждого Элемент Из СтруктураРеквизитов Цикл
				НоваяСтрока[Элемент.Значение] = 
					СтрокаКроссТаблицы[Элемент.Ключ + СтрокаПериод.ИмяКолонки];
			КонецЦикла;
			ЦентрализованныеЗакупкиКлиентСерверУХ.ОбработатьСтрокуТЧ(
				Объект, 
				НоваяСтрока, 
				ТаблицаПериоды, 
				СтруктураДействий,
				ЗаменаИменРеквизитов);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры 

// Записать кросс-таблицу в переданную таблицу значений
// или табличную часть. Не учитывает НДС. Заполняет
// вертикальные колонки кросс-таблицы: Период, Количество и Сумма.
// Остальные беруться как аналитики строк.
//
// Параметры:
//  КроссТаблица - ТаблицаЗначений - таблица с колонками
//		Количество и Сумма по каждому периоду из ТаблицаПериодов.
//  ПлоскаяТаблица - ТабличнаяЧасть | ТаблицаЗначений - таблица
//		для заполнения. Перед заполнением очищается.
//  ТаблицаПериодов - ТаблицаЗначений - периоды кросс-таблицы.
//	ЦенаВключаетНДС - Булево - значение реквизита документа.
//
Процедура ПодготовитьЗаполнитьТаблицуИзКроссТаблицы(
										КроссТаблица,
										ПлоскаяТаблица, 
										ТаблицаПериодов,
										ЦенаВключаетНДС=Неопределено, 
										Процент = Ложь) Экспорт
	Параметры = Новый Структура;
	Параметры.Вставить("ТаблицаПериоды", ТаблицаПериодов);
	Параметры.Вставить("СтруктураРеквизитовПериода",
		Новый Структура("Период", "ПериодПотребности"));
	Параметры.Вставить("СтруктураРеквизитов", 
		Новый Структура("Количество_, Сумма_", "Количество", "Сумма"));
	Если Процент = Ложь Тогда
	Параметры.Вставить("СтруктураРеквизитов", 
		Новый Структура("Количество_, Сумма_", "Количество", "Сумма"));
	Иначе
	Параметры.Вставить("СтруктураРеквизитов", 
		Новый Структура("Количество_, Сумма_, Процент_", "Количество", "Сумма", "Процент"));
	КонецЕсли;		
	Объект = Новый Структура;
	Объект.Вставить("ПлоскаяТаблица", ПлоскаяТаблица);
	Объект.Вставить("ЦенаВключаетНДС", ЦенаВключаетНДС);
	ЗаполнитьТаблицуИзКроссТаблицы(
		Объект, 
		"ПлоскаяТаблица", 
		КроссТаблица, 
		Параметры);
	Если ЦенаВключаетНДС <> Неопределено Тогда
		ЦентрализованныеЗакупкиКлиентСерверУХ.ЗаполнитьСуммуНДСТаблицы(
			ПлоскаяТаблица, 
			ЦенаВключаетНДС);
	КонецЕсли;
КонецПроцедуры

// Процедура рассчитывает добавленное поле "Номер строки" для кросс-таблицы
//
// Параметры:
//  Форма                    - УправляемаяФорма - Форма в которой есть кросс-таблица
//  ИмяРеквизитаКроссТаблицы - Строка - Имя кросс-таблицы в форме
//
Процедура РассчитатьНомерСтрокиКроссТаблицы(Форма, Знач ИмяРеквизитаКроссТаблицы) Экспорт 

	КроссТаблица = Форма[ИмяРеквизитаКроссТаблицы];
	НомерСтроки = 0;
	Для каждого СтрокаТЧ Из КроссТаблица Цикл
		
		НомерСтроки = НомерСтроки + 1;
		СтрокаТЧ.НомерСтроки = НомерСтроки;
	
	КонецЦикла; 

КонецПроцедуры

// Обработать строку кросс-таблицы номенклатуры по указанным действиям.
// Может делать серверный(е) вызов(ы).
//
// Параметры:
//  Объект - любой объект 1С с возможностью получать значения реквизитов
//				- объект в контексте которого производятся действия
//				  над строкой кросс-таблицы.
//  ТекущаяСтрока - ДанныеФормыЭлементКоллекции,
//					СтрокаТаблицыЗначений,
//					СтрокаТабличнойЧасти - строка кросс-таблицы номенклатуры.
//  ТаблицаПериодов - ДанныеФормыКоллекция,
//					  ТаблицаЗначений - таблица с описанием периодов кросс-таблицы.
//  СтруктураДействий - Структура - действия, которые необходимо выполнить
//				в контексте строки кросс-таблицы номенклатуры.
//  ЗаменаИменРеквизитов - Структура, Соответствие - 
//				{Имя реквизита типового объекта:
//				 Имя реквизита в переданном объекте}.
//
Процедура ОбработатьСтрокуТЧ(Объект, 
							 ТекущаяСтрока, 
							 ТаблицаПериодов, 
							 СтруктураДействий,
							 ЗаменаИменРеквизитов=Неопределено) Экспорт
	ДанныеДляПолучения = 
		ЦентрализованныеЗакупкиКлиентСерверУХ.ЧтоПолучитьНаСервере(
			Объект, 
			ТекущаяСтрока, 
			СтруктураДействий,
			ЗаменаИменРеквизитов);
	
	Если ДанныеДляПолучения.Количество() > 0 Тогда
		ЗначенияДанных = ЦентрализованныеЗакупкиВызовСервераУХ.ПолучитьДанныеНаСервере(ДанныеДляПолучения);
	Иначе
		ЗначенияДанных = Новый Структура;
	КонецЕсли;
	
	Если СтруктураДействий.Свойство("УстановитьХарактеристику") Тогда
		ТекущаяСтрока.Характеристика = ЗначенияДанных.Характеристика;
		ТекущаяСтрока.ХарактеристикиИспользуются = 
			ЗначенияДанных.ХарактеристикиИспользуются;
	КонецЕсли;
	
	Если СтруктураДействий.Свойство("УстановитьКоэффициентЕдиницыИзмерения") Тогда
		ТекущаяСтрока.Коэффициент = ЗначенияДанных.Коэффициент;
	КонецЕсли;
	
	Если СтруктураДействий.Свойство("УстановитьЕдиницуИзменения") Тогда
		ТекущаяСтрока.ЕдиницаИзмерения = ЗначенияДанных.ЕдиницаИзмерения;
		ТекущаяСтрока.Коэффициент = ЗначенияДанных.Коэффициент;
	КонецЕсли;
	
	Если СтруктураДействий.Свойство("ПересчитатьПоКоэффициенту") Тогда
		флЕстьЦенаПоПериодам = Неопределено;
		СтарыйКоэффициент = ?(ТекущаяСтрока.СтарыйКоэффициент=0,1,ТекущаяСтрока.СтарыйКоэффициент);
		Коэффициент = ?(ТекущаяСтрока.Коэффициент=0,1,ТекущаяСтрока.Коэффициент);
		Если СтарыйКоэффициент <> Коэффициент Тогда
			
			КоэффПересчета = СтарыйКоэффициент / Коэффициент;
			ТекущаяСтрока.Цена = Окр(ТекущаяСтрока.Цена / КоэффПересчета, 2);
					
			Для каждого СтрокаПериода Из ТаблицаПериодов Цикл
				Если НЕ СтрокаПериода.Активная Тогда
					Продолжить;
				КонецЕсли;
				Количество_ = ТекущаяСтрока["Количество_" + СтрокаПериода.ИмяКолонки];
				Если Окр(Количество_) = Количество_ Тогда
					ДробныеРазряды = 0;
				Иначе
					ДробныеРазряды = 2;
				КонецЕсли;
				
				ТекущаяСтрока["Количество_" + СтрокаПериода.ИмяКолонки] =
					Окр(Количество_ * КоэффПересчета, ДробныеРазряды);
					
				Если флЕстьЦенаПоПериодам = Неопределено Тогда
					Попытка
						Цена_ = ТекущаяСтрока["Цена_" + СтрокаПериода.ИмяКолонки];
						флЕстьЦенаПоПериодам = Истина;
					Исключение
						флЕстьЦенаПоПериодам = Ложь;
					КонецПопытки;
				КонецЕсли;
				Если флЕстьЦенаПоПериодам Тогда
					ТекущаяСтрока["Цена_" + СтрокаПериода.ИмяКолонки] =
						Окр(ТекущаяСтрока["Цена_" + СтрокаПериода.ИмяКолонки] / КоэффПересчета, 2);
				КонецЕсли;
			КонецЦикла;
			
			ТекущаяСтрока.СтарыйКоэффициент = ТекущаяСтрока.Коэффициент;
		КонецЕсли;
	КонецЕсли;
		
	Если СтруктураДействий.Свойство("УстановитьЦену")
			ИЛИ СтруктураДействий.Свойство("УстановитьЦенуТК") Тогда
		ВалютаДокумента = ПолучитьЗначениеРеквизитаОбъекта(
			Объект,
			"ВалютаДокумента",
			ЗаменаИменРеквизитов);
		Если ЗначениеЗаполнено(ТекущаяСтрока.Номенклатура) 
			И ЗначениеЗаполнено(ВалютаДокумента) 
			И ТипЗнч(ТекущаяСтрока.Номенклатура) <> 
					Тип("СправочникСсылка.ТоварныеКатегории") Тогда
			ТекущаяСтрока.Цена = ЗначенияДанных.Цена;
		Иначе
			ТекущаяСтрока.Цена = 0;
		КонецЕсли;
	КонецЕсли;
	Если СтруктураДействий.Свойство("УстановитьЦену")
			ИЛИ СтруктураДействий.Свойство("УстановитьЦенуТК")
			ИЛИ СтруктураДействий.Свойство("ЗаполнитьЦеныПериодов") Тогда
		УстановитьЦенуПоПериодамСтроки(
			ТаблицаПериодов, ТекущаяСтрока, ТекущаяСтрока.Цена);	
	КонецЕсли;
	Если СтруктураДействий.Свойство("УстановитьСтавкуНДС") Тогда
		ТекущаяСтрока.СтавкаНДС = ЗначенияДанных.СтавкаНДС;
	КонецЕсли;
	Если СтруктураДействий.Свойство("РасчитатьНДССтроки") Тогда
		РасчитатьСуммыПоНДССтроки(
			ТекущаяСтрока, 
			ЗначенияДанных.СуммаВключаетНДС, 
			Истина);
	КонецЕсли;
КонецПроцедуры

// Определяет по набору действий со строкой кросс-таблицы номенклатуры
// какие данные нужно получить на сервере.
//
// Параметры:
//  Объект - Любой объект 1С с возможностью получать значения реквизитов
//				- объект в контексте которого производятся действия
//				  над строкой кросс-таблицы.
//  ТекущаяСтрока - ДанныеФормыЭлементКоллекции,
//					СтрокаТаблицыЗначений,
//					СтрокаТабличнойЧасти - строка кросс-таблицы номенклатуры.
//  СтруктураДействий - Структура - действия, которые необходимо выполнить
//				в контексте строки кросс-таблицы номенклатуры.
//  ЗаменаИменРеквизитов - Структура, Соответствие - 
//				{Имя реквизита типового объекта:
//				 Имя реквизита в переданном объекте}.
// 
// Возвращаемое значение:
//  Описание данных для получения функцией 
//	ЦентрализованныеЗакупкиВызовСервераУХ.ПолучитьДанныеНаСервере().
//
Функция ЧтоПолучитьНаСервере(Объект, 
							ТекущаяСтрока, 
							СтруктураДействий, 
							ЗаменаИменРеквизитов=Неопределено) Экспорт
	ДанныеДляПолучения = Новый Массив;
	СтрокаРеквизитов = "Имя,Формула,Операнды";
	
	Если СтруктураДействий.Свойство("УстановитьХарактеристику") Тогда
		Если ЗначениеЗаполнено(ТекущаяСтрока.Номенклатура) Тогда
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "Характеристика";
			ОписаниеЗначения.Формула = "Справочники.ХарактеристикиНоменклатуры.ПустаяСсылка()";
			ОписаниеЗначения.Операнды = Неопределено;
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "ХарактеристикиИспользуются";
			ОписаниеЗначения.Формула =
				"УправлениеЗакупкамиВстраиваниеПереопределяемыйУХ.ХарактеристикиИспользуются(
				|	ОписаниеЗначения.Операнды.Номенклатура)";
			ОписаниеЗначения.Операнды = Новый Структура(
				"Номенклатура", 
				ТекущаяСтрока.Номенклатура);
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
		Иначе
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "Характеристика";
			ОписаниеЗначения.Формула = "Справочники.ХарактеристикиНоменклатуры.ПустаяСсылка()";
			ОписаниеЗначения.Операнды = Неопределено;
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "ХарактеристикиИспользуются";
			ОписаниеЗначения.Формула = "Ложь";
			ОписаниеЗначения.Операнды = Неопределено;
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
		КонецЕсли;
	КонецЕсли;
	
	Если СтруктураДействий.Свойство("УстановитьКоэффициентЕдиницыИзмерения") Тогда
		Если ЗначениеЗаполнено(ТекущаяСтрока.Номенклатура)
				И ЗначениеЗаполнено(ТекущаяСтрока.ЕдиницаИзмерения) Тогда
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "Коэффициент";
			ОписаниеЗначения.Формула =
				"УправлениеЗакупкамиВстраиваниеПереопределяемыйУХ.ПолучитьКоэффициентЕдиницыИзмерения(
				|	ОписаниеЗначения.Операнды.Номенклатура,
				|	ОписаниеЗначения.Операнды.Характеристика,
				|	ОписаниеЗначения.Операнды.ЕдиницаИзмерения)";
			ОписаниеЗначения.Операнды = Новый Структура(
				"Номенклатура,Характеристика,ЕдиницаИзмерения", 
				ТекущаяСтрока.Номенклатура,
				ПолучитьЗначениеРеквизитаОбъекта(
					ТекущаяСтрока, 
					"Характеристика", 
					Неопределено),
				ТекущаяСтрока.ЕдиницаИзмерения);
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
		Иначе
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "Коэффициент";
			ОписаниеЗначения.Формула = "1";
			ОписаниеЗначения.Операнды = Неопределено;
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
		КонецЕсли;
	КонецЕсли;
	
	Если СтруктураДействий.Свойство("УстановитьЕдиницуИзменения") Тогда
		Если ЗначениеЗаполнено(ТекущаяСтрока.Номенклатура) Тогда
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "ЕдиницаИзмерения";
			ОписаниеЗначения.Формула = "ОписаниеЗначения.Операнды.Номенклатура.ЕдиницаИзмерения";
			ОписаниеЗначения.Операнды = Новый Структура("Номенклатура", ТекущаяСтрока.Номенклатура);
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
		Иначе
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "ЕдиницаИзмерения";
			ОписаниеЗначения.Формула = 
				УправлениеЗакупкамиВстраиваниеПереопределяемыйКлиентСерверУХ.ПолучитьТекстПустойЕдиницыИзмерения();
			ОписаниеЗначения.Операнды = Неопределено;
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
		КонецЕсли;
		// установили базовую ед. измерения
		ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
		ОписаниеЗначения.Имя = "Коэффициент";
		ОписаниеЗначения.Формула = "1";
		ОписаниеЗначения.Операнды = Неопределено;
		ДанныеДляПолучения.Добавить(ОписаниеЗначения);
	КонецЕсли;
	
	// цена номенклатуры
	Если СтруктураДействий.Свойство("УстановитьЦену") Тогда
		ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
		ОписаниеЗначения.Имя = "Цена";
		ОписаниеЗначения.Формула = 
				"УправлениеЗакупкамиВстраиваниеПереопределяемыйУХ.ПолучитьЦенуНоменклатуры(
				|	ОписаниеЗначения.Операнды.Номенклатура,
				|	ОписаниеЗначения.Операнды.Характеристика,
				|	Константы.ТипЦенДляРасценкиЗаявокНаПотребность.Получить(),
				|	ОписаниеЗначения.Операнды.ДатаКурса,
				|	ОписаниеЗначения.Операнды.Валюта)";
		ОписаниеЗначения.Операнды = Новый Структура;
		ОписаниеЗначения.Операнды.Вставить("Номенклатура", ТекущаяСтрока.Номенклатура);
		ОписаниеЗначения.Операнды.Вставить(
			"Характеристика",
			ПолучитьЗначениеРеквизитаОбъекта(
					ТекущаяСтрока, 
					"Характеристика", 
					Неопределено));
		ОписаниеЗначения.Операнды.Вставить("Валюта", ПолучитьЗначениеРеквизитаОбъекта(
			Объект,
			"ВалютаДокумента",
			ЗаменаИменРеквизитов));
		ДатаКурса = ПолучитьДатуКурсаПланаЗакупок(Объект, ЗаменаИменРеквизитов);
		Если ДатаКурса <> Неопределено Тогда
			ОписаниеЗначения.Операнды.Вставить("ДатаКурса", ДатаКурса);
		Иначе
			ОписаниеЗначения.Формула = 0;
			ОписаниеЗначения.Операнды = Неопределено;
		КонецЕсли;
		ДанныеДляПолучения.Добавить(ОписаниеЗначения);
	КонецЕсли;
	
	// Цена товарной категории
	Если СтруктураДействий.Свойство("УстановитьЦенуТК") Тогда
		ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
		ОписаниеЗначения.Имя = "Цена";
		ОписаниеЗначения.Формула = 0;
		ОписаниеЗначения.Операнды = Неопределено;
		ДанныеДляПолучения.Добавить(ОписаниеЗначения);
	КонецЕсли;
	
	Если СтруктураДействий.Свойство("УстановитьСтавкуНДС") Тогда
		Если ЗначениеЗаполнено(ТекущаяСтрока.Номенклатура) Тогда
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "СтавкаНДС";
			ОписаниеЗначения.Формула =
				"УправлениеЗакупкамиВстраиваниеПереопределяемыйУХ.СтавкаНДС(
				|	ОписаниеЗначения.Операнды.Номенклатура,
				|	ОписаниеЗначения.Операнды.ДатаСтавкиНДС)";
			ОписаниеЗначения.Операнды = Новый Структура;
			ОписаниеЗначения.Операнды.Вставить("Номенклатура", ТекущаяСтрока.Номенклатура);
			ДатаСтавкиНДС = ПолучитьДатуСтавкиНДС(Объект, ЗаменаИменРеквизитов);
			Если ДатаСтавкиНДС <> Неопределено Тогда
				ОписаниеЗначения.Операнды.Вставить("ДатаСтавкиНДС", ДатаСтавкиНДС);
			Иначе
				ОписаниеЗначения.Формула = 0;
				ОписаниеЗначения.Операнды = Неопределено;
			КонецЕсли;
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
		Иначе
			ОписаниеЗначения = Новый Структура(СтрокаРеквизитов);
			ОписаниеЗначения.Имя = "СтавкаНДС";
			ОписаниеЗначения.Формула = "Справочники.СтавкиНДС.ПустаяСсылка()";
			ОписаниеЗначения.Операнды = Неопределено;
			ДанныеДляПолучения.Добавить(ОписаниеЗначения);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ДанныеДляПолучения;
КонецФункции

Функция ПолучитьДатуКурсаПланаЗакупок(Объект, ЗаменаИменРеквизитов, ИмяРеквизитаДаты="ДатаОкончания")
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
										Объект, ИмяРеквизитаДаты) Тогда
		Возврат Объект[ИмяРеквизитаДаты];
	КонецЕсли;
	ПериодЗакупок = ПолучитьЗначениеРеквизитаОбъекта(
		Объект,
		"ПериодЗакупок",
		ЗаменаИменРеквизитов);
	Если ЗначениеЗаполнено(ПериодЗакупок) Тогда
		Возврат ПериодЗакупок[ИмяРеквизитаДаты];
	ИначеЕсли ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
													Объект, "ДатаОкончания") Тогда
		Возврат Объект.ДатаОкончания;
	ИначеЕсли ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
													Объект, "Дата") Тогда
		Возврат Объект.Дата;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ПолучитьДатуСтавкиНДС(Объект, ЗаменаИменРеквизитов, ИмяРеквизитаДаты="ДатаОкончания")
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
										Объект, ИмяРеквизитаДаты) Тогда
		Возврат Объект[ИмяРеквизитаДаты];
	КонецЕсли;
	ПериодЗакупок = ПолучитьЗначениеРеквизитаОбъекта(
		Объект,
		"ПериодЗакупок",
		ЗаменаИменРеквизитов);
	Если ЗначениеЗаполнено(ПериодЗакупок) Тогда
		Возврат ПериодЗакупок[ИмяРеквизитаДаты];
	ИначеЕсли ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
													Объект, "Дата") Тогда
		Возврат Объект.Дата;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Возвращает значение реквизита объекта с учетом правил замены
// имен реквизитов.
//
Функция ПолучитьЗначениеРеквизитаОбъекта(Объект, 
										 ИмяРеквизита, 
										 ЗаменаИменРеквизитов) Экспорт
	Если ЗаменаИменРеквизитов <> Неопределено 
			И ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
									ЗаменаИменРеквизитов, ИмяРеквизита) Тогда
		Возврат Объект[ЗаменаИменРеквизитов[ИмяРеквизита]];
	КонецЕсли;
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
												  Объект, ИмяРеквизита) Тогда
		Возврат Объект[ИмяРеквизита];
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Пересчитывает итоговые поля (Количество, Сумма, Цена, СуммаНДС) строк кросс-таблицы
Процедура ПересчитатьИтоговыеПоказателиКроссТаблицы(
									КроссТаблица,
									ПериодыЗакупок,
									ЦенаВключаетНДС) Экспорт
	Для Каждого СтрокаКроссТаблицы Из КроссТаблица Цикл
		ПриИзмененииКоличестваСуммыСтроки(
			ЦенаВключаетНДС,
			ПериодыЗакупок, 
			СтрокаКроссТаблицы);
		Если ТипЗнч(СтрокаКроссТаблицы.Номенклатура) <>
							Тип("СправочникСсылка.ТоварныеКатегории") Тогда
			СуммаДляРасчетаЦены = СтрокаКроссТаблицы.Сумма
				- ?(ЦенаВключаетНДС, 0, СтрокаКроссТаблицы.СуммаНДС);
			СтрокаКроссТаблицы.Цена = СуммаДляРасчетаЦены /
				?(СтрокаКроссТаблицы.Количество=0,
					1, 
					СтрокаКроссТаблицы.Количество);
		Иначе
			СтрокаКроссТаблицы.Цена = 0;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Обнуляет значение количества для указанной строки кросс-таблицы.
//
Процедура ОбнулитьКоличествоСтрокиКроссТаблицы(ПериодыЗакупок,
												СтрокаТоваров) Экспорт
	Для каждого СтрокаПериода Из ПериодыЗакупок Цикл
		СтрокаТоваров["Количество_" + СтрокаПериода.ИмяКолонки] = 0;
	КонецЦикла;
	СтрокаТоваров.Количество = 0;
КонецПроцедуры

Процедура ОбработатьИзменениеЦеныКроссТаблицы(ЦенаВключаетНДС,
											   ПериодыЗакупок,
											   ТекущаяСтрока) Экспорт
	Если ТекущаяСтрока <> Неопределено Тогда
		УстановитьЦенуПоПериодамСтроки(
			ПериодыЗакупок,
			ТекущаяСтрока,
			ТекущаяСтрока.Цена);
		ПересчитатьСуммуСтрокиПоЦене(
			ПериодыЗакупок, 
			ТекущаяСтрока,
			ЦенаВключаетНДС);
		ПриИзмененииКоличестваСуммыСтроки(
			Истина, 
			ПериодыЗакупок, 
			ТекущаяСтрока,
			Ложь);
	КонецЕсли;
КонецПроцедуры
		
Процедура ПриИзмененииКоличестваСуммыСтроки(ЦенаВключаетНДС, 
											ПериодыЗакупок, 
											СтрокаТоваров,
											ЕстьСуммаСНДС=Ложь) Экспорт
	РассчитатьИтогКоличестваСуммыСтроки(
		ПериодыЗакупок, 
		СтрокаТоваров);
	РасчитатьНДССтроки(Истина, СтрокаТоваров);
	Если ЕстьСуммаСНДС Тогда
		ОбновитьСуммуСНДССтроки(ЦенаВключаетНДС, СтрокаТоваров);
	КонецЕсли;
КонецПроцедуры

Процедура РассчитатьИтогКоличестваСуммыСтроки(ПериодыЗакупок, 
											СтрокаТоваров) Экспорт
	Количество = 0;
	Сумма = 0;
	Для каждого СтрокаПериода Из ПериодыЗакупок Цикл
		Если НЕ СтрокаПериода.Активная Тогда
			Продолжить;
		КонецЕсли;
		Количество = Количество +
			СтрокаТоваров["Количество_" + СтрокаПериода.ИмяКолонки];
		Сумма = Сумма + СтрокаТоваров["Сумма_" + СтрокаПериода.ИмяКолонки];
	КонецЦикла;
	СтрокаТоваров.Количество = Количество;
	СтрокаТоваров.Сумма = Сумма;
КонецПроцедуры

// Заполняет реквизит СуммаНДС и СуммаСНДС на основании
//  реквизита Сумма и СтавкаНДС.
//
// Параметры:
//  ТаблицаНоменклатуры	 - ТабличнаяЧасть | ТаблицаЗначений
//		- таблица для обновления сумм НДС.
//  ЦенаВключаетНДС - Булево - способ расчета НДС по полю Сумма.
//
Процедура ЗаполнитьСуммуНДСТаблицы(ТаблицаНоменклатуры, СуммаВключаетНДС) Экспорт
	флЕстьСуммаСНДС = ЕстьРеквизитТаблицы(ТаблицаНоменклатуры, "СуммаСНДС");
	Для Каждого СтрокаТаблицы Из ТаблицаНоменклатуры Цикл
		РасчитатьСуммыПоНДССтроки(СтрокаТаблицы, СуммаВключаетНДС, флЕстьСуммаСНДС);
	КонецЦикла;
КонецПроцедуры

Процедура УстановитьЦенуПоПериодамСтроки(ПериодыЗакупок, СтрокаТаблицы, Цена) Экспорт
	Для каждого СтрокаПериода Из ПериодыЗакупок Цикл
		Если НЕ СтрокаПериода.Активная Тогда
			Продолжить;
		КонецЕсли;
		СтрокаТаблицы["Цена_" + СтрокаПериода.ИмяКолонки] = Цена;
	КонецЦикла;
КонецПроцедуры

Процедура ПересчитатьСуммуСтрокиПоЦене(ПериодыЗакупок,
									   СтрокаТоваров,
									   ЦенаВключаетНДС) Экспорт
	Для каждого СтрокаПериода Из ПериодыЗакупок Цикл
		Если НЕ СтрокаПериода.Активная 
			 И СтрокаТоваров.ЭтоКатегорияНоменклатуры Тогда
			Продолжить;
		КонецЕсли;
		ИмяПериода = СтрокаПериода.ИмяКолонки;
		ПересчитатьСуммуСтрокиКолонкиОтЦеныИКоличества(
			СтрокаТоваров,
			ИмяПериода,
			ЦенаВключаетНДС);
	КонецЦикла;
КонецПроцедуры

Процедура ПересчитатьСуммуСтрокиКолонкиОтЦеныИКоличества(
											СтрокаТаблицы,
											УИДПериода,
											ЦенаВключаетНДС) Экспорт
	Если СтрокаТаблицы <> Неопределено
			И ТипЗнч(СтрокаТаблицы.Номенклатура) = Тип("СправочникСсылка.Номенклатура") Тогда
		СуммаБазовая = СтрокаТаблицы["Количество_" + УИДПериода] 
			* СтрокаТаблицы["Цена_" + УИДПериода];
		СтрокаТаблицы["Сумма_" + УИДПериода] = СуммаБазовая;
		Если НЕ ЦенаВключаетНДС Тогда
			СтавкаНДС = ВстраиваниеУХВызовСервера.ПолучитьСтавкуНДС(СтрокаТаблицы.СтавкаНДС);
			Если ТипЗнч(СтавкаНДС) = Тип("СправочникСсылка.СтавкиНДС") Тогда
				СтавкаНДС = ОбщегоНазначенияУХ.ПолучитьЗначениеРеквизита(СтавкаНДС, "Ставка");
				Если СтавкаНДС = Неопределено Тогда
					СтавкаНДС = 0;
				КонецЕсли;	
			КонецЕсли;			
			СтрокаТаблицы["Сумма_" + УИДПериода] =
				СуммаБазовая
				+ УчетНДСКлиентСервер.РассчитатьСуммуНДС(
					СуммаБазовая, 
					Ложь,	
					СтавкаНДС);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Обновляет СуммуНДС, Сумму и если есть, СуммуСНДС
Процедура РасчитатьСуммыПоНДССтроки(СтрокаТаблицы, СуммаВключаетНДС, ЕстьСуммаСНДС) Экспорт
	РасчитатьНДССтроки(СуммаВключаетНДС, СтрокаТаблицы);
	ОбновитьСуммуПоНДССтроки(СтрокаТаблицы, СуммаВключаетНДС);
	Если ЕстьСуммаСНДС Тогда
		ОбновитьСуммуСНДССтроки(СуммаВключаетНДС, СтрокаТаблицы);
	КонецЕсли;
КонецПроцедуры

// Обновляет Сумму при изменении ставки НДС строки.
Процедура ОбновитьСуммуПоНДССтроки(СтрокаТаблицы, СуммаВключаетНДС) Экспорт
	// Не можем быть уверенными, что сумма содержит корректные данные
	Если ТипЗнч(СтрокаТаблицы.Номенклатура) = Тип("СправочникСсылка.Номенклатура") Тогда
		СтрокаТаблицы.Сумма = СтрокаТаблицы.Количество * СтрокаТаблицы.Цена;
		Если НЕ СуммаВключаетНДС Тогда
			СтрокаТаблицы.Сумма = СтрокаТаблицы.Сумма + СтрокаТаблицы.СуммаНДС;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Обновляет колонку "СуммаСНДС" таблицы.
//
Процедура ОбновитьСуммуСНДС(ЦенаВключаетНДС, ТаблицаНоменклатуры) Экспорт
	Для Каждого СтрокаТаблицы Из ТаблицаНоменклатуры Цикл
		ОбновитьСуммуСНДССтроки(
			ЦенаВключаетНДС, 
			СтрокаТаблицы);
	КонецЦикла;
КонецПроцедуры

Процедура РасчитатьНДССтроки(ЦенаВключаетНДС, СтрокаТаблицы) Экспорт
	НоваяСтавкаНДС = ВстраиваниеУХВызовСервера.ПолучитьСтавкуНДС(СтрокаТаблицы.СтавкаНДС);
	Если ЗначениеЗаполнено(НоваяСтавкаНДС) Тогда
		Если ТипЗнч(НоваяСтавкаНДС) = Тип("Число") Тогда
			СтрокаТаблицы.СуммаНДС = УчетНДСКлиентСервер.РассчитатьСуммуНДС(СтрокаТаблицы.Сумма, ЦенаВключаетНДС, НоваяСтавкаНДС);
		ИначеЕсли ТипЗнч(НоваяСтавкаНДС) = Тип("СправочникСсылка.СтавкиНДС") Тогда
			ЗначениеСтавки = ОбщегоНазначенияУХ.ПолучитьЗначениеРеквизита(НоваяСтавкаНДС, "Ставка");
			СтрокаТаблицы.СуммаНДС = УчетНДСКлиентСервер.РассчитатьСуммуНДС(СтрокаТаблицы.Сумма, ЦенаВключаетНДС, ЗначениеСтавки);
		Иначе
			ТекстСообщения = НСтр("ru = 'Неизвестный вариант ставки НДС: %СтавкаНДС%. Рассчет НДС отменен'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%СтавкаНДС%", Строка(НоваяСтавкаНДС));
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
			СтрокаТаблицы.СуммаНДС = 0;
		КонецЕсли;
	Иначе
		СтрокаТаблицы.СуммаНДС = 0;
	КонецЕсли;
КонецПроцедуры

Процедура ОбновитьСуммуСНДССтроки(ЦенаВключаетНДС, СтрокаТаблицы) Экспорт
	Если ЦенаВключаетНДС Тогда
		СтрокаТаблицы.СуммаСНДС = СтрокаТаблицы.Сумма;
	Иначе
		СтрокаТаблицы.СуммаСНДС = СтрокаТаблицы.Сумма
			+ СтрокаТаблицы.СуммаНДС;
	КонецЕсли;
КонецПроцедуры

Функция ЕстьРеквизитТаблицы(Таблица, ИмяРеквизита) Экспорт
	Если Таблица.Количество() > 0 Тогда
		ПерваяСтрока = Таблица[0];
		Возврат ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
			ПерваяСтрока, 
			ИмяРеквизита);
	КонецЕсли;
	Возврат Ложь;
КонецФункции

// Если какой-либо из переданных периодов не заполнен,
// то в переданной таблице значений или табличной
// части ищет по колонке ИмяРеквизитаПериода
// периоды с минимальной и максимальной датой начала
// и устанавливает их как значение ПериодНачала, 
// ПериодОкончания начала и конца (если соотвествующее
// значение не заполнено).
Процедура ПроверитьЗаполнитьГраницыПериодаКроссТаблицы(
											ПериодНачала, 
											ПериодОкончания, 
											ИсходнаяТаблица,
											ИмяРеквизитаПериода) Экспорт
	флНачалоНеЗаполнено = НЕ ЗначениеЗаполнено(ПериодНачала);
	флОкончаниеНеЗаполнено = НЕ ЗначениеЗаполнено(ПериодОкончания);
	Если флНачалоНеЗаполнено ИЛИ флОкончаниеНеЗаполнено Тогда
		ГраницыПериода =
			ПолучитьГраницыПериодаКроссТаблицы(
				ИсходнаяТаблица,
				ИмяРеквизитаПериода);
		Если флНачалоНеЗаполнено И ЗначениеЗаполнено(ГраницыПериода.Начало) Тогда
			ПериодНачала = ГраницыПериода.Начало;
		КонецЕсли;
		Если флОкончаниеНеЗаполнено И ЗначениеЗаполнено(ГраницыПериода.Окончание) Тогда
			ПериодОкончания = ГраницыПериода.Окончание;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Возвращает структуру с двумя датами: Начало и Окончание.
// С минимальной и максимальной датой начала периода соответственно
// Периоды читаем из реквизита ИмяРеквизитаПериода таблицы.
//
Функция ПолучитьГраницыПериодаКроссТаблицы(ТаблицаСПериодами,
										ИмяРеквизитаПериода) Экспорт
	Границы = Новый Структура("Начало, Окончание",
		ПредопределенноеЗначение("Справочник.Периоды.ПустаяСсылка"),
		ПредопределенноеЗначение("Справочник.Периоды.ПустаяСсылка"));
	МинДата = '30000101';
	МаксДата = '00010101';
	Для Каждого СтрокаТаблицы Из ТаблицаСПериодами Цикл
		Период = СтрокаТаблицы[ИмяРеквизитаПериода];
		Если ЗначениеЗаполнено(Период) Тогда
			ДатаНачала = Период.ДатаНачала;
			Если ДатаНачала < МинДата Тогда
				МинДата = ДатаНачала;
				Границы.Начало = Период;
			КонецЕсли;
			Если ДатаНачала > МаксДата Тогда
				МаксДата = ДатаНачала;
				Границы.Окончание = Период;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Границы;
КонецФункции

// Функция - Получить описание колонки кросс таблицы
//
// Параметры:
//  ИмяКолонки - Строка - имя колонки в формате ИмяПоля_УИДПериода,
//		где ИмяПоля - это Количество, Цена или Сумма с любым
//					  префиксом перед ними (например, 
//					  "ПотребностиВНоменклатуреПоПериодамКоличество");
//			УИДПериода - это идентификатор периода кросс таблицы.
// 
// Возвращаемое значение:
//  Структура{ВидРесурса, УИДПериода} - если удалось разложить имя
//		на составляющие. ВидРесурса может принимать значения:
//		Количество, Цена или Сумма.
//	Неопределено - если не удалось разделить строку или оперделить
//		имя ресурса.
//
Функция ПолучитьОписаниеКолонкиКроссТаблицы(ИмяКолонки) Экспорт
	Поз = СтрНайти(ИмяКолонки, "_");
	Если Поз = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	ИмяРесурса = ОпределитьИмяРесурсаВИмениПоля(Лев(ИмяКолонки, Поз-1));
	Если ИмяРесурса = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ОписаниеКолонки = Новый Структура;
	ОписаниеКолонки.Вставить("ВидРесурса", ИмяРесурса);
	ОписаниеКолонки.Вставить("УИДПериода", Сред(ИмяКолонки, Поз+1));
	Возврат ОписаниеКолонки;
КонецФункции

// Пытается найти имена "Количество", "Цена", "Сумма"
// в конце имени поля.
//
// Параметры:
//  ИмяПоля - Строка - имя колонки кросс-таблицы без УИД периода.
// 
// Возвращаемое значение:
//	Строка - нейденное имя ресурса.
//	Неопределено - не удалось найти имя ресурса.
//
Функция ОпределитьИмяРесурсаВИмениПоля(ИмяПоля) Экспорт
	ИменаРесурсов = СтрРазделить("Количество,Цена,Сумма", ",");
	Для Каждого ИмяРесурса Из ИменаРесурсов Цикл
		Если ЕстьИмяРесурсаВСтроке(ИмяПоля, ИмяРесурса) Тогда
			Возврат ИмяРесурса;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

// Функция - Найти имя ресурса в конце строки.
//
// Параметры:
//  Стр	- Строка - в ее конце пытаемся найти имя ресурса.
//  ИмяРесурса - Строка - имя для поиска.
// 
// Возвращаемое значение:
//   Булево - имя найдено или нет.
//
Функция ЕстьИмяРесурсаВСтроке(Стр, ИмяРесурса) Экспорт
	Поз = СтрНайти(Стр, ИмяРесурса, НаправлениеПоиска.СКонца);
	Если Поз = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
КонецФункции

// Проверяет заполнение характеристик, если они необходимы.
//
// Параметры:
//  ТаблицаПотребностей - ДанныеФормыКоллекция - кросс-таблица потребностей.
//  ИмяЭлементаФормыТаблицыПотребностей - Строка - имя элемента формы
//		представляющего кросс-таблицу. Необходим для формирования ошибки.
//  ИмяПоляХарактеристик - Строка - имя поля содержащего характеристику.
//  ИмяПоляИспользованияХарактеристик - Строка - имя поля с реквизитом типа
//		Булево для отслеживания необходимости заполнения характеристики.
//  ОшибкиПользователю - Структура - внешняя переменная, которая будет
//		содержать описания ошибок в виде пригодном для функции
//		ОбщегоНазначенияКлиентСервер.СообщитьОшибкиПользователю().
// 
// Возвращаемое значение:
//   - Булево - Истина - все характеристики заполнены корректно.
//				Ложь - есть ошибки, ОшибкиПользователю
//				в этом случае содержат описание ошибок.
//
Функция ХарактеристикиЗаполненыКорректно(ТаблицаПотребностей,
										 ИмяЭлементаФормыТаблицыПотребностей,
										 ИмяПоляХарактеристик,
										 ИмяПоляИспользованияХарактеристик,
										 ОшибкиПользователю) Экспорт
	ЕстьОшибки = Ложь;
	Для Каждого СтрокаТаблицы Из ТаблицаПотребностей Цикл
		Если СтрокаТаблицы[ИмяПоляИспользованияХарактеристик]
			И НЕ ЗначениеЗаполнено(СтрокаТаблицы[ИмяПоляХарактеристик]) Тогда
			ТекстСообщения = НСтр(СтрШаблон("ru='Не заполнена характеристика в строке %1!'", СтрокаТаблицы.НомерСтроки));
			ПолеОшибки = ИмяЭлементаФормыТаблицыПотребностей + "[%1]." + ИмяПоляХарактеристик;
			ИндексСтроки = СтрокаТаблицы.НомерСтроки - 1;
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(
				ОшибкиПользователю,	ПолеОшибки,	ТекстСообщения,	Неопределено, ИндексСтроки);
			ЕстьОшибки = Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат ЕстьОшибки;
КонецФункции

// Проверяет поля на заполненность, и формирует сообщения об ошибках.
//
// Параметры:
//  ТаблицаПотребностей - ДанныеФормыКоллекция - кросс-таблица потребностей.
//  СтруктураИменаПолей - Структура - имена полей для проверки, с их
//		представлением для формирования ошибки.
//  ОшибкиПользователю - Структура - внешняя переменная, которая будет
//		содержать описания ошибок в виде пригодном для функции
//		ОбщегоНазначенияКлиентСервер.СообщитьОшибкиПользователю().
//
Процедура ПроверитьЗаполнениеПолейКроссТаблицы(ТаблицаПотребностей,
											   ИмяЭлементаФормыТаблицыПотребностей,
											   СтруктураИменаПолей,
											   ОшибкиПользователю) Экспорт
	Для Каждого СтрокаТаблицы Из ТаблицаПотребностей Цикл
		Для Каждого ИмяПредставление Из СтруктураИменаПолей Цикл
			ИмяПоля = ИмяПредставление.Ключ;
			ПредставлениеПоля = ИмяПредставление.Значение;
			Если НЕ ЗначениеЗаполнено(СтрокаТаблицы[СокрЛП(ИмяПоля)]) Тогда
				ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(
					ОшибкиПользователю,
					ИмяЭлементаФормыТаблицыПотребностей + "[%1]." + ИмяПоля,
					НСтр(СтрШаблон("ru='Не заполнено поле %1 в строке %2!'",
						ПредставлениеПоля,
						СтрокаТаблицы.НомерСтроки)),
					Неопределено,
					СтрокаТаблицы.НомерСтроки-1);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры


#КонецОбласти


#Область ВерсионированиеОбъектовДляЕИС

Процедура ОбновитьВерсиюДляЕИС(Ссылка, Форма) Экспорт
	ОписаниеВерсии = ЦентрализованныеЗакупкиВызовСервераУХ.ПолучитьВерсиюОбъектаДляЕИС(Ссылка);
	Если ОписаниеВерсии.НомерВерсии > 0 Тогда
		ТекстРедакция = НСтр("ru = 'Редакция №%НомерВерсии%'");
		ТекстРедакция = СтрЗаменить(ТекстРедакция, "%НомерВерсии%", СокрЛП(ОписаниеВерсии.НомерВерсии));
		Форма.УХ_ЦУЗ_НомерВерсии = ТекстРедакция;
		Форма.УХ_ЦУЗ_ОбоснованиеИзменений = ОписаниеВерсии.ОбоснованиеИзменений;
		Форма.Элементы.УХ_ЦУЗ_ОбоснованиеИзменений.Видимость = Истина;    
	Иначе
		Форма.УХ_ЦУЗ_НомерВерсии = "";
		Форма.Элементы.УХ_ЦУЗ_ОбоснованиеИзменений.Видимость = Ложь;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти


#Область РаботаСоСтрокамиПланаЗакупок


// Проверить, что значение флага ТребуетсяОбоснованиеНМЦ установлено
// в любой строке таблицы Номенклатура документа СтрокаПланаЗакупок.
//  Вынесено для доступа из объекта и формы.
//
// Параметры:
//  ТаблицаНоменклатуры	- Объект с функцией НайтиСтроки(Структура) - 
//		таблица номенклатуры с реквизитом "ТребуетсяОбоснованиеНМЦ".
// 
// Возвращаемое значение:
//   - 
//
Функция ТребуетсяОбоснованиеНМЦДляТаблицыНоменклатуры(ТаблицаНоменклатуры) Экспорт
	Возврат ТаблицаНоменклатуры.НайтиСтроки(
		Новый Структура("ТребуетсяОбоснованиеНМЦ", Истина))
			.Количество() > 0;
КонецФункции

// Возвращает строковое представление потребности.
//
// Параметры:
//  СтруктураПотребности - Любой объект с [], для чтения
//			значений реквизитов потребности.
//  РазделительКлючЗначение - Строка - разделитель имени реквизита
//			и его значения.
//  РазделительРеквизитов - Строка - разделитель реквизитов.
// 
// Возвращаемое значение:
//   - Строка - представление потребности в понятном для пользователя виде.
//
Функция ПредставлениеПотребности(СтруктураПотребности, 
							Знач РазделительКлючЗначение=": ",
							Знач РазделительРеквизитов=", ") Экспорт
	мРеквизитов = Новый Массив;
	ПредставлениеИмен = ПолучитьПредставлениеКлючевыхПолейПотребности();
	Для Каждого РеквизитПредставление Из ПредставлениеИмен Цикл
		Значение = СтруктураПотребности[РеквизитПредставление.Ключ];
		Если ЗначениеЗаполнено(Значение) Тогда
			ПредставлениеЗанчения = Строка(Значение);
		Иначе
			ПредставлениеЗанчения = "-";
		КонецЕсли;
		мРеквизитов.Добавить(
			НСтр("ru='" + РеквизитПредставление.Значение + "'")
			+ РазделительКлючЗначение
			+ ПредставлениеЗанчения);
	КонецЦикла;
	Возврат СтрСоединить(мРеквизитов, РазделительРеквизитов);
КонецФункции

// Найти в кэше значение. Если его нет, то возвращает Неопределено.
//
// Параметры:
//  Кэш		 - Соответствие	 - для быстрого получения значения по набору параметров.
//  Параметры	 - Массив	 - набор значений для последовательного поиска
//								во вложенных соответствиях.
// 
// Возвращаемое значение:
//   - Неопределено - нет цены для указанных параметров.
//	 - значение - цена найдена.
//
Функция НайтиЗначениеВКэше(Кэш, Параметры) Экспорт
	ТекущийКэш = Кэш;
	ПоследнийИндекс = Параметры.Количество();
	Для Ном=0 По ПоследнийИндекс Цикл
		ТекущийКэш = ТекущийКэш[Параметры[Ном]];
		Если ТекущийКэш = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	Возврат ТекущийКэш;
КонецФункции

// Помещает значение в рекурсивный кэш по переданным значениям.
//
// Параметры:
//  Кэш			 - Соответствие	 - для добавления значения.
//  Параметры	 - Массив	 - значения для поиска во вложенных соотвествиях.
//	Значение	 - Произвольный - значение для добавления в кэш.
//  Обновить	 - Булево	 - если Ложь и значение уже есть в кэше, то не обновляет.
//							   если Истина, то обновляет в любом случае.
//
Процедура ДобавитьЗначениеВКэш(Кэш, 
							Параметры,
							Значение,
							Обновить=Ложь) Экспорт
	ТекущийКэш = Кэш;
	ПоследнийИндекс = Параметры.Количество();
	Для Ном=0 По ПоследнийИндекс-1 Цикл
		ТекущийКэш = ТекущийКэш[Параметры[Ном]];
		Если ТекущийКэш = Неопределено Тогда
			ТекущийКэш[Параметры[Ном]] = Новый Соответствие;
		КонецЕсли;
	КонецЦикла;
	Если Обновить 
		ИЛИ ТекущийКэш[Параметры[ПоследнийИндекс]] = Неопределено Тогда
		ТекущийКэш[Параметры[ПоследнийИндекс]] = Значение;
	КонецЕсли;
КонецПроцедуры

// Создает массив из двух значений.
//
Функция ПоместитьВМассив2(Значение1, Значение2) Экспорт
	Результат = Новый Массив;
	Результат.Добавить(Значение1);
	Результат.Добавить(Значение2);
	Возврат Результат;
КонецФункции

// Создает массив из трех значений.
//
Функция ПоместитьВМассив3(Значение1, Значение2, Значение3) Экспорт
	Результат = Новый Массив;
	Результат.Добавить(Значение1);
	Результат.Добавить(Значение2);
	Результат.Добавить(Значение3);
	Возврат Результат;
КонецФункции

// Определяет, что закупка от даты ДатаОфициальногоОбъявленияЗакупкиВход до даты
// ДатаИсполненияДоговораВход является многопериодной.
Функция ЗакупкаБольшеГода(ДатаОфициальногоОбъявленияЗакупкиВход, ДатаИсполненияДоговораВход) Экспорт
	РезультатФункции = Ложь;
	Если (ЗначениеЗаполнено(ДатаОфициальногоОбъявленияЗакупкиВход)) И (ЗначениеЗаполнено(ДатаИсполненияДоговораВход)) Тогда
		РезультатФункции = (Год(ДатаОфициальногоОбъявленияЗакупкиВход) < Год(ДатаИсполненияДоговораВход));
	Иначе
		РезультатФункции = Ложь;
	КонецЕсли;
	Возврат РезультатФункции;
КонецФункции		 // ЗакупкаБольшеГода()

// Рассчитывает Сумму контракта документа Строка плана закупок по её таблице
// потребностей ТаблицаВход.
Функция ПолучитьСуммуКонтрактаПоТаблицеПотребности(ТаблицаВход) Экспорт
	// Получим уникальные номера строк.
	РезультатФункции = 0;
	МассивНомеров = Новый Массив;
	Для Каждого ТекПотребностиВНоменклатуреПоПериодам Из ТаблицаВход Цикл
		МассивНомеров.Добавить(ТекПотребностиВНоменклатуреПоПериодам.НомерСтроки);
	КонецЦикла;	
	МассивНомеров = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивНомеров);
	//Для каждой строки увеличим сумму на итоговую сумму.
	Для Каждого ТекМассивНомеров Из МассивНомеров Цикл
		СтруктураПоиска = Новый Структура;
		СтруктураПоиска.Вставить("НомерСтроки", ТекМассивНомеров);
		НайденныеСтроки = ТаблицаВход.НайтиСтроки(СтруктураПоиска);
		МаксимальнаяЦена = 0;
		Для Каждого ТекНайденныеСтроки Из НайденныеСтроки Цикл
			Если ТекНайденныеСтроки.ИтогоЗаВесьПериод > МаксимальнаяЦена Тогда
				МаксимальнаяЦена = ТекНайденныеСтроки.ИтогоЗаВесьПериод;
			Иначе
				// Продолжаем поиск.
			КонецЕсли;
		КонецЦикла;	
		РезультатФункции = РезультатФункции + МаксимальнаяЦена;
	КонецЦикла;	
	Возврат РезультатФункции;
КонецФункции		 // ПолучитьСуммуКонтрактаПоТаблицеПотребности()

#КонецОбласти


#Область РаботаСоСтатьямиБДРВТЧНоменклатура


Функция ПолучитьТаблицуНоменклатурыИзКонтекстаФормы(Форма) Экспорт
	КонтекстУправленияСтатьямиНоменклатуры = Форма.КонтекстУправленияСтатьямиНоменклатуры;
	ИмяТЧНоменклатуры = КонтекстУправленияСтатьямиНоменклатуры.ИмяТЧНоменклатуры;
	
	Если ПустаяСтрока(ИмяТЧНоменклатуры) Тогда
		// Таблица номенклатуры - это реквизит формы
		Возврат Форма[КонтекстУправленияСтатьямиНоменклатуры.ИмяРеквизитаТаблицыНоменклатуры];
	КонецЕсли;
	
	// Таблица номенклатуры - это реквизит объекта формы
	ИмяРеквизитаОбъекта = КонтекстУправленияСтатьямиНоменклатуры.ИмяРеквизитаОбъекта;
	Возврат Форма[ИмяРеквизитаОбъекта][ИмяТЧНоменклатуры];
КонецФункции

Процедура ЗаполнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник)
	ТаблицаПриемник.Очистить();
	Для Каждого СтрокаТаблицыИсточник Из ТаблицаИсточник Цикл
		НоваяСтрокаПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрокаПриемника, СтрокаТаблицыИсточник);
	КонецЦикла;
КонецПроцедуры


#КонецОбласти


#Область ОповещенияПользователям


// Возвращает пустую структуру с полями "Ошибки" и "Успехи" типа Массив.
Функция ПолучитьПустойРезультатРаботы() Экспорт
	Возврат Новый Структура("Ошибки, Успехи", Неопределено, Новый Массив);
КонецФункции

// Добавить в структуру описывающую результат работы сообщение об ошибке.
// Если РезультатРаботы - Неопределено, то создает новый.
// Аргументы см. функцию ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю.
//
// Параметры:
//  РезультатРаботы - Структура - см. функцию ПолучитьПустойРезультатРаботы.
//  ПолеОшибки - Строка - значение, которое задается в свойстве Поле объекта СообщениеПользователю.
//           Для автоподстановки номера строки должна содержать "%1".
//           Например, "Объект.ИНН" или "Объект.Пользователи[%1].Пользователь".
//  ТекстДляОднойОшибки - Строка - текст ошибки для случая, когда ГруппаОшибок в коллекции только одна,
//           например НСтр("ru = 'Пользователь не выбран.'").
//  ГруппаОшибок - Произвольный - используется для выбора либо текста для одной ошибки,
//           либо текста для нескольких ошибок, например, имя "Объект.Пользователи".
//           Если значение не заполнено, тогда используется текст для одной ошибки.
//  НомерСтроки - Число - значение от 0 ... , определяющее номер строки, который нужно подставить
//           в строку ПолеОшибки и в ТекстДляНесколькихОшибок (подставляется НомерСтроки + 1).
//  ТекстДляНесколькихОшибок - Строка - текст ошибки для случая, когда добавлено несколько ошибок с одинаковым
//           свойством ГруппаОшибок, например, НСтр("ru = 'Пользователь в строке %1 не выбран.'").
//  ИндексСтроки - Неопределено - совпадает со значением параметра НомерСтроки.
//           Число - значение от 0 ... , определяющее номер строки, который нужно подставить
//           в строку ПолеОшибки.
//
Процедура ДобавитьОшибку(РезультатРаботы,
						ПолеОшибки,
						ТекстДляОднойОшибки,
						ГруппаОшибок = Неопределено,
						НомерСтроки = 0,
						ТекстДляНесколькихОшибок = "",
						ИндексСтроки = Неопределено) Экспорт
	Если РезультатРаботы = Неопределено Тогда
		РезультатРаботы = ПолучитьПустойРезультатРаботы();
	КонецЕсли;
	ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(
		РезультатРаботы.Ошибки,
		ПолеОшибки,
		ТекстДляОднойОшибки,
		ГруппаОшибок,
		НомерСтроки,
		ТекстДляНесколькихОшибок,
		ИндексСтроки);
КонецПроцедуры

// Добавить в структуру описывающую результат работы сообщение об ошибке.
// Если РезультатРаботы - Неопределено, то создает новый.
//
Процедура ДобавитьУспех(РезультатРаботы, ОписаниеУспеха) Экспорт
	Если РезультатРаботы = Неопределено Тогда
		РезультатРаботы = ПолучитьПустойРезультатРаботы();
	КонецЕсли;
	РезультатРаботы.Успехи.Добавить(ОписаниеУспеха);
КонецПроцедуры

// Вывести сообщения пользователю об ошибках.
//
// Параметры:
//  мСообщений - Массив(Строка|СообщениеПользователю) - сообщения пользователю.
//		Каждая строка выводится отдельным сообщением пользователю.
//		Если в элемент массива - это сообщение пользователю, то оно может быть
//		привязано к элементам открытых пользователем форм.
//  ЗаголовокОповещения - Строка - если заполнено, то будет
//		будет выведено первым сообщением.
//
Процедура СообщитьПользователюИзМассива(мСообщений,
				ЗаголовокОповещения="") Экспорт
	Если НЕ ЗначениеЗаполнено(мСообщений) ИЛИ
				мСообщений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	Если НЕ ПустаяСтрока(ЗаголовокОповещения) Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ЗаголовокОповещения);
	КонецЕсли;
	
	Для Каждого ЭлементСообщения Из мСообщений Цикл
		Если ТипЗнч(ЭлементСообщения) = Тип("Строка") Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ЭлементСообщения);
		ИначеЕсли ТипЗнч(ЭлементСообщения) = Тип("СообщениеПользователю") Тогда
			ЭлементСообщения.Сообщить();
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура СообщитьОшибкиПользователю(РезультатРаботы,
									ЗаголовокОповещенияОбОшибке="") Экспорт
	Если РезультатРаботы.СписокОшибок = Неопределено
			ИЛИ РезультатРаботы.СписокОшибок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	Если НЕ ПустаяСтрока(ЗаголовокОповещенияОбОшибке) Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ЗаголовокОповещенияОбОшибке;
		Сообщение.Сообщить();
	КонецЕсли;
	ОбщегоНазначенияКлиентСервер.СообщитьОшибкиПользователю(РезультатРаботы);
КонецПроцедуры

// Преобразовать сообщения пользователю об ошибках в строку.
//
// Параметры:
//  мСообщений - Массив(Строка|СообщениеПользователю) - сообщения пользователю.
//		Каждая строка выводится отдельным сообщением пользователю.
//		Если в элемент массива - это сообщение пользователю, то оно может быть
//		привязано к элементам открытых пользователем форм.
//	РазделительСообщений - Строка - разделитель, вставляемый между сообщениями.
//		Если не указан, то Символы.ПС.
//  ЗаголовокОповещения - Строка - если заполнено, то будет
//		будет добавлено перед сообщениями.
//
// Возвращает:
//		Строка - заголовок и все сообщения в порядке их появления
//				 в исходном массиве.
//
Функция МассивСообщенийВСтроку(мСообщений,
							   ЗаголовокОповещения="",
							   Знач РазделительСообщений=Неопределено) Экспорт
	Если НЕ ЗначениеЗаполнено(мСообщений) ИЛИ
				мСообщений.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	мРезультат = Новый Массив;
	Если НЕ ПустаяСтрока(ЗаголовокОповещения) Тогда
		мРезультат.Добавить(ЗаголовокОповещения);
	КонецЕсли;
	Для Каждого ЭлементСообщения Из мСообщений Цикл
		Если ТипЗнч(ЭлементСообщения) = Тип("Строка") Тогда
			мРезультат.Добавить(ЭлементСообщения);
		ИначеЕсли ТипЗнч(ЭлементСообщения) = Тип("СообщениеПользователю") Тогда
			мРезультат.Добавить(ЭлементСообщения.Текст);
		КонецЕсли;
	КонецЦикла;
	Если РазделительСообщений = Неопределено Тогда
		РазделительСообщений = Символы.ПС;
	КонецЕсли;
	Возврат СтрСоединить(мРезультат, РазделительСообщений);
КонецФункции

// Сообщить пользователю результаты работы функции.
//
// Параметры:
//  РезультатРаботы	- Структура("Ошибки, Успехи") - содержит два массива
//		с сообщениями об ошибках и успехах, соответственно.
//  ЗаголовокОповещенияОбУспехе - Строка - Если заполнен, то перед всеми
//		сообщениями об успехах будет выведена эта строка.
//  ЗаголовокОповещенияОбОшибке - Строка - Если заполнен, то перед всеми
//		сообщениями об ошибках будет выведена эта строка.
//
Процедура СообщитьПользователюОРезультатахРаботыФункции(
												РезультатРаботы,
												ЗаголовокОповещенияОбУспехе="",
												ЗаголовокОповещенияОбОшибке="") Экспорт
	СообщитьОшибкиПользователю(РезультатРаботы.Ошибки, ЗаголовокОповещенияОбОшибке);
	СообщитьПользователюИзМассива(РезультатРаботы.Успехи, ЗаголовокОповещенияОбУспехе);
КонецПроцедуры

// Возвращает Истина, если нет ошибок, и есть хотя бы один успех.
Функция ПроверитьУспехФункции(РезультатРаботы) Экспорт
	ЕстьОшибки = ЗначениеЗаполнено(РезультатРаботы.Ошибки) И
					РезультатРаботы.Ошибки.Количество() > 0;
	
	Возврат НЕ ЕстьОшибки И ЗначениеЗаполнено(РезультатРаботы.Успехи) И
					РезультатРаботы.Успехи.Количество() > 0;
КонецФункции

// Для объекта с реквизитами формирует текстовое представление вида:
// {Префикс}{ИмяРеквизита}{РазделительЗначений}{Значение реквизита}{РазделительРеквизитов}
// Для самого последнего значения реквизита
// РазделительРеквизитов не вставляется.
//
// Параметры:
//  Объект - Любой объект из которого можно читать значения
//		реквизитов квадратными скобками.
//	мИменаИзмерений - Массив[Строка] - массив имен 
//  РазделительЗначений - Строка - текст вставляемый между именем
//		измерения и его значением.
//  РазделительСтрок - Строка - текст разделяющий измерения.
//		Если не указан, или Неопределено, то вставляет новую строку.
// 
// Возвращаемое значение:
//   - Строка - представление объекта. 
//
Функция ПолучитьПредставлениеОбъекта(Объект,
								мИменаРеквизитов,
								Знач Префикс = "",
								Знач РазделительЗначений = " = ", 
								Знач РазделительРеквизитов = Неопределено) Экспорт
	Если РазделительРеквизитов = Неопределено Тогда
		РазделительРеквизитов = Символы.ПС;
	КонецЕсли;
	Результат = "";
	флПервый = Истина;
	Для Каждого ИмяРеквизита Из мИменаРеквизитов Цикл
		Если флПервый Тогда
			флПервый = Ложь;
		Иначе
			Результат = Результат + РазделительРеквизитов;
		КонецЕсли;
		Результат = Результат + ИмяРеквизита + РазделительЗначений
			+ Объект[ИмяРеквизита];
	КонецЦикла;
	Возврат Результат;
КонецФункции


#КонецОбласти


#Область ПодсистемаСогласования


Функция ЭтоСостояниеУтвержденногоОбъекта(СтатусСогласования) Экспорт
	Возврат СтатусСогласования = 
				ПредопределенноеЗначение(
					"Перечисление.СостоянияСогласования.Утверждена")
		ИЛИ СтатусСогласования = 
				ПредопределенноеЗначение(
					"Перечисление.СтатусыЛотов.ВключенВГПЗ")
		ИЛИ СтатусСогласования = 
				ПредопределенноеЗначение(
					"Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Утвержден")
		ИЛИ СтатусСогласования = 
				ПредопределенноеЗначение(
					"Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Выгружен")
		ИЛИ СтатусСогласования = 
				ПредопределенноеЗначение(
					"Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Размещен");
КонецФункции

Функция ЭтоИмяСобытияСогласования(ИмяСобытия) Экспорт
	Возврат СтрНайти(
		"ОбъектСогласован,
		|ОбъектОтклонен,
		|МаршрутИнициализирован,
		|СостояниеЗаявкиПриИзменении",
		ИмяСобытия) > 0;
КонецФункции

// По состоянию согласования СостояниеВход получает соответствующий
// ему статус выгружаемого объекта.
Функция СостоянияСогласованияВСтатусыВыгружаемыхОбъектов(СостояниеВход) Экспорт
	РезультатФункции = ПредопределенноеЗначение("Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Черновик");
	Если СостояниеВход = ПредопределенноеЗначение("Перечисление.СостоянияСогласования.Черновик") Тогда
		РезультатФункции = ПредопределенноеЗначение("Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Черновик");
	ИначеЕсли СостояниеВход = ПредопределенноеЗначение("Перечисление.СостоянияСогласования.НаУтверждении") Тогда
		РезультатФункции = ПредопределенноеЗначение("Перечисление.СтатусыВыгружаемыхОбъектовЕИС.НаУтверждении");
	ИначеЕсли СостояниеВход = ПредопределенноеЗначение("Перечисление.СостоянияСогласования.Утверждена") Тогда
		РезультатФункции = ПредопределенноеЗначение("Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Утвержден");
	ИначеЕсли СостояниеВход = ПредопределенноеЗначение("Перечисление.СостоянияСогласования.Возвращена") Тогда
		РезультатФункции = ПредопределенноеЗначение("Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Возвращен");
	ИначеЕсли СостояниеВход = ПредопределенноеЗначение("Перечисление.СостоянияСогласования.Отклонена") Тогда
		РезультатФункции = ПредопределенноеЗначение("Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Возвращен");
	ИначеЕсли СостояниеВход = ПредопределенноеЗначение("Перечисление.СостоянияСогласования.ПустаяСсылка") Тогда
		РезультатФункции = ПредопределенноеЗначение("Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Черновик");
	Иначе
		РезультатФункции = ПредопределенноеЗначение("Перечисление.СтатусыВыгружаемыхОбъектовЕИС.Черновик");
	КонецЕсли;
	Возврат РезультатФункции;
КонецФункции		 //	СостоянияСогласованияВСтатусыВыгружаемыхОбъектов()

#КонецОбласти


#Область РаботаСРеквизитамиФормы


// Получить соответствие имен подчиненных элементов
// значениям их реквизита ТолькоПросмотр.
//
// Параметры:
//  Владелец -  - 
//  ТолькоПросмотр - Соответствие| Неопределено - 
//		необязательный. Соответствие имен элементов
//		значениям реквизита "ТолькоПросмотр" для
//		добавления. Если передано Неопределено,
//		то создает новое соответствие
// 
// Возвращаемое значение:
//   - Соответствие {Имя элемента: Булево - значение только просмотр}
//
Функция ПолучитьТолькоПросмотрПодчиненныхЭлементов(
								Владелец, 
								ТолькоПросмотр=Неопределено) Экспорт
	Если ТолькоПросмотр = Неопределено Тогда
		ТолькоПросмотр = Новый Соответствие;
	КонецЕсли;
	Для Каждого Элемент ИЗ Владелец Цикл
		Если ТипЗнч(Элемент)=Тип("ПолеФормы") Тогда
			ТолькоПросмотр[Элемент.Имя] = Элемент.ТолькоПросмотр;
		КонецЕсли;
		Если ТипЗнч(Элемент)=Тип("ГруппаФормы") Тогда
			ПолучитьТолькоПросмотрПодчиненныхЭлементов(
				Элемент.ПодчиненныеЭлементы,
				ТолькоПросмотр);
		КонецЕсли;
	КонецЦикла;
	Возврат ТолькоПросмотр;
КонецФункции

Процедура ВосстановитьТолькоПросмотрЭлементов(
									Форма, 
									ТолькоПросмотр) Экспорт
	Элементы = Форма.Элементы;
	Для Каждого КлючЗнач ИЗ ТолькоПросмотр Цикл
		ЭлементФормы = Элементы[КлючЗнач.Ключ];
		ЭлементФормы.ТолькоПросмотр = КлючЗнач.Значение;
	КонецЦикла;
КонецПроцедуры

	
#КонецОбласти


#Область РаботаСРеквизитамиОбъектов

// В зависимости от вида документа и конфигурации возвращает
//  разные имена реквизитов.
//
// Параметры:
//  Документ - ДокументОбъект | ДокументСсылка - документ валюту которого
//		нужно прочитать.
// 
// Возвращаемое значение:
//   - СправочникСсылка.Валюты - валюта документа.
//	 - Неопределено - передано неверное значение документа или у документа
//			нет реквизитов "ВалютаДокумента", или "Валюта".
//
Функция ПолучитьВалютуДокумента(Документ) Экспорт
	Если Документ <> Неопределено Тогда
		Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
				Документ, "ВалютаДокумента") Тогда
			Возврат Документ.ВалютаДокумента;
		ИначеЕсли ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(
				Документ, "Валюта") Тогда
			Возврат Документ.Валюта;
		КонецЕсли;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Устанавливает значение свойства элемента формы, если находит элемент на форме
//
// Параметры
//  ЭлементыФормы - ВсеЭлементыФормы - элементы формы, среди которых содержится искомый элемент.
//  ИмяЭлемента   - Строка - имя искомого элемента.
//  ИмяСвойства   - Строка - имя свойства, для которого будет устанавливаться значение.
//  Значение      - Произвольный - значение, которое будет установлено
//  УстанавливатьДляПодчиненных - Булево - установить аналогичное свойство для подчиненных элементов искомого элемента.
//
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение, УстанавливатьДляПодчиненных = Ложь) Экспорт
	
	Элемент = ЭлементыФормы.Найти(ИмяЭлемента);
	Если Элемент = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если НРег(ИмяСвойства) = НРег("ТолькоПросмотр")
	И ТипЗнч(Элемент) = Тип("КнопкаФормы") Тогда
		ИмяСвойстваЭлемента = "Доступность";
		ЗначениеСвойства    = НЕ Значение;
	Иначе
		ИмяСвойстваЭлемента = ИмяСвойства;
		ЗначениеСвойства    = Значение;
	КонецЕсли;
	
	Если НРег(ИмяСвойства) = НРег("РасширеннаяПодсказка") Тогда
		Элемент.РасширеннаяПодсказка.Заголовок = Значение;
	Иначе
		Если Элемент[ИмяСвойстваЭлемента] <> ЗначениеСвойства Тогда
			Элемент[ИмяСвойстваЭлемента] = ЗначениеСвойства;
		КонецЕсли;
	КонецЕсли;
	
	ТипыЭлементовФормыСПодчиненнымиЭлементами = Новый ОписаниеТипов("УправляемаяФорма, ГруппаФормы, ТаблицаФормы");
	
	Если УстанавливатьДляПодчиненных И ТипыЭлементовФормыСПодчиненнымиЭлементами.СодержитТип(ТипЗнч(Элемент)) Тогда
		Для Каждого ПодчиненныйЭлемент Из Элемент.ПодчиненныеЭлементы Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ПодчиненныйЭлемент.Имя, ИмяСвойства, Значение, Истина);
		КонецЦикла;
 	КонецЕсли;
 	
КонецПроцедуры // УстановитьСвойствоЭлементаФорма()


#КонецОбласти


#Область ПолучениеНастроекМетаданных


// Имена измерений регистра накопления ПотребностиВНоменклатуре
//
Функция ИменаКлючевыхПолейПотребности() Экспорт 
	Возврат	СтрСоединить(
		ПолучитьМассивИменаКлючевыхПолейПотребности(),
		",");
КонецФункции

Функция ПолучитьМассивИменаКлючевыхПолейПотребности() Экспорт
	Результат = Новый Массив;
	Результат.Добавить("Приоритет");
	Результат.Добавить("Номенклатура");
	Результат.Добавить("Характеристика");
	Результат.Добавить("ПериодПотребности");
	Результат.Добавить("Организация");
	Результат.Добавить("МестоПоставки");
	Результат.Добавить("Проект");
	Результат.Добавить("ДоговорСПокупателем");
	Результат.Добавить("Менеджер");
	Возврат Результат;
КонецФункции

// Получить представление имег ключевых полей потребности.
// 
// Возвращаемое значение:
//   - Структура:
//		- ключ - имя реквизита потребности;
//		- значение - представление реквизита для пользователя.
//
Функция ПолучитьПредставлениеКлючевыхПолейПотребности() Экспорт
	Результат = Новый Структура;
	Результат.Вставить("Приоритет", НСтр("ru='Приоритет'"));
	Результат.Вставить("Номенклатура", НСтр("ru='Номенклатура'"));
	Результат.Вставить("Характеристика", НСтр("ru='Характеристика'"));
	Результат.Вставить("ПериодПотребности", НСтр("ru='ПериодПотребности'"));
	Результат.Вставить("Организация", НСтр("ru='Организация'"));
	Результат.Вставить("МестоПоставки", НСтр("ru='МестоПоставки'"));
	Результат.Вставить("Проект", НСтр("ru='Проект'"));
	Результат.Вставить("ДоговорСПокупателем", НСтр("ru='ДоговорСПокупателем'"));
	Результат.Вставить("Менеджер", НСтр("ru='Менеджер'"));
	Возврат Результат;
КонецФункции

Функция ПолучитьМассивИменаКлючевыхПолейЗаказа() Экспорт
	Результат = ПолучитьМассивИменаКлючевыхПолейПотребности();
	Результат.Добавить("Лот");
	Возврат Результат;
КонецФункции

// Имена ключевых полей кросс-таблицы с потребностями.
// Из нее удалено поле периода потребности
//
Функция ИменаКлючевыхПолейКроссТаблицыПотребностей() Экспорт 
	Возврат	СтрЗаменить(
		ИменаКлючевыхПолейПотребности(), 
		"ПериодПотребности,", 
		"");
КонецФункции
		
// Имена измерений регистра накопления ПланПоставокПоДоговорам
//
Функция ИменаКлючевыхПолейПоставокПоДоговорам() Экспорт 
	Возврат	"Договор,
			|Приоритет,
			|Номенклатура,
			|Характеристика,
			|ПериодПотребности,
			|Организация,
			|МестоПоставки,
			|Проект,
			|Менеджер,
			|ДоговорСПокупателем,
			|Лот"
КонецФункции

// Имена измерений регистра накопления ЗаказыПоставщикамУХ
//
Функция ИменаКлючевыхПолейЗаказовПоставщикам() Экспорт 
	Возврат	"ЗаказПоставщику,
			|Приоритет,
			|ПериодПотребности,
			|НоменклатураИсходная,
			|ХарактеристикаИсходная,
			|Номенклатура,
			|Характеристика,
			|Лот,
			|Проект,
			|Организация,
			|МестоПоставки,
			|Менеджер,
			|ДоговорСПокупателем,
			|Склад"
КонецФункции

Функция ИменаКлючевыхПолейПредложенияПоставщика() Экспорт
	// Переносы не допускаются
	Возврат "Номенклатура,Характеристика,МестоПоставки";
КонецФункции

Функция ИменаКлючевыхПолейВыбораПобедителяЛота() Экспорт
	// Переносы не допускаются
	Возврат "Приоритет,Номенклатура,Характеристика,Организация,МестоПоставки,Проект,ДоговорСПокупателем,ПредложениеПоставщика";
КонецФункции

Функция ИменаКлючевыхПолейВерсииСоглашенияКоммерческийДоговор() Экспорт
	Возврат "Лот,Приоритет,Номенклатура,Характеристика,Организация,МестоПоставки,Проект,ДоговорСПокупателем,Менеджер";
КонецФункции

// Возвращает массив видов договоров с контрагентом
//  по которым возможна работа в рамках централизованных
//  закупок.
// 
// Возвращаемое значение:
//   ФиксированныйМассив(СправочникСсылка.ВидыДоговоровКонтрагентовУХ)
//		допустимые виды договоров.
//
Функция ПолучитьВидыДоговоровУХ() Экспорт
	Возврат Новый ФиксированныйМассив(
		РаботаСДоговорамиКонтрагентовУХКлиентСервер.ВидыДоговоровСПоставщиком());
КонецФункции

// Проверяет, что с видом договора с контрагентом
//  возможна работа в рамках централизованных закупок.
//
// Параметры:
//  ВидДоговораУХ - СправочникСсылка.ВидыДоговоровКонтрагентовУХ -
//		вид договора для проверки.
// 
// Возвращаемое значение:
//   Булево - Истина - возможно использовать договор с данным
//		видом. Ложь - нельзя.
//
Функция ЭтоДопустимыйВидДоговораУХ(ВидДоговораУХ) Экспорт
	Возврат ПолучитьВидыДоговоровУХ()
			.Найти(ВидДоговораУХ) <> Неопределено;
КонецФункции

// Определяет, что причина ПричинаВход является причиной по единственному предложению.
Функция ПричинаЕдинственноеПредложение(ПричинаВход) Экспорт
	РезультатФункции = Ложь;
	МассивПричинЕдинственногоПоставщика = Новый Массив;
	МассивПричинЕдинственногоПоставщика.Добавить(ПредопределенноеЗначение("Перечисление.ПричиныПризнанияЗакупкиНесостоявшейся.ПоданаОднаЗаявка"));
	МассивПричинЕдинственногоПоставщика.Добавить(ПредопределенноеЗначение("Перечисление.ПричиныПризнанияЗакупкиНесостоявшейся.ДопущенОдинУчастник"));
	МассивПричинЕдинственногоПоставщика.Добавить(ПредопределенноеЗначение("Перечисление.ПричиныПризнанияЗакупкиНесостоявшейся.Иная"));
	НайденнаяПричина = МассивПричинЕдинственногоПоставщика.Найти(ПричинаВход);
	РезультатФункции = (НайденнаяПричина <> Неопределено);
	Возврат РезультатФункции;
КонецФункции		 // ПричинаЕдинственноеПредложение()

// Определяет, что способ выбора поставщика СпособВыбораВход относится только к 
// электронным торгам.
Функция ЭтоСпособВЭлектроннойФорме(СпособВыбораВход) Экспорт
	РезультатФункции = Ложь;
	МассивЗакупкиВЭлектроннойФорме = Новый Массив;
	МассивЗакупкиВЭлектроннойФорме.Добавить(ПредопределенноеЗначение("Перечисление.СпособыВыбораПоставщика.Аукцион"));
	МассивЗакупкиВЭлектроннойФорме.Добавить(ПредопределенноеЗначение("Перечисление.СпособыВыбораПоставщика.КонкурсУМсп"));
	МассивЗакупкиВЭлектроннойФорме.Добавить(ПредопределенноеЗначение("Перечисление.СпособыВыбораПоставщика.АукционУМсп"));
	МассивЗакупкиВЭлектроннойФорме.Добавить(ПредопределенноеЗначение("Перечисление.СпособыВыбораПоставщика.ЗапросКотировокУМсп"));
	МассивЗакупкиВЭлектроннойФорме.Добавить(ПредопределенноеЗначение("Перечисление.СпособыВыбораПоставщика.ЗапросПредложенийУМсп"));
	РезультатФункции = (МассивЗакупкиВЭлектроннойФорме.Найти(СпособВыбораВход) <> Неопределено);
	Возврат РезультатФункции;
КонецФункции		 // ЭтоСпособВЭлектроннойФорме()

// Возвращает строку длиной не более определенного количества символов.
// Если строка больше - она обрезается и в конец добавляется многоточие.
//
// Параметры:
//  ИсходнаяСтрока		 - Строка 
//  МаксимальнаяДлина	 - Число 
//
// Возвращаемое значение:
//  Строка 
//
Функция ПредставлениеСтрокиСДлинойНеБолее(ИсходнаяСтрока, МаксимальнаяДлина) Экспорт
	
	Если СтрДлина(ИсходнаяСтрока) <= МаксимальнаяДлина Тогда
		Возврат ИсходнаяСтрока;
	Иначе
		Возврат Лев(ИсходнаяСтрока, СтрДлина(ИсходнаяСтрока) - 3) + "...";
	КонецЕсли;
	
КонецФункции

#КонецОбласти


#Область НоменклатураСОсобымПорядкомЗакупки

// Для объекта и структуры с настройками особого порядка закупки возвращает
//  имена полей и их значения, которые должны быть установлены по значениям
//  реквизитов особого порядка закупки номенклатуры.
//
// Параметры:
//  Объект - любой объект для анализа значений его реквизитов. 
//  ЗначенияРеквизитовОсобогоПорядка - Структура - описывает значения
//		по которым нужно обновлять реквизиты объекта.
//  НастройкаСоотвествияИмен - Структура - ключ - имя реквизита в
//		структуре ЗначенияРеквизитовОсобогоПорядка; значение - имя
//		соответствующего реквизита объекта.
// 
// Возвращаемое значение:
//	- Структура, где имена ее полей - это имена реквизитов объекта, которые
//		нужно изменить по значению настройки;
//		значения - это значения для установки.
//
Функция ПолучитьРеквизитыДляУстановкиПоНастройкамОсобогоПорядкаЗакупки(
												Объект,
												ЗначенияРеквизитовОсобогоПорядка,
												НастройкаСоотвествияИмен) Экспорт
	РеквизитыДляИзменения = Новый Структура;
	Если ЗначенияРеквизитовОсобогоПорядка <> Неопределено Тогда
		Для Каждого КлючЗначение Из НастройкаСоотвествияИмен Цикл
			флРегистрировать = ЗарегистрироватьРеквизитДляИзмененияЗначения(
				Объект[КлючЗначение.Значение], 
				ЗначенияРеквизитовОсобогоПорядка[КлючЗначение.Ключ]);
			Если флРегистрировать Тогда
				РеквизитыДляИзменения.Вставить(
					КлючЗначение.Значение,
					ЗначенияРеквизитовОсобогоПорядка[КлючЗначение.Ключ]);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат РеквизитыДляИзменения;
КонецФункции


#КонецОбласти


#Область НеэкспортныеФункцииПроцедуры


Функция ЗарегистрироватьРеквизитДляИзмененияЗначения(СтароеЗначение, 
													   НовоеЗначение) 
	ТипНовогоЗначения = ТипЗнч(НовоеЗначение);
	Если ТипНовогоЗначения = Тип("Булево") Тогда
		// Булев реквизит изменяем, только если устанавливаем в Истину.
		Возврат (НовоеЗначение = Истина);
	КонецЕсли;
	// Все остальные реквизиты изменяем только если они еще не заполнены.
	Возврат НЕ ЗначениеЗаполнено(СтароеЗначение) И ЗначениеЗаполнено(НовоеЗначение);
КонецФункции


#КонецОбласти