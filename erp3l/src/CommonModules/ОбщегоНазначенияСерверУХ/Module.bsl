#Область ПрограммныйИнтерфейс

////////////////////////////////////////////////////////////////////////////////
// Работа с массивами и таблицами значений

// Функция возвращает результат вычитания элементов множества таблицы
// ТаблицаВычитаемая из ТаблицаОсновная.
//
Функция ВычестьТаблицу(знач ТаблицаОсновная,
                       знач ТаблицаВычитаемая,
                       знач КолонкаСравненияОсновнойТаблицы = "",
                       знач КолонкаСравненияВычитаемойТаблицы = "") Экспорт
	
	Если Не ЗначениеЗаполнено(КолонкаСравненияОсновнойТаблицы) Тогда
		КолонкаСравненияОсновнойТаблицы = "Значение";
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(КолонкаСравненияВычитаемойТаблицы) Тогда
		КолонкаСравненияВычитаемойТаблицы = "Значение";
	КонецЕсли;
	
	ТаблицаРезультат = Новый ТаблицаЗначений;
	ТаблицаРезультат = ТаблицаОсновная.Скопировать();
	
	Для Каждого Элемент Из ТаблицаВычитаемая Цикл
		Значение = Элемент[КолонкаСравненияОсновнойТаблицы];
		НайденнаяСтрока = ТаблицаРезультат.Найти(Значение, КолонкаСравненияОсновнойТаблицы);
		Если НайденнаяСтрока <> Неопределено Тогда
			ТаблицаРезультат.Удалить(НайденнаяСтрока);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТаблицаРезультат;
	
КонецФункции

// Функция возвращает таблицу созданную на основе ТаблицаИнициализации.
// Если ТаблицаИнициализации не указана, то создается пустая таблица.
//
Функция СоздатьТаблицуСравнения(ТаблицаИнициализации = Неопределено,
                                ИмяКолонкиСравнения = "Значение") Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить(ИмяКолонкиСравнения);
	
	Если ТаблицаИнициализации <> Неопределено Тогда
		
		МассивЗначений = ТаблицаИнициализации.ВыгрузитьКолонку(ИмяКолонкиСравнения);
		
		Для Каждого Элемент Из ТаблицаИнициализации Цикл
			НоваяСтрока = Таблица.Добавить();
			НоваяСтрока.Установить(0, Элемент[ИмяКолонкиСравнения]);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Таблица;

КонецФункции

// Найти в представлении дерева строку по структуре отбора.
//
Функция НайтиВДанныхФормыДерево(СтруктураОтбора, ДанныеФормыДерево) Экспорт
	
	ЭлементыФормы = ДанныеФормыДерево.ПолучитьЭлементы();
	
	Для Каждого Элемент Из ЭлементыФормы Цикл
		
		СоответствиеЕсть = Истина;
		
		Для Каждого ЭлементОтбора Из СтруктураОтбора Цикл
			Если Элемент[ЭлементОтбора.Ключ] <> ЭлементОтбора.Значение Тогда
				СоответствиеЕсть = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если СоответствиеЕсть Тогда
			Возврат Элемент;
		КонецЕсли;
		
		РезультатПроверки = НайтиВДанныхФормыДерево(СтруктураОтбора, Элемент);
		
		Если РезультатПроверки <> Неопределено Тогда
			Возврат РезультатПроверки;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// РАСЧЕТ ПЕРИОДИЧЕСКИХ КУРСОВ.
//

// Процедура выполняет заполнение периодических курсов
//
Функция ЗаполнитьПериодическиеКурсыВалют(Период, Сценарий = Неопределено, ПериодОкончание = Неопределено) Экспорт
	
	Перем ТаблицаПредыдущихКурсов;
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	ТаблицаЗначений.Колонки.Добавить("Валюта",                         	Новый ОписаниеТипов("СправочникСсылка.Валюты"));
	ТаблицаЗначений.Колонки.Добавить("Кратность",                      	ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10, 0));
	ТаблицаЗначений.Колонки.Добавить("СреднийКурсЗаПериод",            	ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10, 4));
	ТаблицаЗначений.Колонки.Добавить("СреднийКурсЗаПериодЦБ",        	ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10, 4));
	ТаблицаЗначений.Колонки.Добавить("СреднийКурсЗаПериодМСФО",        	ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10, 4));
	ТаблицаЗначений.Колонки.Добавить("КурсНаНачалоПериода",            	ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10, 4));
	ТаблицаЗначений.Колонки.Добавить("КурсНаКонецПериода",             	ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10, 4));	
	ТаблицаЗначений.Колонки.Добавить("КурсНаКонецПредыдущегоПериода",  	ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10, 4));
	ТаблицаЗначений.Колонки.Добавить("СреднийКурсЗаПредыдущийПериодЦБ",	ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10, 4));
	ТаблицаЗначений.Колонки.Добавить("СреднийКурсЗаПредыдущийПериод",	ОбщегоНазначенияУХ.ПолучитьОписаниеТиповЧисла(10, 4));
		
	Если ЗначениеЗаполнено(Сценарий)   Тогда

		ПредыдущийПериод = ОбщегоНазначенияУХ.глОтносительныйПериод(Период, -1, Истина);
			
		Если ЗначениеЗаполнено(ПредыдущийПериод) Тогда
			
			Запрос = Новый Запрос;
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	ПериодическиеКурсы.Валюта,
			|	ПериодическиеКурсы.Кратность,
			|	ПериодическиеКурсы.СреднийКурсЗаПериод,
			|	ПериодическиеКурсы.КурсНаКонецПериода,
			|	ПериодическиеКурсы.СреднийКурсЗаПериодЦБ
			|ИЗ
			|	РегистрСведений.ПериодическиеКурсы КАК ПериодическиеКурсы
			|ГДЕ
			|	ПериодическиеКурсы.Сценарий = &Сценарий
			|	И ПериодическиеКурсы.ПериодКурса = &ПериодКурса";
			
			Запрос.УстановитьПараметр("Сценарий", Сценарий);
			Запрос.УстановитьПараметр("ПериодКурса", ПредыдущийПериод);
			
			ТаблицаПредыдущихКурсов = Запрос.Выполнить().Выгрузить();
			ТаблицаПредыдущихКурсов.Индексы.Добавить("Валюта");
			
		КонецЕсли;		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КурсыВалют.Период КАК Период,
	|	КурсыВалют.Валюта КАК Валюта,
	|	КурсыВалют.Курс / КурсыВалют.Кратность КАК Курс,
	|	РАЗНОСТЬДАТ(&ДатаНачала, КурсыВалют.Период, ДЕНЬ) + 1 КАК ДеньКурса,
	|	КурсыВалют.Кратность
	|ИЗ
	|	РегистрСведений.КурсыВалют КАК КурсыВалют
	|ГДЕ
	|	КурсыВалют.Период > &ДатаНачала
	|	И КурсыВалют.Период < &ДатаОкончания
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	&ДатаНачала,
	|	КурсыВалютСрезПоследних.Валюта,
	|	КурсыВалютСрезПоследних.Курс / КурсыВалютСрезПоследних.Кратность,
	|	1,
	|	КурсыВалютСрезПоследних.Кратность
	|ИЗ
	|	РегистрСведений.КурсыВалют.СрезПоследних(&ДатаНачала, ) КАК КурсыВалютСрезПоследних
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	&ДатаОкончания,
	|	КурсыВалютСрезПоследних.Валюта,
	|	КурсыВалютСрезПоследних.Курс / КурсыВалютСрезПоследних.Кратность,
	|	РАЗНОСТЬДАТ(&ДатаНачала, &ДатаОкончания, ДЕНЬ) + 1,
	|	КурсыВалютСрезПоследних.Кратность
	|ИЗ
	|	РегистрСведений.КурсыВалют.СрезПоследних(&ДатаОкончания, ) КАК КурсыВалютСрезПоследних
	|ГДЕ
	|	(НЕ &ДатаНачала = &ДатаОкончания)
	|
	|УПОРЯДОЧИТЬ ПО
	|	Период
	|ИТОГИ ПО
	|	Валюта";
	
	Запрос.УстановитьПараметр("ДатаНачала",    Период.ДатаНачала);		
	Запрос.УстановитьПараметр("ДатаОкончания", Период.ДатаОкончания);
	Период_ДатаОкончания = Период.ДатаОкончания;
	
	ВыборкаВалют = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	МаксОснование = Pow(10,5);
	МинОснование = Pow(10, -5);
		
	Пока ВыборкаВалют.Следующий() Цикл
		
		ПрошлыйДеньКурса	= Неопределено;
		ПрошлыйКурс      	= Неопределено;
		
		ПредДатаКурса      	= Период.ДатаНачала;
		ПредМесяцКурса		= Месяц(Период.ДатаНачала);
		КурсыПоМесяцам	    = Новый Соответствие;
		
		ВыборкаКурсов = ВыборкаВалют.Выбрать();
		
		Пока ВыборкаКурсов.Следующий() Цикл
			
			Если ВыборкаКурсов.Период = Период.ДатаНачала Тогда
				
				КурсНаНачалоПериода = ВыборкаКурсов.Курс;
				СреднийКурсЗаПериод            = 1 / ВыборкаКурсов.Курс;
				
			Иначе
				
				СреднийКурсЗаПериод = СреднийКурсЗаПериод + 1 / ВыборкаКурсов.Курс + (ВыборкаКурсов.ДеньКурса - ПрошлыйДеньКурса - 1) / ПрошлыйКурс;
				
			КонецЕсли;
			
			Если ВыборкаКурсов.Период = Период_ДатаОкончания Тогда
				
				КурсНаКонецПериода	= ВыборкаКурсов.Курс;
				СреднийКурсЗаПериод	= ВыборкаКурсов.ДеньКурса / СреднийКурсЗаПериод;
				Кратность           = ВыборкаКурсов.Кратность;
				
			КонецЕсли;
			
			ТекМесяц = Месяц(ВыборкаКурсов.Период);
			Для НомерМесяца = ПредМесяцКурса По ТекМесяц Цикл
			
				КурсыТекущегоМесяца = КурсыПоМесяцам.Получить(НомерМесяца);
				ТекущийДеньКонцаМесяца = День(КонецМесяца(ДобавитьМесяц(ПредДатаКурса, НомерМесяца - ПредМесяцКурса)));
				Если КурсыТекущегоМесяца = Неопределено Тогда					
				 	КурсыТекущегоМесяца = Новый Структура("ПроизведениеКурсов, ЧислоДней", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(1), ТекущийДеньКонцаМесяца);
				КонецЕсли;
				
				ТекДеньНачала = ?(НомерМесяца = ПредМесяцКурса, ?(ПрошлыйДеньКурса = Неопределено, День(Период.ДатаНачала)-1, День(ПредДатаКурса)), 0);
				ТекДеньОкончания = ?(НомерМесяца = ТекМесяц, День(ВыборкаКурсов.Период), ТекущийДеньКонцаМесяца);
				ТекущийКурс = ?(ПрошлыйКурс = Неопределено, ВыборкаКурсов.Курс, ПрошлыйКурс);
				
				ПредПроизведение = КурсыТекущегоМесяца.ПроизведениеКурсов[КурсыТекущегоМесяца.ПроизведениеКурсов.Количество()-1];
				
				ПроизведениеКурсов = ПредПроизведение * Pow(ТекущийКурс, ТекДеньОкончания - ТекДеньНачала);// степень - число дней повтора курса				
				КурсыТекущегоМесяца.ПроизведениеКурсов[КурсыТекущегоМесяца.ПроизведениеКурсов.Количество()-1] = ПроизведениеКурсов;
				
				Если (ПроизведениеКурсов >= МаксОснование) Или (ПроизведениеКурсов <= МинОснование) Тогда
					КурсыТекущегоМесяца.ПроизведениеКурсов.Добавить(1);
				КонецЕсли;
				
				КурсыПоМесяцам.Вставить(НомерМесяца, КурсыТекущегоМесяца);
							
			КонецЦикла;
			
			ПрошлыйДеньКурса    = ВыборкаКурсов.ДеньКурса;
			ПрошлыйКурс         = ВыборкаКурсов.Курс;
			
			ПредДатаКурса      	= ВыборкаКурсов.Период;
			ПредМесяцКурса		= ТекМесяц;
			
		КонецЦикла;
		
		Движение = ТаблицаЗначений.Добавить();
		
		Движение.Валюта                     = ВыборкаВалют.Валюта;
		Движение.КурсНаНачалоПериода        = КурсНаНачалоПериода * Кратность;
		Движение.КурсНаКонецПериода         = КурсНаКонецПериода * Кратность;
		Движение.СреднийКурсЗаПериод        = СреднийКурсЗаПериод * Кратность;
		Движение.СреднийКурсЗаПериодМСФО	= (КурсНаНачалоПериода + КурсНаКонецПериода) / 2 * Кратность;
		Движение.СреднийКурсЗаПериодЦБ		= ПолучитьСреднийКурсЗаПериодЦБ(КурсыПоМесяцам, Период) * Кратность;
		Движение.Кратность                  = Кратность;
		
		Если ТаблицаПредыдущихКурсов <> Неопределено Тогда
			
			СтрокаПредыдущихКурсов = ТаблицаПредыдущихКурсов.Найти(Движение.Валюта, "Валюта");
			Если СтрокаПредыдущихКурсов <> Неопределено Тогда
				
				Движение.КурсНаКонецПредыдущегоПериода 		= СтрокаПредыдущихКурсов.КурсНаКонецПериода;
				Движение.СреднийКурсЗаПредыдущийПериод 		= СтрокаПредыдущихКурсов.СреднийКурсЗаПериод;
				Движение.СреднийКурсЗаПредыдущийПериодЦБ 	= СтрокаПредыдущихКурсов.СреднийКурсЗаПериодЦБ;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла; 
	
	Возврат ТаблицаЗначений;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С ПЕРИОДАМИ.
//

Функция МассивПодпериодов(ОсновнойПериод, Периодичность, Упорядочить=Ложь) Экспорт
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Периоды.Ссылка
		|ИЗ
		|	Справочник.Периоды КАК Периоды
		|ГДЕ
		|	Периоды.Родитель В ИЕРАРХИИ(&Родитель)
		|	И НЕ Периоды.ПометкаУдаления
		|	И Периоды.Периодичность = &Периодичность";
		
	Если Упорядочить Тогда
		Запрос.Текст = Запрос.Текст +
			"
			|УПОРЯДОЧИТЬ ПО
			|	Периоды.ДатаНачала";
	КонеЦЕсли;
	
	Запрос.УстановитьПараметр("Периодичность", Периодичность);
	Запрос.УстановитьПараметр("Родитель", ОсновнойПериод);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Новый Массив;
	КонецЕсли;
	
	Возврат РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("Ссылка");
КонецФункции

Функция ВернутьТаблицуДоступныхПериодов() Экспорт
	
	ТаблицаПериодов = Новый ТаблицаЗначений;
	ТаблицаПериодов.Колонки.Добавить("Периодичность", Новый ОписаниеТипов("ПеречислениеСсылка.Периодичность"));
	ТаблицаПериодов.Колонки.Добавить("Код", ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(50));
	ТаблицаПериодов.Колонки.Добавить("Представление", ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(200));
	ТаблицаПериодов.Колонки.Добавить("ДатаПериода", ОбщегоНазначенияУХ.ПолучитьОписаниеТиповДаты(ЧастиДаты.Дата));
	
	ТекущаяДата = ТекущаяДата();
	
	Для Каждого Элемент Из Перечисления.Периодичность Цикл
		
		НоваяСтрока = ТаблицаПериодов.Добавить();
		
		Если Элемент = Перечисления.Периодичность.Год
		 ИЛИ Элемент = Перечисления.Периодичность.Месяц
		 ИЛИ Элемент = Перечисления.Периодичность.День Тогда
			ТекстПред = "Предыдущий";
			ТекстТек  = "Текущий";
			ТекстСлед = "Следующий";
		ИначеЕсли Элемент = Перечисления.Периодичность.Неделя
			  ИЛИ Элемент = Перечисления.Периодичность.Декада Тогда
			ТекстПред = "Предыдущая";
			ТекстТек  = "Текущая";
			ТекстСлед = "Следующая";
		ИначеЕсли Элемент = Перечисления.Периодичность.Полугодие Тогда
			ТекстПред = "Предыдущее";
			ТекстТек  = "Текущее";
			ТекстСлед = "Следующее";
		Иначе
			Продолжить;
		КонецЕсли;
		
		
		НоваяСтрока.Представление = ТекстПред + " " + Элемент;
		НоваяСтрока.Код           = "П_" + Элемент;
		НоваяСтрока.ДатаПериода   = ОпределитьОтносительнуюДату(ТекущаяДата, Элемент, -1);
		НоваяСтрока.Периодичность = Элемент;
		
		НоваяСтрока = ТаблицаПериодов.Добавить();
		НоваяСтрока.Представление = ТекстТек + " " + Элемент;
		НоваяСтрока.Код           = "Т_" + Элемент;
		НоваяСтрока.ДатаПериода   = ТекущаяДата;
		НоваяСтрока.Периодичность = Элемент;
		
		НоваяСтрока = ТаблицаПериодов.Добавить();
		НоваяСтрока.Представление = ТекстСлед + " " + Элемент;
		НоваяСтрока.Код           = "С_" + Элемент;
		НоваяСтрока.ДатаПериода   = ОпределитьОтносительнуюДату(ТекущаяДата, Элемент, 1);
		НоваяСтрока.Периодичность = Элемент;
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВИ.Код,
	|	ВИ.Представление,
	|	ВИ.Периодичность,
	|	ВИ.ДатаПериода
	|ПОМЕСТИТЬ ТаблицаПериметров
	|ИЗ
	|	&ВнешнийИсточник КАК ВИ
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаПериметров.Код КАК Код,
	|	ТаблицаПериметров.Представление КАК Представление,
	|	Периоды.Ссылка КАК Период
	|ИЗ
	|	Справочник.Периоды КАК Периоды
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ТаблицаПериметров КАК ТаблицаПериметров
	|		ПО (ТаблицаПериметров.Периодичность = Периоды.Периодичность)
	|			И (ТаблицаПериметров.ДатаПериода >= Периоды.ДатаНачала)
	|			И (ТаблицаПериметров.ДатаПериода <= Периоды.ДатаОкончания)
	|ИТОГИ ПО
	|	Код,
	|	Представление";
	
	Запрос.УстановитьПараметр("ВнешнийИсточник", ТаблицаПериодов);
	ВЫборка = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	ТаблицаОтвета = Новый ТаблицаЗначений;
	ТаблицаОтвета.Колонки.Добавить("Код", ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(50));
	ТаблицаОтвета.Колонки.Добавить("Представление", ОбщегоНазначенияУХ.ПолучитьОписаниеТиповСтроки(200));
	ТаблицаОтвета.Колонки.Добавить("Период"       , Новый ОписаниеТипов("СправочникСсылка.Периоды"));
	
	Пока Выборка.Следующий() Цикл
		ВыборкаПоПредставлению = Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		Если ВыборкаПоПредставлению.Следующий() Тогда
			
			ВыборкаДетализация = ВыборкаПоПредставлению.Выбрать();
			Если ВыборкаДетализация.Следующий() Тогда
				
				ЗаполнитьЗначенияСвойств(ТаблицаОтвета.Добавить(), ВыборкаДетализация);
				
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТаблицаОтвета;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ОБРАБОТКА МУЛЬТИЯЗЫЧНОСТИ
//
// Процедура обеспечивает управление видимостью и наименованием полей формы, отражающих иноязычные данные.
//
// Параметры:
//  Элементы - 	ЭлементыФормы - Коллекция элементов формы, содержащая реквизиты поддержки многоязычности.
Процедура ПоддержкаМультиязычностиУправлениеФормой(Элементы) Экспорт
	
	Если Элементы.Найти("ПоддержкаМногоязычности") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаЯзыков = ОбщегоНазначенияПовтИспУХ.ПолучитьДополнительныеЯзыки();
	
	Если ТаблицаЯзыков = Неопределено ИЛИ ТаблицаЯзыков.Количество() = 0 Тогда
		Элементы.ПоддержкаМногоязычности.Видимость = Ложь;
	Иначе	
		Элементы.ПоддержкаМногоязычности.Видимость = Истина;
		Для Инд = 1 По 2 Цикл
			ОтображатьДопЯзык = Инд <= ТаблицаЯзыков.Количество();
			ИмяЭлементаГруппа = "ГруппаЯзык" + Строка(Инд);
			Если Элементы.Найти(ИмяЭлементаГруппа) <> Неопределено Тогда
				ГруппаРеквизитовЯзыка = Элементы[ИмяЭлементаГруппа];
				ГруппаРеквизитовЯзыка.Видимость = ОтображатьДопЯзык;
				Если ОтображатьДопЯзык Тогда
					ГруппаРеквизитовЯзыка.Заголовок = ТаблицаЯзыков[Инд - 1].НаименованиеЯзыка;
					КодЯзыка = ТаблицаЯзыков[Инд - 1].КодЯзыка;
					Для Каждого ТекПодчиненныйЭлемент Из ГруппаРеквизитовЯзыка.ПодчиненныеЭлементы Цикл
						ТекПодчиненныйЭлемент.Заголовок = СтрЗаменить(ТекПодчиненныйЭлемент.Заголовок, "Язык" + Инд, КодЯзыка);
					КонецЦикла;
				КонецЕсли;
			Иначе
				Продолжить;
			КонецЕсли;
 		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Функция ПериодГод(Период) Экспорт
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Периоды.Ссылка
		|ИЗ
		|	Справочник.Периоды КАК Периоды
		|ГДЕ
		|	НЕ Периоды.ПометкаУдаления
		|	И Периоды.ДатаНачала <= &Дата
		|	И Периоды.ДатаОкончания >= &Дата
		|	И Периоды.Периодичность = ЗНАЧЕНИЕ(Перечисление.Периодичность.Год)";

	Запрос.УстановитьПараметр("Дата", Период.ДатаНачала);

	РезультатЗапроса = Запрос.Выполнить();

	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
    
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Возврат ВыборкаДетальныеЗаписи.Ссылка;
	КонецЦикла;

	
	Возврат Неопределено;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С ФОРМАМИ.
//

Процедура ЗаменитьУдалитьПараметрВыбора(Элемент, Имя, НовыйПараметрВыбора = Неопределено) Экспорт

	МассивПараметров = Новый Массив;
	Для Каждого СвязьПараметровВыбора Из Элемент.ПараметрыВыбора Цикл
		Если ВРег(СвязьПараметровВыбора.Имя) <> ВРег(Имя) Тогда
			МассивПараметров.Добавить(СвязьПараметровВыбора);
		КонецЕсли;
	КонецЦикла;

	Если НовыйПараметрВыбора <> Неопределено Тогда
		МассивПараметров.Добавить(НовыйПараметрВыбора);
	КонецЕсли;
	
	Элемент.ПараметрыВыбора = Новый ФиксированныйМассив(МассивПараметров);

КонецПроцедуры

Процедура ОбновитьСписокРесурсовРегистра(РегистрБухгалтерии,РеквизитРесурс,ЭлементРесурс) Экспорт
	
	Если НЕ ЗначениеЗаполнено(РегистрБухгалтерии) Тогда
		
		РеквизитРесурс="";
		Возврат;
		
	КонецЕсли;
	
	ТекЗначениеРесурса=РеквизитРесурс;
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|	РегистрыБухгалтерииБДРесурсы.Имя КАК Имя,
	|	РегистрыБухгалтерииБДРесурсы.Синоним
	|ИЗ
	|	Справочник.РегистрыБухгалтерииБД.Ресурсы КАК РегистрыБухгалтерииБДРесурсы
	|ГДЕ
	|	РегистрыБухгалтерииБДРесурсы.Ссылка = &Ссылка
	|
	|УПОРЯДОЧИТЬ ПО
	|	РегистрыБухгалтерииБДРесурсы.ПризнакУчета";
	
	Запрос.УстановитьПараметр("Ссылка",РегистрБухгалтерии);
	
	ЭлементРесурс.СписокВыбора.Очистить();
	
	Результат=Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		
		РегистрОбъект=РегистрБухгалтерии.ПолучитьОбъект();
		РегистрОбъект.ЗаполнитьРеквизитыОбъекта();
		РегистрОбъект.Записать();
		
		Для Каждого Ресурс ИЗ РегистрОбъект.Ресурсы Цикл
			
			ЭлементРесурс.СписокВыбора.Добавить(Ресурс.Имя,Ресурс.Синоним);
			
		КонецЦикла;
		
	Иначе
		
		ДанныеРесурсов=Результат.Выбрать();
		
		Пока ДанныеРесурсов.Следующий() Цикл
			
			ЭлементРесурс.СписокВыбора.Добавить(ДанныеРесурсов.Имя,ДанныеРесурсов.Синоним);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если НЕ ЭлементРесурс.СписокВыбора.НайтиПоЗначению(ТекЗначениеРесурса)=Неопределено Тогда
		
		РеквизитРесурс=ТекЗначениеРесурса;
		
	Иначе
		
		РеквизитРесурс=ЭлементРесурс.СписокВыбора[0].Значение;
		
	КонецЕсли;
		
КонецПроцедуры // ПолучитьСписокРесурсовРегистра() 

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С ОТЧЕТАМИ.
//

Функция ЗаполнитьПользовательскиеНастройкиОтчета(ИмяОтчета, ПараметрыПользователя, ИмяВарианта="") Экспорт	
	
	ОтчетОбъект = Отчеты[ИмяОтчета].Создать();
	КомпоновщикНастроек = ОтчетОбъект.КомпоновщикНастроек;
	
	Если ПустаяСтрока(ИмяВарианта) Тогда
		Настройки = КомпоновщикНастроек.ПолучитьНастройки();
		
	Иначе
		Варианты=ОтчетОбъект.СхемаКомпоновкиДанных.ВариантыНастроек;
		НайденныйВариант=Варианты.Найти(ИмяВарианта);
		Если НайденныйВариант = Неопределено Тогда
			Настройки = КомпоновщикНастроек.ПолучитьНастройки();
		Иначе
			Настройки=НайденныйВариант.Настройки;
		КонецЕсли;
		
	КонецЕсли; 
	
	Для каждого ПараметрПользователя Из ПараметрыПользователя Цикл
		Настройки.ПараметрыДанных.УстановитьЗначениеПараметра(ПараметрПользователя.Ключ, ПараметрПользователя.Значение);
	КонецЦикла;
	
	КомпоновщикНастроек.ЗагрузитьНастройки(Настройки);
	
	Возврат КомпоновщикНастроек.ПользовательскиеНастройки;
	
КонецФункции

// Возвращает тип по ссылкам на справочники, описывающие метаданные (Справочник БД, Документы БД и др.).
Функция ВернутьТипПоСсылкеБД(ИсходнаяСсылка) Экспорт
	РезультатФункции = Неопределено;
	Если ИсходнаяСсылка <> Неопределено Тогда
		НаименованиеСсылки = ИсходнаяСсылка.Наименование;
		Если ТипЗнч(ИсходнаяСсылка) = Тип("СправочникСсылка.СправочникиБД") Тогда
			РезультатФункции = Тип("СправочникСсылка."+ НаименованиеСсылки);
		ИначеЕсли ТипЗнч(ИсходнаяСсылка) = Тип("СправочникСсылка.ДокументыБД") Тогда	
			РезультатФункции = Тип("ДокументСсылка."+ НаименованиеСсылки);
		ИначеЕсли ТипЗнч(ИсходнаяСсылка) = Тип("СправочникСсылка.ПеречисленияБД") Тогда	
			РезультатФункции = Тип("ПеречислениеСсылка."+ НаименованиеСсылки);
		ИначеЕсли ТипЗнч(ИсходнаяСсылка) = Тип("СправочникСсылка.ПланыВидовХарактеристикБД") Тогда	
			РезультатФункции = Тип("ПланыВидовХарактеристикМенеджер."+ НаименованиеСсылки);
		ИначеЕсли ТипЗнч(ИсходнаяСсылка) = Тип("СправочникСсылка.ПланыСчетовБД") Тогда	
			РезультатФункции = Тип("ПланыСчетовМенеджер."+ НаименованиеСсылки);
		ИначеЕсли ТипЗнч(ИсходнаяСсылка) = Тип("СправочникСсылка.РегистрыБухгалтерииБД") Тогда	
			РезультатФункции = Тип("РегистрБухгалтерииМенеджер."+ НаименованиеСсылки);
		ИначеЕсли ТипЗнч(ИсходнаяСсылка) = Тип("СправочникСсылка.РегистрыНакопленияБД") Тогда	
			РезультатФункции = Тип("РегистрыНакопленияМенеджер."+ НаименованиеСсылки);
		ИначеЕсли ТипЗнч(ИсходнаяСсылка) = Тип("СправочникСсылка.РегистрыСведенийБД") Тогда	
			РезультатФункции = Тип("РегистрыСведенийМенеджер."+ НаименованиеСсылки);
		Иначе
			РезультатФункции = Неопределено;	// Неизвестный вариант.
		КонецЕсли;	
	Иначе
		РезультатФункции = Неопределено;		// Исходная ссылка не определена.
	КонецЕсли;
	Возврат РезультатФункции;
КонецФункции

// Функция возвращает ссылку на описание объекта метаданных по его типу
//
// Параметры:
//  ТипВход	 - 	Тип - Тип объекта, для которого требуется получить описание
// 
// Возвращаемое значение:
//  СправочникСсылка.СправочникиБД, СправочникСсылка.ДокументыБД, СправочникСсылка.ПеречисленияБД,
//	СправочникСсылка.ПланыВидовХарактеристикБД, СправочникСсылка.ПланыСчетовБД - ссылка на описание объекта метаданных..
//
Функция ВернутьСсылкуБДПоТипу(ТипВход) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипВход);
	
	МенеджерОбъектаБД = Неопределено;
	Если ОбщегоНазначения.ЭтоСправочник(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.СправочникиБД;	
	ИначеЕсли ОбщегоНазначения.ЭтоДокумент(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.ДокументыБД;
	ИначеЕсли ОбщегоНазначения.ЭтоПеречисление(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.ПеречисленияБД;
	ИначеЕсли ОбщегоНазначения.ЭтоПланВидовХарактеристик(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.ПланыВидовХарактеристикБД;
	ИначеЕсли ОбщегоНазначения.ЭтоПланСчетов(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.ПланыСчетовБД;
	КонецЕсли;
	
	Если МенеджерОбъектаБД = Неопределено Тогда
		РезультатФункции = Неопределено;
	Иначе
		РезультатФункции = МенеджерОбъектаБД.НайтиПоНаименованию(ОбъектМетаданных.Имя,Истина,, Справочники.ТипыБазДанных.ТекущаяИБ);
	КонецЕсли;
	Возврат РезультатФункции;
	
КонецФункции

Функция ВернутьСсылкуБДПоОбъектуМетаданных(ОбъектМетаданных) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерОбъектаБД = Неопределено;
	Если ОбщегоНазначения.ЭтоСправочник(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.СправочникиБД;	
	ИначеЕсли ОбщегоНазначения.ЭтоДокумент(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.ДокументыБД;
	ИначеЕсли ОбщегоНазначения.ЭтоПеречисление(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.ПеречисленияБД;
	ИначеЕсли ОбщегоНазначения.ЭтоПланВидовХарактеристик(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.ПланыВидовХарактеристикБД;
	ИначеЕсли ОбщегоНазначения.ЭтоПланСчетов(ОбъектМетаданных) Тогда
		МенеджерОбъектаБД = Справочники.ПланыСчетовБД;
	КонецЕсли;
	
	Если МенеджерОбъектаБД = Неопределено Тогда
		РезультатФункции = Неопределено;
	Иначе
		РезультатФункции = МенеджерОбъектаБД.НайтиПоНаименованию(ОбъектМетаданных.Имя,Истина,, Справочники.ТипыБазДанных.ТекущаяИБ);
	КонецЕсли;
	
	Возврат РезультатФункции;
	
КонецФункции

Функция ВернутьСсылкуБДПоПолномуИмени(ПолноеИмя) Экспорт
	
	КлассОбъектаМетаданных = "";
	ИмяОбъектаМетаданных = "";
	
	ЧастиИмени = СтрРазделить(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() >= 2 Тогда
		КлассОбъектаМетаданных = ВРЕГ(ЧастиИмени[0]);
		ИмяОбъектаМетаданных  = ЧастиИмени[1];
	Иначе
		ШаблонТекстаОшибки = НСтр("ru = '""%1"" не является корректным полным именем объекта метаданных'");
		ВызватьИсключение СтрШаблон(ШаблонТекстаОшибки, ПолноеИмя);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерОбъектаБД = Неопределено;
	Если КлассОбъектаМетаданных = "СПРАВОЧНИК" Тогда
		МенеджерОбъектаБД = Справочники.СправочникиБД;	
	ИначеЕсли КлассОбъектаМетаданных = "ДОКУМЕНТ" Тогда
		МенеджерОбъектаБД = Справочники.ДокументыБД;
	ИначеЕсли КлассОбъектаМетаданных = "ПЕРЕЧИСЛЕНИЕ" Тогда
		МенеджерОбъектаБД = Справочники.ПеречисленияБД;
	ИначеЕсли КлассОбъектаМетаданных = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		МенеджерОбъектаБД = Справочники.ПланыВидовХарактеристикБД;
	ИначеЕсли КлассОбъектаМетаданных = "ПЛАНСЧЕТОВ" Тогда
		МенеджерОбъектаБД = Справочники.ПланыСчетовБД;
	КонецЕсли;
	
	Если МенеджерОбъектаБД = Неопределено Тогда
		РезультатФункции = Неопределено;
	Иначе
		РезультатФункции = МенеджерОбъектаБД.НайтиПоНаименованию(ИмяОбъектаМетаданных,Истина,, Справочники.ТипыБазДанных.ТекущаяИБ);
	КонецЕсли;
	
	Возврат РезультатФункции;
	
	
КонецФункции

// По дереву значений ДеревоВход формирует пустую таблицу значений,
// с колонками, совпадающими с колонками дерева.
Функция СформироватьПустуюТаблицуПоДереву(ДеревоВход) Экспорт
	РезультатФункции = Новый ТаблицаЗначений;
	Для Каждого ТекКолонки Из ДеревоВход.Колонки Цикл
		РезультатФункции.Колонки.Добавить(ТекКолонки.Имя, ТекКолонки.ТипЗначения, ТекКолонки.Заголовок, ТекКолонки.Ширина);
	КонецЦикла;
	Возврат РезультатФункции;
КонецФункции		// СформироватьПустуюТаблицуПоДереву()

// Рекурсивно добавлет в таблицу значений НоваяТаблица строки из дерева ДеревоВход.
// Параметр ГлубинаРекурсииВход защищает от бесконечной рекурсии.
Процедура ДобавитьСтрокиДереваВТаблицу(ДеревоВход, НоваяТаблица, ГлубинаРекурсииВход = 0)
	Если ГлубинаРекурсииВход > 999999 Тогда
		Возврат;
	КонецЕсли;
	Для Каждого ТекСтроки Из ДеревоВход.Строки Цикл
		НоваяСтрокаТаблицы = НоваяТаблица.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрокаТаблицы, ТекСтроки);
		ДобавитьСтрокиДереваВТаблицу(ТекСтроки, НоваяТаблица, ГлубинаРекурсииВход + 1);
	КонецЦикла;
КонецПроцедуры		// ДобавитьСтрокиДереваВТаблицу()

// Возвращает плоскую таблицу значений, полученную из дерева значений ДеревоВход.
Функция ПреобразоватьДеревоЗначенийВТаблицу(ДеревоВход) Экспорт
	РезультатФункции = СформироватьПустуюТаблицуПоДереву(ДеревоВход);
	ДобавитьСтрокиДереваВТаблицу(ДеревоВход, РезультатФункции);
	Возврат РезультатФункции;
КонецФункции		// ПреобразоватьДеревоЗначенийВТаблицу()

// Формирует соответствие из таблицы значений ТаблицаВход по колонке-ключу ИмяКолонкиКлючаВход
// и колонке-значению ИмяКолонкиЗначенияВход.
Функция ПреобразоватьТаблицуЗначенийВСоответствие(ТаблицаВход, ИмяКолонкиКлючаВход, ИмяКолонкиЗначенияВход) Экспорт
	РезультатФункции = Новый Соответствие;
	Если ТипЗнч(ТаблицаВход) = Тип("ТаблицаЗначений") Тогда
		КолонкиТаблицы = ТаблицаВход.Колонки;
		КолонкаКлюч		 = КолонкиТаблицы.Найти(ИмяКолонкиКлючаВход);
		КолонкаЗначение	 = КолонкиТаблицы.Найти(ИмяКолонкиЗначенияВход);
		Если (КолонкаКлюч <> Неопределено) Тогда
			Если (КолонкаЗначение <> Неопределено) Тогда
				ТаблицаСвертка = ТаблицаВход.Скопировать();
				СтрокаСвертка = ИмяКолонкиКлючаВход + "," + ИмяКолонкиЗначенияВход;
				ТаблицаСвертка.Свернуть(СтрокаСвертка);
				Для Каждого ТекТаблицаСвертка Из ТаблицаСвертка Цикл
					ТекКлюч		 = ТекТаблицаСвертка[ИмяКолонкиКлючаВход];
					ТекЗначение	 = ТекТаблицаСвертка[ИмяКолонкиЗначенияВход];
					РезультатФункции.Вставить(ТекКлюч, ТекЗначение);
				КонецЦикла;
			Иначе
				ТекстСообщения = НСтр("ru = 'Колонка значения не найдена: %ИмяКолонкиЗначения%'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ИмяКолонкиЗначения%", Строка(ИмяКолонкиЗначенияВход));
				ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
				РезультатФункции = Новый Соответствие;
			КонецЕсли;
		Иначе
			ТекстСообщения = НСтр("ru = 'Колонка ключа не найдена: %ИмяКолонкиКлюча%'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ИмяКолонкиКлюча%", Строка(ИмяКолонкиКлючаВход));
			ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
			РезультатФункции = Новый Соответствие;
		КонецЕсли;
	Иначе
		ТекстСообщения = НСтр("ru = 'Неизвестный вариант таблицы: %Таблица%'");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Таблица%", Строка(ТаблицаВход));
		ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
		РезультатФункции = Новый Соответствие;
	КонецЕсли;
	Возврат РезультатФункции;
КонецФункции		// ПреобразоватьТаблицуЗначенийВСоответствие()

// Возвращает копию массива ИсходныйМассивВход, в которую добавлены
// имена колонок из табличной части ТаблицаВход.
Функция ДобавитьВМассивКолонкиТаблицы(ИсходныйМассивВход, ТаблицаВход) Экспорт
	РезультатФункции = Новый Массив;
	Для Каждого ИсходныйМассивВход Из ИсходныйМассивВход Цикл
		РезультатФункции.Добавить(ИсходныйМассивВход);
	КонецЦикла;
	Для Каждого ТекКолонки Из ТаблицаВход.Колонки Цикл
		Если РезультатФункции.Найти(ТекКолонки.Имя) = Неопределено Тогда
			РезультатФункции.Добавить(ТекКолонки.Имя); 
		Иначе
			Продолжить;			// Такая колонка уже есть в массиве. Не добавляем её.
		КонецЕсли;
	КонецЦикла;
	Возврат РезультатФункции;
КонецФункции

// Возвращает наиболее подходящий бланк для открытия сводной таблицы
// по виду отчета ВидОтчетаВход.
Функция ПолучитьБланкДляОткрытияСводнойТаблицы(ВидОтчетаВход) Экспорт
	ПустойБланк = Справочники.БланкиОтчетов.ПустаяСсылка();
	РезультатФункции = ПустойБланк;
	// Получим бланк сводной таблицы по умолчанию.
	БланкОтчетаПоУмолчанию = ПолучитьБланкСводнойТаблицыПоУмолчанию(ВидОтчетаВход);
	Если ЗначениеЗаполнено(БланкОтчетаПоУмолчанию) Тогда
		РезультатФункции = БланкОтчетаПоУмолчанию;
	Иначе
		// Не удалось получить бланк по умолчанию. Получим список всех бланков, если в нём один бланк - воспользуемся им.
		МассивБланков = ПолучитьМассивБланковСводнойТаблицы(ВидОтчетаВход);
		Если МассивБланков.Количество() = 1 Тогда
			РезультатФункции = МассивБланков[0];
		Иначе
			РезультатФункции = ПустойБланк;
		КонецЕсли;
	КонецЕсли;
	Возврат РезультатФункции;
КонецФункции

// Возвращает уникальную отметку времени по ссылке СсылкаВход.
// Сдвигает дату в случае повтора.
Функция ПолучитьОтметкуПоОбъекту(СсылкаВход = Неопределено) Экспорт
	ТекДата = ТекущаяДатаСеанса();
	РезультатФункции = ТекДата;
	ФиксСоответствие = ПараметрыСеанса.СоответствиеДатОбъектов;
	ЗначениеДаты = ФиксСоответствие.Получить(СсылкаВход);
	Если ЗначениеДаты = Неопределено Тогда
		РезультатФункции = ТекДата;
	Иначе
		Если ЗначениеДаты >= РезультатФункции Тогда
			РезультатФункции = ЗначениеДаты + 1;
		Иначе
			РезультатФункции = ТекДата;
		КонецЕсли;
	КонецЕсли;
	ЗаписатьДатуПоОбъекту(РезультатФункции, СсылкаВход, ФиксСоответствие);
	Возврат РезультатФункции;
КонецФункции
	
// Сравнивает ПериодичностьВход1 и ПериодичностьВход2. Возвращает
// Истину, если ПериодичностьВход1 больше. Когда параметр ВключаяРавенствоВход
// Истинный, также вернёт Истину при равенстве периодичностей.
Функция СравнитьПериодичность(ПериодичностьВход1, ПериодичностьВход2, ВключаяРавенствоВход = Ложь) Экспорт
	РезультатФункции = Истина;
	Если (ВключаяРавенствоВход) И (ПериодичностьВход1 = ПериодичностьВход2) Тогда
		РезультатФункции = Истина;
	Иначе
		Если ЗначениеЗаполнено(ПериодичностьВход1) Тогда
			ИндексПериодичности1 = Перечисления.Периодичность.Индекс(ПериодичностьВход1);
		Иначе
			ИндексПериодичности1 = 999;
		КонецЕсли;
		Если ЗначениеЗаполнено(ПериодичностьВход2) Тогда
			ИндексПериодичности2 = Перечисления.Периодичность.Индекс(ПериодичностьВход2);
		Иначе
			ИндексПериодичности2 = 999;
		КонецЕсли;
		РезультатФункции = ИндексПериодичности1 > ИндексПериодичности2;
	КонецЕсли;
	Возврат РезультатФункции;
КонецФункции

// Возвращает организацию объекта базы данных СсылкаВход,
// из реквизита, указанном в справочнике ДокументыБД/СправочникиБД.
Функция ПолучитьОрганизациюОбъекта(СсылкаВход) Экспорт
	РезультатФункции = Справочники.Организации.ПустаяСсылка();
	Попытка
		ТипСсылки = ТипЗнч(СсылкаВход);
		ЭтоСправочник = Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки);
		ЭтоДокумент = Документы.ТипВсеСсылки().СодержитТип(ТипСсылки);
		Если ЭтоСправочник ИЛИ ЭтоДокумент Тогда
			СсылкаСправочникБД = ОбщегоНазначенияСерверУХ.ВернутьСсылкуБДПоТипу(ТипСсылки);
			Если СсылкаСправочникБД <> Неопределено Тогда
				Если ЗначениеЗаполнено(СсылкаСправочникБД.РеквизитРазделенияПоОрганизациям) Тогда
					РезультатФункции = СсылкаВход[СсылкаСправочникБД.РеквизитРазделенияПоОрганизациям];
				Иначе
					// Реквизит разделения по организации пуст.
					РезультатФункции = Справочники.Организации.ПустаяСсылка();
				КонецЕсли;
			Иначе
				// Определить справочник БД не удалось.
				РезультатФункции = Справочники.Организации.ПустаяСсылка();
			КонецЕсли;
		Иначе
			// У прочих объектов нет реквизита для определения организации.
			РезультатФункции = Справочники.Организации.ПустаяСсылка();
		КонецЕсли;
	Исключение
		ТекстСообщения = НСтр("ru = 'Произошла ошибка при определении организации для объекта %Ссылка% : %ОписаниеОшибки%'");
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Ссылка%", Строка(СсылкаВход));
		ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ОписаниеОшибки%", ОписаниеОшибки());
		ОбщегоНазначенияУХ.СообщитьОбОшибке(ТекстСообщения);
		РезультатФункции = Справочники.Организации.ПустаяСсылка();
	КонецПопытки;
	Возврат РезультатФункции;
КонецФункции		// ПолучитьОрганизациюОбъекта()

Функция ЗаполнитьОтборНаРавенство(Отбор, Параметры) Экспорт
	
	Для каждого ЭлементОтбора Из Отбор Цикл
		Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Параметры, ЭлементОтбора.Имя) Тогда
			ЭлементОтбора.Установить(Параметры[ЭлементОтбора.Имя]);
		КонецЕсли;
	КонецЦикла;
	
КонецФункции	

Функция ЗаписатьЗаписьРегистра(Менеджер, СтарыеПараметрыЗаписи, НовыеПараметрыЗаписи = Неопределено) Экспорт
	
	Набор = Менеджер.СоздатьНаборЗаписей();
	ОбщегоНазначенияСерверУХ.ЗаполнитьОтборНаРавенство(Набор.Отбор, СтарыеПараметрыЗаписи);
	СтрокаНабора = Набор.Добавить();
	ЗаполнитьЗначенияСвойств(СтрокаНабора, СтарыеПараметрыЗаписи);
	Если НовыеПараметрыЗаписи <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(СтрокаНабора, НовыеПараметрыЗаписи);
	КонецЕсли;	
	Набор.Записать();
	
КонецФункции	

// Возвращает валюту управленческого учета
// Если переданная в качестве параметра валюта уже заполнена - возвращает ее.
// Если валюта не передана в качестве параметра или передан пустой,
// валюту упр. учета. Если валюта упр. учета не заполнена - возвращает пустую ссылку на валюту
//
// Параметры:
// Валюта - СправочникСсылка.Валюты - Валюта, которую нужно заполнить
//
// Возвращаемое значение:
// СправочникСсылка.Валюты
//
Функция ПолучитьВалютуУправленческогоУчета(Знач Валюта = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(Валюта) Тогда
		Возврат Константы.ВалютаУправленческогоУчета.Получить();
	Иначе
		Возврат Валюта;
	КонецЕсли;
	
КонецФункции

// Возвращает валюту регламентированного учета
// Если переданная в качестве параметра валюта уже заполнена - возвращает ее.
// Если валюта не передана в качестве параметра или передан пустой,
// валюту регл. учета. Если валюта регл. учета не заполнена - возвращает пустую ссылку на валюту
//
// Параметры:
// Валюта - СправочникСсылка.Валюты - Валюта, которую нужно заполнить
//
// Возвращаемое значение:
// СправочникСсылка.Валюты
//
Функция ПолучитьВалютуРегламентированногоУчета(Знач Валюта = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(Валюта) Тогда
		Возврат Константы.ВалютаРегламентированногоУчета.Получить();
	Иначе
		Возврат Валюта;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьСреднийКурсЗаПериодЦБ(КурсыПоМесяцам, Период)
	
	//Источник: http://www.cbr.ru/statistics/credit_statistics/metod_ex_rate.pdf
	//средний курс по методике ЦБ рассчитываются по формуле:	
	//Среднемесячный: Mi = POW(D1*...*Dm,1/m), где m - количество дней в месяце, Di - курс на дату	
	//Среднеквартальный и годовой: СреднийКурсЗаПериодЦБ = POW(M1*...*Mn,1/n), где n - количество месяцев, Мi - среднемесячный курс	
	//для увеличения точности преобразуем формулу( POW(POW(A*B,C)*POW(D*E,F),G) = POW(A*B,C*G)*POW(D*E,F*G) ):
	//СреднийКурсЗаПериодЦБ = POW(D1*...*Dm1, 1/(n*m1)) * ... * POW(D1*...*Dmn, 1/n*mn)
	//где "n*mi" - ТекущаяСтепень(в коде)
	//так как величина D1*...*Dmi - может быть очень большой(или очень маленькой), возможна потеря точности.
	//Чтобы избежать этого, разобъем произведение курсов на группы(в коде ПроизведениеКурсов) 
	//и каждое произведение возведем в степень(т.к.: POW(A*B,C)=POW(B,C)*POW(A,C) )
	
	ЧислоМесяцевПериода = (Год(Период.ДатаОкончания) - Год(Период.ДатаНачала)) * 12 + (Месяц(Период.ДатаОкончания) - Месяц(Период.ДатаНачала)) + 1;
		
	СреднийКурсЗаПериодЦБ = 1;
	Для каждого ТекущиеКурсыМесяца Из КурсыПоМесяцам Цикл			
		ТекущаяСтепень = ЧислоМесяцевПериода * ТекущиеКурсыМесяца.Значение.ЧислоДней;
		Для каждого ТекущееПроизвдениеКурсов Из ТекущиеКурсыМесяца.Значение.ПроизведениеКурсов Цикл			
			СреднийКурсЗаПериодЦБ = СреднийКурсЗаПериодЦБ * Pow(ТекущееПроизвдениеКурсов, 1 / ТекущаяСтепень);
		КонецЦикла;		
	КонецЦикла;
	
	Возврат СреднийКурсЗаПериодЦБ;

КонецФункции

// Возвращает бланк отчета сводной таблицы по умолчанию для 
// вида отчета ВидОтчетаВход.
Функция ПолучитьБланкСводнойТаблицыПоУмолчанию(ВидОтчетаВход)
	Перем БланкОтображенияПоУмолчанию;
	Перем БланкДляИмпортаПоУмолчанию;
	Перем ПравилоОбработкиПоУмолчанию;
	Перем ПравилоПроверкиПоУмолчанию;
	Перем БланкСводнойТаблицыПоУмолчанию;
	РезультатФункции = Справочники.БланкиОтчетов.ПустаяСсылка();
	Справочники.ВидыОтчетов.ПолучитьНастройкиПоУмолчанию(ВидОтчетаВход, БланкОтображенияПоУмолчанию, БланкДляИмпортаПоУмолчанию, ПравилоОбработкиПоУмолчанию, ПравилоПроверкиПоУмолчанию, БланкСводнойТаблицыПоУмолчанию);
	РезультатФункции = БланкСводнойТаблицыПоУмолчанию;
	Возврат РезультатФункции;
КонецФункции

// Возвращает массив бланков отчетов сводной таблицы для вида отчета ВидОтчетаВход.
Функция ПолучитьМассивБланковСводнойТаблицы(ВидОтчетаВход)
	РезультатФункции = Новый Массив;
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
		|	БланкиОтчетов.Ссылка
		|ИЗ
		|	Справочник.БланкиОтчетов КАК БланкиОтчетов
		|ГДЕ
		|	НЕ БланкиОтчетов.ПометкаУдаления
		|	И БланкиОтчетов.Владелец = &ВидОтчета
		|	И БланкиОтчетов.РежимБланка = 1";
	
	Запрос.УстановитьПараметр("ВидОтчета", ВидОтчетаВход);
	РезультатЗапроса = Запрос.Выполнить();
	Выгрузка = РезультатЗапроса.Выгрузить();
	РезультатФункции = Выгрузка.ВыгрузитьКолонку("Ссылка");
	
	Возврат РезультатФункции;	
	
КонецФункции

Функция ОпределитьОтносительнуюДату(ДатаНачала, Периодичность, Смещение)
	
	Если Периодичность		= Перечисления.Периодичность.Год 
	 ИЛИ Периодичность      = Перечисления.Периодичность.ДевятьМесяцев Тогда
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(ДатаНачала, 12 * Смещение);
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(ДатаНачала, 6 * Смещение);
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(ДатаНачала, 3 * Смещение);
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(ДатаНачала, Смещение);
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		
		// анализируем
		ГодДатыНачала						= Год(ДатаНачала);
		МесяцДатыНачала						= Месяц(ДатаНачала);
		ДеньДатыНачала						= День(ДатаНачала);
		ДекадаДатыНачала					= Цел((ДеньДатыНачала - 1) / 10) + 1;
		ДекадаДатыНачала					= ?(ДекадаДатыНачала = 4, 3, ДекадаДатыНачала);
		НомерДекадыНЭ						= ГодДатыНачала * 36 + (МесяцДатыНачала - 1) * 3 + (ДекадаДатыНачала - 1);
		
		// изменяем
		НомерДекадыНЭ						= НомерДекадыНЭ + Смещение;
		
		// синтезируем
		ГодДатыНачалаОтнПериода				= Цел((НомерДекадыНЭ)/ 36);
		ДекадаВГоду							= НомерДекадыНЭ % 36;
		МесяцВГодуДатыНачалаОтнПериода		= Цел(ДекадаВГоду / 3) + 1;
		ДекадаВМесяце						= ДекадаВГоду % 3;
		ДеньВМесяцеДатыНачалаОтнПериода		= ДекадаВМесяце * 10 + 1;
		
		ДатаНачалаОтносительногоПериода		= Дата(ГодДатыНачалаОтнПериода, МесяцВГодуДатыНачалаОтнПериода, ДеньВМесяцеДатыНачалаОтнПериода);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		ОдинДень							= НачалоДня(Дата(2000, 1, 2)) - НачалоДня(Дата(2000, 1, 1));
		ДатаНачалаОтносительногоПериода		= ДатаНачала + ОдинДень * Смещение;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ДатаНачалаОтносительногоПериода;
	
КонецФункции

// Записывает в параметр сеанса СоответствиеДатОбъектов дату ДатаВход
// по объекту СсылкаВход, добавляя данные в соответствие СоответствиеВход.
Процедура ЗаписатьДатуПоОбъекту(ДатаВход, СсылкаВход, СоответствиеВход)
	НовоеСоответствие = Новый Соответствие(СоответствиеВход);
	НовоеСоответствие.Вставить(СсылкаВход, ДатаВход);
	НовоеФиксСоответствие = Новый ФиксированноеСоответствие(НовоеСоответствие);
	ПараметрыСеанса.СоответствиеДатОбъектов = НовоеФиксСоответствие;
КонецПроцедуры

// Рассчитывает следующий момент запуска задания.
//
// Параметры:
// Расписание                  - РасписаниеРегламентногоЗадания - расписание,
//                               для которого требуется рассчитать момент следующего запуска.
// ЧасовойПояс				   - Строка - часовой пояс.
// ДатаНачалаПоследнегоЗапуска - Дата - Дата начала последнего запуска регламентного задания.
//                               Если дата задана, то используется для проверки таких условий как.
//                               ПериодПовтораДней, ПериодНедель, ПериодПовтораВТечениеДня.
//                               Если дата не задана, то считается,
//                               что задание не выполнялось ни разу и проверка этих условий не производится.
//
// Возвращаемое значение:
//   Дата - рассчитанный следующий момент запуска задания.
//
Функция ПолучитьЗапланированныйМоментЗапускаЗадания(Знач Расписание, Знач ЧасовойПояс, 
		Знач ДатаНачалаПоследнегоЗапуска = '00010101', Знач ДатаЗавершенияПоследнегоЗапуска = '00010101') Экспорт
	
	Если ПустаяСтрока(ЧасовойПояс) Тогда
		ЧасовойПояс = Неопределено;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДатаНачалаПоследнегоЗапуска) Тогда 
		ДатаНачалаПоследнегоЗапуска = МестноеВремя(ДатаНачалаПоследнегоЗапуска, ЧасовойПояс);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДатаЗавершенияПоследнегоЗапуска) Тогда
		ДатаЗавершенияПоследнегоЗапуска = МестноеВремя(ДатаЗавершенияПоследнегоЗапуска, ЧасовойПояс);
	КонецЕсли;
	
	ДатаРасчета = МестноеВремя(ТекущаяУниверсальнаяДата(), ЧасовойПояс);
	
	НайденнаяДата = СледующаяДатаВыполненияРасписания(Расписание, ДатаРасчета, ДатаНачалаПоследнегоЗапуска, ДатаЗавершенияПоследнегоЗапуска);
	
	Если ЗначениеЗаполнено(НайденнаяДата) Тогда
		Возврат УниверсальноеВремя(НайденнаяДата, ЧасовойПояс);
	Иначе
		Возврат НайденнаяДата;
	КонецЕсли;
	
КонецФункции

// Возвращает следующую дата выполнения расписания.
//
// Параметры:
//  Расписание - РасписаниеРегламентногоЗадания - расписание по которому
//   будет рассчитываться дата.
//  ДатаДляПроверки - Дата - минимальная дата на которую может
//   быть запланировано выполнение.
//  ДатаНачалаПоследнегоЗапуска - Дата - Дата начала последнего 
//   запуска задания. Если дата задана, то используется для проверки таких 
//   условий как ПериодПовтораДней, ПериодНедель, ПериодПовтораВТечениеДня. 
//   Если дата не задана, то считается, что задание не выполнялось ни разу 
//   и проверка этих условий не производится. 
//  ДатаЗавершенияПоследнегоЗапуска - Дата - Дата завершения 
//   последнего запуска задания. Если дата задана, то используется для 
//   проверки условия ПаузаПовтора. Если дата не задана, то считается, что 
//   задание ни разу не завершалось, и проверка этого условия не производится. 
//  МаксимальныйГоризонтПланирования - Число - Максимальное количество секунд
//   относительно ДатаДляПроверки на которое может быть выполнено планирование.
//   Увеличение значения может привести к замедлению расчета на сложных
//   расписаниях.
//
// Возвращаемое значение: 
//  Дата - следующая дата выполнения расписания.
//
Функция СледующаяДатаВыполненияРасписания(Знач Расписание, Знач ДатаДляПроверки, 
	Знач ДатаНачалаПоследнегоЗапуска = Неопределено, Знач ДатаЗавершенияПоследнегоЗапуска = Неопределено, 
	Знач МаксимальныйГоризонтПланирования = Неопределено)
	
	Если МаксимальныйГоризонтПланирования = Неопределено Тогда
		МаксимальныйГоризонтПланирования = 366 * 86400 * 10;
	КонецЕсли;
	
	ИсходнаяДатаДляПроверки = ДатаДляПроверки;
	ВремяНачалаПоследнегоЗапуска = '00010101' + (ДатаНачалаПоследнегоЗапуска - НачалоДня(ДатаНачалаПоследнегоЗапуска));
	
	// Границы по датам
	Если ЗначениеЗаполнено(Расписание.ДатаКонца)
		И ДатаДляПроверки > Расписание.ДатаКонца Тогда
		
		// Интервал выполнения по дням закончился.
		Возврат '00010101';
	КонецЕсли;
		
	Если ДатаДляПроверки < Расписание.ДатаНачала Тогда
		ДатаДляПроверки = Расписание.ДатаНачала;
	КонецЕсли;
	
	МожноМенятьДень = Истина;
	
	// Учет периодичности
	Если ЗначениеЗаполнено(ДатаНачалаПоследнегоЗапуска) Тогда
		
		// Период недель
		Если Расписание.ПериодНедель > 1
			И (НачалоНедели(ДатаДляПроверки) - НачалоНедели(ДатаНачалаПоследнегоЗапуска)) / (7 * 86400) < Расписание.ПериодНедель Тогда
		
			ДатаДляПроверки = НачалоНедели(ДатаНачалаПоследнегоЗапуска) + 7 * 86400 * Расписание.ПериодНедель;
		КонецЕсли;
		
		// Период дней
		Если Расписание.ПериодПовтораДней = 0 Тогда
			Если НачалоДня(ДатаДляПроверки) <> НачалоДня(ДатаНачалаПоследнегоЗапуска) Тогда
				// Повторения не установлено и задание уже выполнялось.
				Возврат '00010101';
			КонецЕсли;
			
			МожноМенятьДень = Ложь;
		КонецЕсли;
		
		Если Расписание.ПериодПовтораДней > 1
			И НачалоДня(ДатаДляПроверки) - НачалоДня(ДатаНачалаПоследнегоЗапуска) < (Расписание.ПериодПовтораДней - 1)* 86400 Тогда
			
			ДатаДляПроверки = НачалоДня(ДатаНачалаПоследнегоЗапуска) + Расписание.ПериодПовтораДней * 86400;
		КонецЕсли;
		
		// Если задание повторяется раз в день (но не чаще) то сдвигаем на следующий день после последнего запуска.
		Если Расписание.ПериодПовтораДней = 1 И Расписание.ПериодПовтораВТечениеДня = 0 Тогда
			ДатаДляПроверки = Макс(ДатаДляПроверки, НачалоДня(ДатаНачалаПоследнегоЗапуска+86400));
		КонецЕсли;

	КонецЕсли;
	
	// Учет допустимых интервалов запуска.
	ПоменятьМесяц = Ложь;
	ПоменятьДень = Ложь;
	Пока Истина Цикл
		
		Если ДатаДляПроверки - ИсходнаяДатаДляПроверки > МаксимальныйГоризонтПланирования Тогда
			// Отложить планирование
			Возврат '00010101';
		КонецЕсли;
		
		Если НЕ МожноМенятьДень
			И (ПоменятьДень ИЛИ ПоменятьМесяц) Тогда
			
			// Повторения не установлено и задание уже выполнялось.
			Возврат '00010101';
		КонецЕсли;
		
		// Месяцы
		Пока ПоменятьМесяц
			ИЛИ Расписание.Месяцы.Количество() > 0 
			И Расписание.Месяцы.Найти(Месяц(ДатаДляПроверки)) = Неопределено Цикл
			
			ПоменятьМесяц = Ложь;
			
			// Переход на следующий месяц
			ДатаДляПроверки = НачалоМесяца(ДобавитьМесяц(ДатаДляПроверки, 1));
		КонецЦикла;
		
		// День месяца
		ДнейВМесяце = День(КонецМесяца(ДатаДляПроверки));
		Если Расписание.ДеньВМесяце <> 0 Тогда
			
			ТекущийДень = День(ДатаДляПроверки);
			
			Если Расписание.ДеньВМесяце > 0 
				И (ДнейВМесяце < Расписание.ДеньВМесяце ИЛИ ТекущийДень > Расписание.ДеньВМесяце)
				ИЛИ Расписание.ДеньВМесяце < 0 
				И (ДнейВМесяце < -Расписание.ДеньВМесяце ИЛИ ТекущийДень > ДнейВМесяце - -Расписание.ДеньВМесяце) Тогда
				
				// В этом месяце нет такого числа или оно уже прошло.
				ПоменятьМесяц = Истина;
				Продолжить;
			КонецЕсли;
			
			Если Расписание.ДеньВМесяце > 0 Тогда
				ДатаДляПроверки = НачалоМесяца(ДатаДляПроверки) + (Расписание.ДеньВМесяце - 1) * 86400;
			КонецЕсли;
			
			Если Расписание.ДеньВМесяце < 0 Тогда
				ДатаДляПроверки = НачалоДня(КонецМесяца(ДатаДляПроверки)) - (-Расписание.ДеньВМесяце -1) * 86400;
			КонецЕсли;
		КонецЕсли;
		
		// День недели в месяце
		Если Расписание.ДеньНеделиВМесяце <> 0 Тогда
			Если Расписание.ДеньНеделиВМесяце > 0 Тогда
				ДеньНачалаНедели = (Расписание.ДеньНеделиВМесяце - 1) * 7 + 1;
			КонецЕсли;
			Если Расписание.ДеньНеделиВМесяце < 0 Тогда
				ДеньНачалаНедели = ДнейВМесяце - (-Расписание.ДеньНеделиВМесяце) * 7 + 1;
			КонецЕсли;
			
			ДеньКонцаНедели = Мин(ДеньНачалаНедели + 6, ДнейВМесяце);
			
			Если День(ДатаДляПроверки) > ДеньКонцаНедели 
				ИЛИ ДеньНачалаНедели > ДнейВМесяце Тогда
				// В этом месяце нужная неделя уже прошла (или ее не было).
				ПоменятьМесяц = Истина;
				Продолжить;
			КонецЕсли;
			
			Если День(ДатаДляПроверки) < ДеньНачалаНедели Тогда
				Если Расписание.ДеньВМесяце <> 0 Тогда
					
					// День зафиксирован и он не подходит.
					ПоменятьМесяц = Истина;
					Продолжить;
				КонецЕсли;
				ДатаДляПроверки = НачалоМесяца(ДатаДляПроверки) + (ДеньНачалаНедели - 1) * 86400;
			КонецЕсли;
		КонецЕсли;
		
		// День недели
		Пока ПоменятьДень
			ИЛИ Расписание.ДниНедели.Найти(ДеньНедели(ДатаДляПроверки)) = Неопределено
			И Расписание.ДниНедели.Количество() > 0 Цикл
			
			ПоменятьДень = Ложь;
			
			Если Расписание.ДеньВМесяце <> 0 Тогда
				// День зафиксирован и он не подходит.
				ПоменятьМесяц = Истина;
				Прервать;
			КонецЕсли;
			
			Если День(ДатаДляПроверки) = ДнейВМесяце Тогда
				// Месяц кончился
				ПоменятьМесяц = Истина;
				Прервать;
			КонецЕсли;
			
			Если Расписание.ДеньНеделиВМесяце <> 0
				И День(ДатаДляПроверки) = ДеньКонцаНедели Тогда
				
				// Нужная неделя кончилась
				ПоменятьМесяц = Истина;
				Прервать;
			КонецЕсли;
			
			ДатаДляПроверки = НачалоДня(ДатаДляПроверки) + 86400;
		КонецЦикла;
		Если ПоменятьМесяц Тогда
			Продолжить;
		КонецЕсли;
		
		// Учет времени
		ВремяДляПроверки = '00010101' + (ДатаДляПроверки - НачалоДня(ДатаДляПроверки));
		
		Если Расписание.ДетальныеРасписанияДня.Количество() = 0 Тогда
			ДетальныеРасписания = Новый Массив;
			ДетальныеРасписания.Добавить(Расписание);


		Иначе
			ДетальныеРасписания = Расписание.ДетальныеРасписанияДня;


		КонецЕсли;
		
		// Если у нас есть промежутки, с переходом через полночь, то разбиваем их на два промежутка.
		Индекс = 0;
		Пока Индекс < ДетальныеРасписания.Количество() Цикл
			
			РасписаниеДня = ДетальныеРасписания[Индекс];
			
			Если НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяНачала) ИЛИ НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) Тогда
				Индекс = Индекс + 1;
				Продолжить;
			КонецЕсли;
			
			Если РасписаниеДня.ВремяНачала > РасписаниеДня.ВремяКонца Тогда
				
				РасписаниеДняПерваяПоловина = Новый РасписаниеРегламентногоЗадания();
				ЗаполнитьЗначенияСвойств(РасписаниеДняПерваяПоловина,РасписаниеДня);
				РасписаниеДняПерваяПоловина.ВремяНачала = НачалоДня(РасписаниеДняПерваяПоловина.ВремяНачала);
				ДетальныеРасписания.Добавить(РасписаниеДняПерваяПоловина);
				
				РасписаниеДняВтораяПоловина = Новый РасписаниеРегламентногоЗадания();
				ЗаполнитьЗначенияСвойств(РасписаниеДняВтораяПоловина,РасписаниеДня);
				РасписаниеДняВтораяПоловина.ВремяКонца = КонецДня(РасписаниеДняВтораяПоловина.ВремяНачала);
				ДетальныеРасписания.Добавить(РасписаниеДняВтораяПоловина);
				
				ДетальныеРасписания.Удалить(Индекс);
				
			Иначе
				
				Индекс = Индекс + 1;
				
			КонецЕсли;
		
		КонецЦикла;
		
		Для Индекс = 0 По ДетальныеРасписания.ВГраница() Цикл
			РасписаниеДня = ДетальныеРасписания[Индекс];
			
			// Границы по времени
			Если ЗначениеЗаполнено(РасписаниеДня.ВремяНачала)
				И ВремяДляПроверки < РасписаниеДня.ВремяНачала Тогда
				
				ВремяДляПроверки = РасписаниеДня.ВремяНачала;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(РасписаниеДня.ВремяКонца)
				И ВремяДляПроверки > РасписаниеДня.ВремяКонца Тогда
				
				Если Индекс < ДетальныеРасписания.ВГраница() Тогда
					// Есть еще расписания дня
					Продолжить;
				КонецЕсли;
				
				// В этом дне подходящее время уже прошло.
				ПоменятьДень = Истина;
				Прервать;
			КонецЕсли;
			
			// Период повтора в течении дня.
			Если ЗначениеЗаполнено(ДатаНачалаПоследнегоЗапуска) Тогда
				
				Если РасписаниеДня.ПериодПовтораВТечениеДня = 0
					И НачалоДня(ДатаДляПроверки) = НачалоДня(ДатаНачалаПоследнегоЗапуска)
					И (НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяНачала) 
						ИЛИ ЗначениеЗаполнено(РасписаниеДня.ВремяНачала) И ВремяНачалаПоследнегоЗапуска >= РасписаниеДня.ВремяНачала)
					И (НЕ ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) 
						ИЛИ ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) И ВремяНачалаПоследнегоЗапуска <= РасписаниеДня.ВремяКонца) Тогда
					
					// В этом интервале (расписании дня) задание уже выполнялось и повторы не установлены.
					Если Индекс < ДетальныеРасписания.ВГраница() Тогда
						Продолжить;
					КонецЕсли;
					
					ПоменятьДень = Истина;
					Прервать;
				КонецЕсли;
				
				Если НачалоДня(ДатаДляПроверки) = НачалоДня(ДатаНачалаПоследнегоЗапуска)
					И ВремяДляПроверки - ВремяНачалаПоследнегоЗапуска < РасписаниеДня.ПериодПовтораВТечениеДня Тогда
					
					НовоеВремяДляПроверки = ВремяНачалаПоследнегоЗапуска + РасписаниеДня.ПериодПовтораВТечениеДня;
					
					Если ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) И НовоеВремяДляПроверки > РасписаниеДня.ВремяКонца
						ИЛИ НачалоДня(НовоеВремяДляПроверки) <> НачалоДня(ВремяДляПроверки) Тогда
						
						// Время ушло за интервал
						Если Индекс < ДетальныеРасписания.ВГраница() Тогда
							Продолжить;
						КонецЕсли;
						
						ПоменятьДень = Истина;
						Прервать;
					КонецЕсли;
					
					ВремяДляПроверки = НовоеВремяДляПроверки;
					
				КонецЕсли;
				
			КонецЕсли;
			
			// Пауза
			Если ЗначениеЗаполнено(ДатаЗавершенияПоследнегоЗапуска) 
				И ЗначениеЗаполнено(РасписаниеДня.ПаузаПовтора) Тогда
				
				ВремяЗавершенияПоследнегоЗапуска = '00010101' + (ДатаЗавершенияПоследнегоЗапуска - НачалоДня(ДатаЗавершенияПоследнегоЗапуска));
				
				Если НачалоДня(ДатаДляПроверки) = НачалоДня(ДатаНачалаПоследнегоЗапуска)
					И ВремяДляПроверки - ВремяЗавершенияПоследнегоЗапуска < РасписаниеДня.ПаузаПовтора Тогда
					
					НовоеВремяДляПроверки = ВремяЗавершенияПоследнегоЗапуска + РасписаниеДня.ПаузаПовтора;
					
					Если ЗначениеЗаполнено(РасписаниеДня.ВремяКонца) И НовоеВремяДляПроверки > РасписаниеДня.ВремяКонца
						ИЛИ НачалоДня(НовоеВремяДляПроверки) <> НачалоДня(ВремяДляПроверки) Тогда
						
						// Время ушло за интервал
						Если Индекс < ДетальныеРасписания.ВГраница() Тогда
							Продолжить;
						КонецЕсли;
						
						ПоменятьДень = Истина;
						Прервать;
					КонецЕсли;
					
					ВремяДляПроверки = НовоеВремяДляПроверки;
					
				КонецЕсли;
			КонецЕсли;
			
			// Нашли подходящее время
			Прервать;
			
		КонецЦикла;
		
		Если ПоменятьДень Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Расписание.ВремяЗавершения)
			И ВремяДляПроверки > Расписание.ВремяЗавершения Тогда
			// В этом дне выполнять поздно.
			ПоменятьДень = Истина;
			Продолжить;
		КонецЕсли;
		
		ДатаДляПроверки = НачалоДня(ДатаДляПроверки) + (ВремяДляПроверки - НачалоДня(ВремяДляПроверки));
		
		Возврат ДатаДляПроверки;
		
	КонецЦикла;
	
КонецФункции

#КонецОбласти