
#Область ПрограммныйИнтерфейс

// Сформировать тело сообщения.
// 
// Параметры:
//  СсылкаНаОбъект - Ссылка - ссылка на выгружаемый объект
//  ИДСообщения - Строка - идентификатор сообщения
//  СхемаДанныхСсылка - СправочникСсылка.СП_СхемыДанных, Строка - ссылка на схему данных или пустая строка
// 
// Возвращаемое значение:
//  Строка - тело сообщения
//
Функция СформироватьТелоСообщения(СсылкаНаОбъект, ИДСообщения = "", СхемаДанныхСсылка = "", json = Ложь) Экспорт
	
	// ( 11.04.2022. Лопатин. Добавлен функционал json
	Если json Тогда
		Возврат ПреобразоватьОбъектВjson(СсылкаНаОбъект);
	КонецЕсли;
	// ).
	
	ИмяОбъекта = СсылкаНаОбъект.Метаданные().ПолноеИмя();
	
	Если ЗначениеЗаполнено(СхемаДанныхСсылка) Тогда
		СхемаДанных = СхемаДанныхСсылка.ТекстСхемы;
	Иначе
		ПространствоИмен = СП_СхемыДанных.ПространствоИменПоИмениОбъекта(ИмяОбъекта);
		СхемаДанных = ПолучитьСхемуДанныхПоИмениОбъекта(ИмяОбъекта, ПространствоИмен);
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ИДСообщения) Тогда
		ИДСообщения = XMLСтрока(Новый УникальныйИдентификатор());
	КонецЕсли;
	
	ДанныеСообщения = Новый Структура;
	ДанныеСообщения.Вставить("ПространствоИмен", СП_СхемыДанных.ПространствоИменПоИмениОбъекта(ИмяОбъекта));
	ДанныеСообщения.Вставить("ПолноеИмяОбъекта", ИмяОбъекта);
	ДанныеСообщения.Вставить("ИДСообщения", ИДСообщения);
	
	Если ЗначениеЗаполнено(СхемаДанных) Тогда
		Фабрика       = ПолучитьФабрикуXDTOПоСхеме(СхемаДанных);
		ДанныеОбъекта = ПолучитьСтруктуруДанныхОбъекта(СсылкаНаОбъект, ИмяОбъекта);
		ОбъектXDTO    = ПреобразоватьСтруктуруВОбъектXDTO(Фабрика, ДанныеОбъекта, ДанныеСообщения);
		
		ЗаполнитьСвойстваСообщенияXDTO(Фабрика, ОбъектXDTO, ДанныеСообщения);
		
		ТелоСообщения = ПреобразоватьОбъектXDTOВСтроку(Фабрика, ДанныеСообщения.ПространствоИмен, ОбъектXDTO);
		
	Иначе
		ТелоСообщения = СтрШаблон("Не обнаружена схема данных по объекту: %1", ИмяОбъекта);
		
	КонецЕсли;
	
	Возврат ТелоСообщения;
	
КонецФункции

// Читает полученное сообщение.
// 
// Параметры:
//  ТелоСообщения - Строка - тело сообщения.
// 
// Возвращаемое значение:
//  Структура:
// 		* БылиОшибки - Булево - признак наличия ошибок.
// 		* ТекстОшибки - Строка - полный текст ошибки.
// 		* ЗагруженныеОбъекты - Массив - ссылки на загруженные объекты.
// 		* ИдентификаторСообщения - УникальныйИдентификатор - идентификатор полученного сообщения.
// 		* ДатаОбработки - ДатаВремя - дата завершения обработки сообщения.
// 
Функция ПрочитатьТелоСообщения(ТелоСообщения, json = Ложь) Экспорт
    
    Если json Тогда
        Возврат ПолучитьОбъектИзJSON(ТелоСообщения);
	КонецЕсли;
	
	ДанныеСообщения = Новый Структура;
	
	// Проверка корректности формата сообщения.
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТелоСообщения);
	Попытка
		ЧтениеXML.ПерейтиКСодержимому();
		
	Исключение
		ДанныеСообщения.Вставить("БылиОшибки", Истина);
		ДанныеСообщения.Вставить("ТекстОшибки", "Не удалось прочитать тело XML сообщения.");
		
		Возврат ДанныеСообщения;
		
	КонецПопытки;
	
	// Получим имя объекта и схему данных.
	ИмяОбъекта = СП_СхемыДанных.ИмяОбъектаПоПространствуИмен(ЧтениеXML.URIПространстваИмен);
	СхемаДанных = ПолучитьСхемуДанныхПоИмениОбъекта(ИмяОбъекта, ЧтениеXML.URIПространстваИмен);
	
	Если СхемаДанных = Неопределено Тогда
		ДанныеСообщения.Вставить("БылиОшибки", Истина);
		ДанныеСообщения.Вставить("ТекстОшибки", "Не обнаружена схема данных по побъекту: " + ИмяОбъекта);
		
	Иначе
		Результат = ЗагрузитьСообщение(СхемаДанных, ТелоСообщения);
		
		Если Результат.Успешно Тогда
			ДанныеСообщения.Вставить("ЗагруженныеОбъекты", Результат.МассивЗагруженныхОбъектов);
			ДанныеСообщения.Вставить("ИдентификаторСообщения", Результат.СвойстваСообщения.ИдентификаторСообщения);
			ДанныеСообщения.Вставить("ДатаОбработки", ТекущаяДатаСеанса());
			ДанныеСообщения.Вставить("ИмяОбъекта", Результат.ДанныеОбъекта.ПолноеИмя);
			
		Иначе
			ДанныеСообщения.Вставить("БылиОшибки", Истина);
			ДанныеСообщения.Вставить("ТекстОшибки", Результат.ТекстОшибки);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ДанныеСообщения;
	
КонецФункции

// Заполняет загружаемый объект.
// 
// Параметры:
//  ЗагружаемыйОбъект - ЛюбойОбъект - загружаемый объект.
//  СтруктураОбъекта - Структура - структура загружаемого объекта.
//  СписокСвойств - Строка - строка заполняемых свойств.
//  ИсключаяСвойства - Строка - строка исключаемых свойств.
//
Процедура ЗаполнитьЗагружаемыйОбъект(ЗагружаемыйОбъект, Знач СтруктураОбъекта, 
	СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	ЗаполнитьСсылочныеРеквизиты(СтруктураОбъекта);
	ЗаполнитьЗначенияСвойств(ЗагружаемыйОбъект, СтруктураОбъекта, СписокСвойств, ИсключаяСвойства);
	
	Для Каждого КлючИЗначение Из СтруктураОбъекта Цикл
		
		Если ТипЗнч(КлючИЗначение.Значение) = Тип("ТаблицаЗначений") Тогда
			
			ИмяТабличнойЧасти = КлючИЗначение.Ключ;
			ТабличнаяЧасть = КлючИЗначение.Значение;
			
			Если ЕстьТабличнаяЧастьОбъекта(ЗагружаемыйОбъект.Метаданные(), ИмяТабличнойЧасти) Тогда
				ЗагружаемыйОбъект[ИмяТабличнойЧасти].Загрузить(ТабличнаяЧасть);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
		
КонецПроцедуры

// Определяет принадлежность объекта метаданных к типу регистр.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных.
// 
// Возвращаемое значение:
//   Булево - Истина, если объект является регистром.
//
Функция ЭтоРегистр(ПолноеИмя) Экспорт
	
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
	
	Если ОбъектМетаданных <> Неопределено Тогда
	
		Возврат Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных)
			Или Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных)
			Или Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных)
			Или Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных);
		
	Иначе
		Возврат Ложь;
		
	КонецЕсли;
		
КонецФункции

// Создает набор записей регистра.
// 
// Параметры:
//  Отбор - Структура - отбор записей регистра.
//  ПолноеИмя - Строка - полное имя регистра.
// 
// Возвращаемое значение:
//  НаборЗаписей - набор записей регистра.
//  
Функция СоздатьНаборЗаписейРегистра(Отбор, ПолноеИмя) Экспорт
	
	МенеджерОбъекта = ПолучитьМенеджерОбъектаПоИмени(ПолноеИмя);
	Если МенеджерОбъекта = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НаборЗаписей = МенеджерОбъекта.СоздатьНаборЗаписей();
	МетаданныеОбъекта = НаборЗаписей.Метаданные();
	
	ЗаполнитьСсылочныеРеквизиты(Отбор);
	
	Для Каждого КлючИЗначение Из Отбор Цикл
		
		ИмяОтбора = КлючИЗначение.Ключ;
		ЭтоГУИД = Ложь;
		
		Если ЕстьЭлементОтбораРегистра(МетаданныеОбъекта, ИмяОтбора, ЭтоГУИД) Тогда
			ЗначениеОтбора = ПолучитьЗначениеРеквизита(КлючИЗначение.Значение);
			Если ЭтоГУИД Тогда
				ЗначениеОтбора = Новый УникальныйИдентификатор(ЗначениеОтбора);
			КонецЕсли;
			НаборЗаписей.Отбор[ИмяОтбора].Установить(ЗначениеОтбора);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НаборЗаписей;
	
КонецФункции

// Получить имя типа в виде строки.
// 
// Параметры:
//  ТипЗначенияРеквизита - Тип - тип значения проверяемого реквизита.
//  ПримитивныйТип - Булево - необязательный, реквизит является примитивным.
// 
// Возвращаемое значение:
//  Строка - имя переданного типа в виде строки.
//  
Функция ПолучитьИмяТипаВВидеСтроки(ТипЗначенияРеквизита, ПримитивныйТип = Ложь) Экспорт
	
	Если ТипЗначенияРеквизита = Тип("Строка")
		или ТипЗначенияРеквизита = Тип("ОписаниеТипов")
		или ТипЗначенияРеквизита = Тип("УникальныйИдентификатор") Тогда
		
		ИмяТипа = "string";
		ПримитивныйТип = Истина;
		
	ИначеЕсли ТипЗначенияРеквизита = Тип("Число") Тогда
		ИмяТипа = "decimal";
		ПримитивныйТип = Истина;
		
	ИначеЕсли ТипЗначенияРеквизита = Тип("Булево") Тогда
		ИмяТипа = "boolean";
		ПримитивныйТип = Истина;
		
	ИначеЕсли ТипЗначенияРеквизита = Тип("Дата") Тогда
		ИмяТипа = "dateTime";
		ПримитивныйТип = Истина;
		
	ИначеЕсли ТипЗначенияРеквизита = Тип("ХранилищеЗначения") Тогда
		ИмяТипа = "base64Binary";
		ПримитивныйТип = Истина;
		
	Иначе
		МетаданныеТипа = Метаданные.НайтиПоТипу(ТипЗначенияРеквизита);
		Если МетаданныеТипа = Неопределено Тогда
			ИмяТипа = "%НеподдерживаемыйТип%";
		Иначе
			ИмяТипа = МетаданныеТипа.ПолноеИмя();
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ИмяТипа;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьФабрикуXDTOПоСхеме(СхемаДанныхСтрока)
	
	СхемаДанныхОбъект = ПолучитьСхемуДанныхВВидеОбъекта(СхемаДанныхСтрока);
	
	НаборСхем = Новый НаборСхемXML();
	НаборСхем.Добавить(СхемаДанныхОбъект);
	
	Возврат Новый ФабрикаXDTO(НаборСхем);
	
КонецФункции

Функция ПолучитьСхемуДанныхВВидеОбъекта(СхемаДанныхСтрока)
	
	ЧтениеXML = Новый ЧтениеXML; 
	ЧтениеXML.УстановитьСтроку(СхемаДанныхСтрока);
	
	ПостроительDOM  = Новый ПостроительDOM;
	ДокументDOM		= ПостроительDOM.Прочитать(ЧтениеXML);
	
	ПостроительСхем = Новый ПостроительСхемXML;
	
	СхемаОбъект = ПостроительСхем.СоздатьСхемуXML(ДокументDOM);
	СхемаОбъект.ОбновитьЭлементDOM();
	
	Возврат СхемаОбъект;
	
КонецФункции

Функция ПолучитьСтруктуруДанныхОбъекта(СсылкаНаОбъект, ИмяОбъекта)
	
	СтруктураДанных = Новый Структура;
	МетаОбъект = СсылкаНаОбъект.Метаданные();
	
	Если ЭтоРегистр(ИмяОбъекта) Тогда
		
		Отбор = Новый Структура;
		Для Каждого ЭлементОтбора Из СсылкаНаОбъект.Отбор Цикл
			Отбор.Вставить(ЭлементОтбора.Имя, ЭлементОтбора.Значение);
		КонецЦикла;
		
		СтруктураДанных.Вставить("Отбор", Отбор);
		СтруктураДанных.Вставить("НаборЗаписей", СсылкаНаОбъект.Выгрузить());
		
	Иначе
		
		СтруктураДанных.Вставить("Идентификатор", XMLСтрока(СсылкаНаОбъект));
		
		Для Каждого ТекРеквизит Из МетаОбъект.СтандартныеРеквизиты Цикл
			СтруктураДанных.Вставить(ТекРеквизит.Имя, СсылкаНаОбъект[ТекРеквизит.Имя]);
		КонецЦикла;
		
		Для каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
			СтруктураДанных.Вставить(ТекРеквизит.Имя, СсылкаНаОбъект[ТекРеквизит.Имя]);
		КонецЦикла;
		
		Для каждого ТекТаблица Из МетаОбъект.ТабличныеЧасти Цикл
			СтруктураДанных.Вставить(ТекТаблица.Имя, СсылкаНаОбъект[ТекТаблица.Имя].Выгрузить());
		КонецЦикла;
	
	КонецЕсли;
	
	Возврат СтруктураДанных;
	
КонецФункции

Функция ПреобразоватьСтруктуруВОбъектXDTO(Фабрика, ДанныеОбъекта, ДанныеСообщения)
	
	ПространствоИмен = ДанныеСообщения.ПространствоИмен;
	ПолноеИмяОбъекта = ДанныеСообщения.ПолноеИмяОбъекта;
	
	ТипСообщение = Фабрика.Тип(ПространствоИмен, "Сообщение");
	СообщениеXDTO = Фабрика.Создать(ТипСообщение);
	
	ТипОбъекта = Фабрика.Тип(ПространствоИмен, ПолноеИмяОбъекта);
	ОбъектXDTO = Фабрика.Создать(ТипОбъекта);
	ОбъектXDTO = СтруктураРеквизитовВОбъектXDTO(Фабрика, ТипОбъекта, ОбъектXDTO, ДанныеОбъекта, ПространствоИмен);
	
	Если СообщениеXDTO.СтрокаСообщения = Неопределено Тогда
		СообщениеXDTO.СтрокаСообщения = ОбъектXDTO;
	Иначе
		СообщениеXDTO.СтрокаСообщения.Добавить(ОбъектXDTO);
	КонецЕсли;
	
	ИмяТипа = СтрШаблон("%1.Отбор", ПолноеИмяОбъекта);
	ТипОтбор = Фабрика.Тип(ПространствоИмен, ИмяТипа);
	Если ТипОтбор <> Неопределено Тогда
		РеквизитыОтбора = ДанныеОбъекта.Отбор;
		
		ОтборXDTO = Фабрика.Создать(ТипОтбор);
		ОтборXDTO = СтруктураРеквизитовВОбъектXDTO(Фабрика, ТипОтбор, ОтборXDTO, РеквизитыОтбора, ПространствоИмен);
		
		СообщениеXDTO.Отбор = ОтборXDTO;	
	КонецЕсли;
	
	Возврат СообщениеXDTO;
	
КонецФункции

Функция ПреобразоватьОбъектXDTOВСтроку(Фабрика, ПространствоИмен, СообщениеXDTO)

	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	Фабрика.ЗаписатьXML(ЗаписьXML, СообщениеXDTO, "Сообщение", ПространствоИмен);
	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

Функция СтруктураРеквизитовВОбъектXDTO(Фабрика, ТипОбъектаXDTO, ОбъектXDTO, СтруктураРеквизитов, ПространствоИмен)
	
	Для Каждого Свойство Из ТипОбъектаXDTO.Свойства Цикл
		
		Если СтруктураРеквизитов.Свойство(Свойство.Имя) Тогда
			
			ЗначениеРеквизита = СтруктураРеквизитов[Свойство.Имя];
			Если Не ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
				Продолжить;
			КонецЕсли;
			
			Если ТипЗнч(Свойство.Тип) = Тип("ТипЗначенияXDTO") Тогда // примитивные типы
				ОбъектXDTO[Свойство.Имя] = ПолучитьПримитивныйТипXDTO(Свойство.Тип.Имя, ЗначениеРеквизита);
				
			ИначеЕсли Свойство.Тип.Свойства.Количество() = 1
				И Свойство.Тип.Свойства[0].ВерхняяГраница = - 1 Тогда // таблица
				
				ОбъектXDTO[Свойство.Имя] = ПолучитьТабличнуюЧастьXDTO(Фабрика,
												ПространствоИмен, Свойство, ЗначениеРеквизита);
				
			ИначеЕсли Свойство.Тип.Имя = "" Тогда // составной тип данных
				ОбъектXDTO[Свойство.Имя] = ПолучитьСоставнойТипXDTO(Фабрика,
												ПространствоИмен, Свойство, ЗначениеРеквизита);
				
			Иначе
				// объект-ссылка
				ТипСвязанногоОбъекта = Фабрика.Тип(ПространствоИмен, Свойство.Тип.Имя);
				СвязанныйОбъектXDTO = Фабрика.Создать(ТипСвязанногоОбъекта);
				
				СтруктураЗначения = Новый Структура("Идентификатор", XMLСтрока(ЗначениеРеквизита));
				ОбъектXDTO[Свойство.Имя] = СтруктураРеквизитовВОбъектXDTO(
					Фабрика, ТипСвязанногоОбъекта, СвязанныйОбъектXDTO, СтруктураЗначения, ПространствоИмен);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;

	Возврат ОбъектXDTO;
	
КонецФункции

Функция ПолучитьПримитивныйТипXDTO(ИмяТипа, ВходящееЗначение)
	
	ДлинаПеречисления = 13;
	Если Лев(ИмяТипа, ДлинаПеречисления) = "Перечисление." Тогда
		ИсходящееЗначение = ПеречислениеВСтроку(ИмяТипа, ВходящееЗначение);
		
	ИначеЕсли ТипЗнч(ВходящееЗначение) = Тип("ОписаниеТипов") Тогда
		ИсходящееЗначение = ОписаниеТиповВСтроку(ВходящееЗначение);
		
	ИначеЕсли ТипЗнч(ВходящееЗначение) = Тип("УникальныйИдентификатор") Тогда
		ИсходящееЗначение = XMLСтрока(ВходящееЗначение);
		
	ИначеЕсли ИмяТипа = "base64Binary" Тогда
		ИсходящееЗначение = ХранилищеЗначенияВСтрокуДанных(ВходящееЗначение);
		
	Иначе
		ИсходящееЗначение = ВходящееЗначение;
		
	КонецЕсли;
	
	Возврат ИсходящееЗначение;
	
КонецФункции

Функция ПолучитьТабличнуюЧастьXDTO(Фабрика, ПространствоИмен, Свойство, ЗначениеРеквизита)
	
	ТипТабличнаяЧасть = Фабрика.Тип(ПространствоИмен, Свойство.Тип.Имя);
	ТабличнаяЧастьXDTO = Фабрика.Создать(ТипТабличнаяЧасть);
	
	Для Каждого СтрокаТаблЧасти Из ЗначениеРеквизита Цикл
		
		СтруктураСтрокиТаблЧасти = СтрокаТаблицыВСтруктуру(ЗначениеРеквизита.Колонки, СтрокаТаблЧасти);
		ТипСтрокаТабличнойЧасти = Свойство.Тип.Свойства[0].Тип;
		СтрокаТабличнойЧастиXDTO = Фабрика.Создать(ТипСтрокаТабличнойЧасти);
		
		СтрокаXDTO = СтруктураРеквизитовВОбъектXDTO(Фабрика,
						ТипСтрокаТабличнойЧасти, 
						СтрокаТабличнойЧастиXDTO, 
						СтруктураСтрокиТаблЧасти, 
						ПространствоИмен);
		
		ТабличнаяЧастьXDTO.Строка.Добавить(СтрокаXDTO);
		
	КонецЦикла;
	
	Возврат ТабличнаяЧастьXDTO;
	
КонецФункции

Функция ПолучитьСоставнойТипXDTO(Фабрика, ПространствоИмен, Свойство, ВходящееЗначение)
	
	ИмяТипа = ПолучитьИмяТипаВВидеСтроки(ТипЗнч(ВходящееЗначение));
	ИмяТипаБезТочки = СтрЗаменить(ИмяТипа, ".", "_");
	
	ДлинаПеречисления = 13;
	Если Лев(ИмяТипа, ДлинаПеречисления) = "Перечисление." Тогда // перечисление внутри составного
		ИтоговоеЗначение = ПеречислениеВСтроку(ИмяТипа, ВходящееЗначение);
		
	ИначеЕсли СтрНайти(ИмяТипа, ".") > 0 Тогда // это ссылка внутри составного
		ТипСвязанногоОбъекта = Фабрика.Тип(ПространствоИмен, ИмяТипа);
		СвязанныйОбъектXDTO = Фабрика.Создать(ТипСвязанногоОбъекта);
		
		СтруктураЗначения = Новый Структура("Идентификатор", XMLСтрока(ВходящееЗначение));
		ИтоговоеЗначение = СтруктураРеквизитовВОбъектXDTO(Фабрика,
								ТипСвязанногоОбъекта, СвязанныйОбъектXDTO, 
								СтруктураЗначения, ПространствоИмен);
		
	Иначе // примитивный тип внутри составного
		Если ИмяТипа = "Структура" И ВходящееЗначение.Свойство(Свойство.Имя) Тогда
			ИтоговоеЗначение = ВходящееЗначение[Свойство.Имя];
			
		ИначеЕсли СтрНайти("string,decimal,boolean,dateTime", ИмяТипа) = 0 Тогда
			ИтоговоеЗначение = Неопределено;
			
		Иначе
			ИтоговоеЗначение = ВходящееЗначение;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ИтоговоеЗначение = Неопределено Тогда
		СоставнойОбъектXDTO = "";
		
	Иначе
		СоставнойОбъектXDTO = Фабрика.Создать(Свойство.Тип);
		СоставнойОбъектXDTO[ИмяТипаБезТочки] = ИтоговоеЗначение;
		
	КонецЕсли;
	
	Возврат СоставнойОбъектXDTO;
	
КонецФункции

Функция ПеречислениеВСтроку(ПолноеИмя, ЗначениеПеречисления) Экспорт
	
	МетаданныеПеречисления = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
	Менеджер = Новый (СтрЗаменить(ПолноеИмя, ".", "Менеджер."));
	ИндексЗначенияПеречисления = Менеджер.Индекс(ЗначениеПеречисления);
	
	Возврат МетаданныеПеречисления.ЗначенияПеречисления[ИндексЗначенияПеречисления].Имя;
	
КонецФункции

Функция ОписаниеТиповВСтроку(ОписаниеТипов)
	
	СтрокаТипов = "";
	Типы = ОписаниеТипов.Типы();
	
	Для Каждого Тип Из Типы Цикл
		Если Не ПустаяСтрока(СтрокаТипов) Тогда
			СтрокаТипов = СтрШаблон("%1, ", СтрокаТипов);
		КонецЕсли;
		
		МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
		Если МетаданныеТипа = Неопределено Тогда
			СтрокаТипов = СтрШаблон("%1%2", СтрокаТипов, Тип);
		Иначе
			СтрокаТипов = СтрШаблон("%1%2", СтрокаТипов, МетаданныеТипа.ПолноеИмя());
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрокаТипов;
	
КонецФункции

Функция ХранилищеЗначенияВСтрокуДанных(ХранилищеЗначения)
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("xml");
	
	// Сериализуем данные в файл
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ИмяВременногоФайла);
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, ХранилищеЗначения, НазначениеТипаXML.Явное);
	ЗаписьXML.Закрыть();
	
	ДвоичныеДанные = Новый ДвоичныеДанные(ИмяВременногоФайла);
	СтрокаДанных = Base64Строка(ДвоичныеДанные);
	
	Попытка
		УдалитьФайлы(ИмяВременногоФайла);
		
	Исключение
		ВызватьИсключение ОписаниеОшибки();
		
	КонецПопытки;
	
	Возврат СтрокаДанных;

КонецФункции

Функция СтрокаТаблицыВСтруктуру(КолонкиТаблицы, СтрокаТаблицы)
	
	Структура = Новый Структура;
	
	Для Каждого Колонка Из КолонкиТаблицы Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

Процедура ЗаполнитьСвойстваСообщенияXDTO(Фабрика, ОбъектXDTO, ДанныеСообщения)
	
	ТипСвойства = Фабрика.Тип(ДанныеСообщения.ПространствоИмен, "СвойстваСообщения");
	СвойстваСообщения = Фабрика.Создать(ТипСвойства);
	СвойстваСообщения.ИдентификаторСообщения = ДанныеСообщения.ИДСообщения;
	СвойстваСообщения.ИмяБазыИсточника = ПолучитьИмяТекущейБазы(); 
	СвойстваСообщения.ПолноеИмяБазыИсточника = ПолучитьПолноеИмяТекущейБазы();
	СвойстваСообщения.КлючМаршрутизации = ПолучитьКлючМаршрутизацииИсходящегоСообщения(ДанныеСообщения);
	
	ОбъектXDTO.СвойстваСообщения = СвойстваСообщения; 
		
КонецПроцедуры

// Получает имя текущей базы данных.
// 
// Возвращаемое значение:
//  Строка - имя текущей базы.
//
Функция ПолучитьИмяТекущейБазы()
	
	ПолноеИмяТекущейБазы = ПолучитьПолноеИмяТекущейБазы();	
	
	ПозицияНачала = СтрНайти(ПолноеИмяТекущейБазы, "Ref=");
	Если ПозицияНачала = 0 Тогда
		Возврат ПолноеИмяТекущейБазы;
		
	Иначе
		// Отрезаем имя сервера, получаем имя базы.
		НачальныйСимвол = 6;
		КолСимволовОкончание = 7;
		
		ИмяТекущейБазы = Прав(ПолноеИмяТекущейБазы, СтрДлина(ПолноеИмяТекущейБазы) - ПозицияНачала + 1);
		
		Возврат Сред(ИмяТекущейБазы, НачальныйСимвол, СтрДлина(ИмяТекущейБазы) - КолСимволовОкончание);
		
	КонецЕсли;
	
КонецФункции

// Получает полное имя текущей базы.
// 
// Возвращаемое значение:
//  Строка - полное имя текущей базы.
//
Функция ПолучитьПолноеИмяТекущейБазы()
	
	Возврат СтрокаСоединенияИнформационнойБазы();	
	
КонецФункции

// Получить ключ маршрутизации исходящего сообщения.
// 
// Параметры:
//  ДанныеСообщения - Структура:
// 		* ПространствоИмен - Срока - имя пространство имен для объекта. 
// 		* ПолноеИмяОбъекта - Строка - полное имя объекта метаданных. 
// 		* ИДСообщения - Строка - идентификатор соообщения.
// 
// Возвращаемое значение:
//  Строка - ключ маршрутизации исходящего сообщения.
//
Функция ПолучитьКлючМаршрутизацииИсходящегоСообщения(ДанныеСообщения)
	
	Возврат СтрШаблон("all.%1", ДанныеСообщения.ПолноеИмяОбъекта); 
	
КонецФункции

// Загружает полученное сообщение согласно схемы данных.
// 
// Параметры:
//  СхемаДанных - Неопределено, СП_СхемыДанных.Ссылка - схема данных.
//  ТелоСообщения - Строка - тело сообщения.
// 
// Возвращаемое значение:
// 	Структура:
// 		* Успешно - Булево - признак успешной загрузки.
// 		* МассивЗагруженныхОбъектов - Массив - массив ссылок загруженных объектов.
// 		* ТекстОшибки - Строка - полный текст ошибки.
// 		* СвойстваСообщения - Структура:
// 			** ПолноеИмя - Строка - имя объекта метаданных текущей базы.
// 			** ПолноеИмяИсточник - Строка - имя объекта метаданных источника.
// 
Функция ЗагрузитьСообщение(СхемаДанных, ТелоСообщения)
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТелоСообщения);
	ЧтениеXML.ПерейтиКСодержимому();
	
	Фабрика = ПолучитьФабрикуXDTOПоСхеме(СхемаДанных);
	ПространствоИмен = ЧтениеXML.URIПространстваИмен;
	
	Попытка
		ОбъектXDTO = Фабрика.ПрочитатьXML(ЧтениеXML, Фабрика.Тип(ПространствоИмен, "Сообщение"));
		
	Исключение
		Результат = Новый Структура;
		Результат.Вставить("Успешно", Ложь);
		Результат.Вставить("ТекстОшибки", ОписаниеОшибки());
		Результат.Вставить("МассивЗагруженныхОбъектов", Новый Массив);
		
		Возврат Результат;
		
	КонецПопытки;
	
	СвойстваСообщения = ПолучитьСвойстваСообщения(ОбъектXDTO);
	ДанныеОбъекта = ОбъектXDTOВДанныеОбъекта(ОбъектXDTO);
	
	Результат = ЗаписатьДанныеОбъектаВИБ(ДанныеОбъекта);
	Результат.Вставить("СвойстваСообщения", СвойстваСообщения);
	Результат.Вставить("ДанныеОбъекта", ДанныеОбъекта);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьСвойстваСообщения(ОбъектXDTO) 
	
	СвойстваСообщения = Новый Структура;
	
	Для Каждого СвойствоСообщения Из ОбъектXDTO.Свойства() Цикл
		Если СвойствоСообщения.Имя = "СвойстваСообщения" Тогда
			СвойстваСообщения = ОбъектXDTOВСтруктуру(ОбъектXDTO[СвойствоСообщения.Имя]);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СвойстваСообщения;
	
КонецФункции

Функция ОбъектXDTOВДанныеОбъекта(ОбъектXDTO)
	
	ДанныеОбъекта = Новый Структура;
	
	Для Каждого СвойствоСообщения Из ОбъектXDTO.Свойства() Цикл
		Если СвойствоСообщения.Имя = "Отбор" Тогда
			ДанныеОбъекта.Вставить("Отбор", ОбъектXDTOВТаблицуЗначений(ОбъектXDTO[СвойствоСообщения.Имя]));
		КонецЕсли;
		
		Если СвойствоСообщения.Имя = "СтрокаСообщения" Тогда
			ДанныеОбъекта.Вставить("Реквизиты", ОбъектXDTOВТаблицуЗначений(ОбъектXDTO[СвойствоСообщения.Имя]));
			ДанныеОбъекта.Вставить("ПолноеИмя", СвойствоСообщения.Тип.Имя);
			ДанныеОбъекта.Вставить("ПолноеИмяИсточник", СвойствоСообщения.Тип.Имя);
			
			ДанныеОбъекта.ПолноеИмя = 
				СП_ОбменДаннымиПереопределяемый.ОпределитьПолноеИмяОбъектаМетаданных(ДанныеОбъекта);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ДанныеОбъекта;
	
КонецФункции

Функция ОбъектXDTOВТаблицуЗначений(ОбъектXDTO)
	
	ТаблицаРезультат = Новый ТаблицаЗначений;
	
	ТипЗначенияОбъекта = ТипЗнч(ОбъектXDTO); 
	Если ТипЗначенияОбъекта = Тип("ОбъектXDTO") Тогда
		ОбрабатываемыйОбъект = ОбъектXDTO;
		
	ИначеЕсли ТипЗначенияОбъекта = Тип("СписокXDTO") И ЗначениеЗаполнено(ОбъектXDTO) Тогда
		ОбрабатываемыйОбъект = ОбъектXDTO.Получить(0);
		
	Иначе
		Возврат ТаблицаРезультат;
		
	КонецЕсли;
	
	Для Каждого Свойство Из ОбрабатываемыйОбъект.Свойства() Цикл
		ТаблицаРезультат.Колонки.Добавить(Свойство.Имя);
	КонецЦикла;
	
	Если ТипЗначенияОбъекта = Тип("СписокXDTO") Тогда
		Для Каждого ЭлементСпискаXDTO Из ОбъектXDTO Цикл
			НоваяСтрока = ТаблицаРезультат.Добавить();
			ЗаполнитьСтрокуТаблицы(НоваяСтрока, ЭлементСпискаXDTO);
		КонецЦикла;
		
	Иначе
		НоваяСтрока = ТаблицаРезультат.Добавить();
		ЗаполнитьСтрокуТаблицы(НоваяСтрока, ОбъектXDTO);
		
	КонецЕсли;
	
	Возврат ТаблицаРезультат;
	
КонецФункции

Процедура ЗаполнитьСтрокуТаблицы(СтрокаТаблицы, ОбъектXDTO)
	
	Для Каждого Свойство Из ОбъектXDTO.Свойства() Цикл
		
		ТипТекущегоСвойства = ТипЗнч(ОбъектXDTO[Свойство.Имя]);
		
		ДлинаПеречисления = 13;
		ЭтоПеречисление = Лев(Свойство.Тип.Имя, ДлинаПеречисления) = "Перечисление."; 
		 
		Если ТипТекущегоСвойства = Тип("ОбъектXDTO") Тогда
			Если Свойство.Тип.Свойства.Количество() = 1 И 
				Свойство.Тип.Свойства[0].ВерхняяГраница = -1 Тогда
				СтрокаТаблицы[Свойство.Имя] = ОбъектXDTOВТаблицуЗначений(ОбъектXDTO[Свойство.Имя].Строка);
			Иначе
				СтрокаТаблицы[Свойство.Имя] = ОбъектXDTOВСтруктуру(ОбъектXDTO[Свойство.Имя]);
			КонецЕсли;
			
		ИначеЕсли ТипТекущегоСвойства = Тип("СписокXDTO") Тогда
			СтрокаТаблицы[Свойство.Имя] = ОбъектXDTOВТаблицуЗначений(ОбъектXDTO[Свойство.Имя]);
			
		ИначеЕсли ЭтоПеречисление Тогда			
			СтруктураРезультат = Новый Структура(
				"ПолноеИмя, ПолноеИмяИсточник, ЗначениеПеречисления",
				Свойство.Тип.Имя, Свойство.Тип.Имя, ОбъектXDTO[Свойство.Имя]);
			
			СтруктураРезультат.ПолноеИмя = 
				СП_ОбменДаннымиПереопределяемый.ОпределитьПолноеИмяОбъектаМетаданных(СтруктураРезультат);
						
			СтрокаТаблицы[Свойство.Имя] = СтруктураРезультат;
			 	
		Иначе	
			СтрокаТаблицы[Свойство.Имя] = ОбъектXDTO[Свойство.Имя];
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ОбъектXDTOВСтруктуру(ОбъектXDTO)
	
	ЭтоСоставнойТип = Не ЗначениеЗаполнено(ОбъектXDTO.Тип().Имя);
	Если ЭтоСоставнойТип Тогда
		Возврат ПолучитьТекущееЗначениеСоставногоТипа(ОбъектXDTO);
	КонецЕсли;
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого Свойство Из ОбъектXDTO.Свойства() Цикл
		
		ТекущийОбъектXDTO = ОбъектXDTO[Свойство.Имя];
		ТипЗначенияСвойства = ТипЗнч(ТекущийОбъектXDTO);
		
		Если ТипЗначенияСвойства = Тип("ОбъектXDTO") Тогда
			СтруктураРезультат.Вставить(Свойство.Имя, ОбъектXDTOВСтруктуру(ТекущийОбъектXDTO));
			
		ИначеЕсли ТипЗначенияСвойства = Тип("СписокXDTO") Тогда
			СтруктураРезультат.Вставить(Свойство.Имя, ОбъектXDTOВТаблицуЗначений(ТекущийОбъектXDTO));
			
		Иначе
			СтруктураРезультат.Вставить(Свойство.Имя, ТекущийОбъектXDTO);
			
		КонецЕсли;
		
	КонецЦикла;
	
	СтруктураРезультат.Вставить("ПолноеИмя", ОбъектXDTO.Тип().Имя);
	СтруктураРезультат.Вставить("ПолноеИмяИсточник", ОбъектXDTO.Тип().Имя);
			
	СтруктураРезультат.ПолноеИмя = 
		СП_ОбменДаннымиПереопределяемый.ОпределитьПолноеИмяОбъектаМетаданных(СтруктураРезультат);
	
	Возврат СтруктураРезультат;
	
КонецФункции

Функция ПолучитьТекущееЗначениеСоставногоТипа(ОбъектXDTO)
	
	ТекущийОбъектXDTO = Неопределено;
	
	Для Каждого Свойство Из ОбъектXDTO.Свойства() Цикл
		
		ТекущийОбъектXDTO = ОбъектXDTO[Свойство.Имя];
		Если Не ТекущийОбъектXDTO = Неопределено Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ТипЗнч(ТекущийОбъектXDTO) = Тип("ОбъектXDTO") Тогда
		Возврат ОбъектXDTOВСтруктуру(ТекущийОбъектXDTO);
		
	Иначе
		Возврат ТекущийОбъектXDTO;
		
	КонецЕсли;
	
КонецФункции

// Записывает данные полученного объекта в информационную базу.
// 
// Параметры:
//  ДанныеОбъекта - Структура - Данные объекта:
// 		* Отбор - ТаблицаЗначений - таблица отбора по объекту.
// 		* Реквизиты - ТаблицаЗначений - таблица реквизитов объекта.
// 		* ПолноеИмя - Строка - полное имя объекта текущей базы.
// 		* ПолноеИмяИсточник - Строка - полное имя объекта источника.
// 
// Возвращаемое значение:
//  Структура - итог записи объекта в базу.
// 		* Успешно - Булево - признак успешной загрузки.
// 		* МассивЗагруженныхОбъектов - Массив - массив загруженных объектов.
// 		* ТекстОшибки - Строка - текст ошибки при загрузке.
//
Функция ЗаписатьДанныеОбъектаВИБ(ДанныеОбъекта)
	
	Результат = Новый Структура("Успешно, МассивЗагруженныхОбъектов", Ложь, Новый Массив);
	
	НачатьТранзакцию();
	
	Попытка
		Объект = ПолучитьЗагружаемыйОбъект(ДанныеОбъекта);
		ЗаписатьЗагружаемыйОбъект(Объект);
		
		РеквизитыИСвойства = СП_СхемыДанных.НоваяСтруктураРеквизитовИСвойств(Объект.Метаданные());
		ЭтоСсылка = РеквизитыИСвойства.Свойства.Свойство("ЭтоСсылка");
		
		Если ЭтоСсылка Тогда
			Результат.МассивЗагруженныхОбъектов.Добавить(Объект.Ссылка);
		КонецЕсли;
		
		Результат.Вставить("Успешно", Истина);
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		ОтменитьТранзакцию();
		
		Результат.Вставить("Успешно", Ложь);
		Результат.Вставить("ТекстОшибки", ОписаниеОшибки());
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьЗагружаемыйОбъект(ДанныеОбъекта)
	
	Если Не ДанныеОбъекта.Свойство("ПолноеИмя") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЭтоРегистр = ЭтоРегистр(ДанныеОбъекта.ПолноеИмя);
	Если ЭтоРегистр  Тогда
		Отбор = СтрокаТаблицыВСтруктуру(ДанныеОбъекта.Отбор.Колонки, ДанныеОбъекта.Отбор[0]);
		ЗагружаемыйОбъект = СоздатьНаборЗаписейРегистра(Отбор, ДанныеОбъекта.ПолноеИмя);
		
		Для Каждого СтрокаСообщения Из ДанныеОбъекта.Реквизиты Цикл
			СтруктураОбъекта = СтрокаТаблицыВСтруктуру(ДанныеОбъекта.Реквизиты.Колонки, СтрокаСообщения);
			
			Если СтруктураОбъекта.Свойство("НаборЗаписей") 
				И ТипЗнч(СтруктураОбъекта.НаборЗаписей) = Тип("ТаблицаЗначений") Тогда
				
				Для каждого СтрокаЗапись Из СтруктураОбъекта.НаборЗаписей Цикл
					СтруктураЗаписи = СтрокаТаблицыВСтруктуру(СтруктураОбъекта.НаборЗаписей.Колонки, СтрокаЗапись);
					СтруктураЗаписи.Вставить("ПолноеИмя", ДанныеОбъекта.ПолноеИмя + ".Запись");
					СтруктураЗаписи.Вставить("ПолноеИмяИсточник", ДанныеОбъекта.ПолноеИмяИсточник + ".Запись");
					
					ПреобразоватьУникальныеИдентификаторы(СтруктураЗаписи, ЗагружаемыйОбъект, ЭтоРегистр);
					
					Запись = ЗагружаемыйОбъект.Добавить();
					СП_ОбменДаннымиПереопределяемый.ЗаполнитьЗагружаемыйОбъект(Запись, СтруктураЗаписи);
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;

	Иначе
		СтруктураОбъекта = СтрокаТаблицыВСтруктуру(ДанныеОбъекта.Реквизиты.Колонки, ДанныеОбъекта.Реквизиты[0]);
		СтруктураОбъекта.Вставить("ПолноеИмя", ДанныеОбъекта.ПолноеИмя);
		СтруктураОбъекта.Вставить("ПолноеИмяИсточник", ДанныеОбъекта.ПолноеИмяИсточник);
		
		ЗагружаемыйОбъект = НайтиСоздатьЗагружаемыйОбъект(СтруктураОбъекта);
		
		ПреобразоватьУникальныеИдентификаторы(СтруктураОбъекта, ЗагружаемыйОбъект);
		
		СП_ОбменДаннымиПереопределяемый.ЗаполнитьЗагружаемыйОбъект(ЗагружаемыйОбъект, СтруктураОбъекта);
		
	КонецЕсли;
	
	Возврат ЗагружаемыйОбъект;
	
КонецФункции

Функция НайтиСоздатьЗагружаемыйОбъект(СтруктураОбъекта)
	
	ЗагружаемыйОбъектСсылка = НайтиСсылкуПоЗагружаемымДанным(СтруктураОбъекта);
	Если ЗначениеЗаполнено(ЗагружаемыйОбъектСсылка) И СсылкаСуществует(ЗагружаемыйОбъектСсылка) Тогда
		Возврат ЗагружаемыйОбъектСсылка.ПолучитьОбъект();
	КонецЕсли;
	
	МенеджерОбъекта = ПолучитьМенеджерОбъектаПоИмени(СтруктураОбъекта.ПолноеИмя);
	
	ЭтоГруппа   = СтруктураОбъекта.Свойство("ЭтоГруппа") И СтруктураОбъекта.ЭтоГруппа;
	ЭтоДокумент = СтрНайти(СтруктураОбъекта.ПолноеИмя, "Документ.") > 0;
	ЭтоЗадача   = СтрНайти(СтруктураОбъекта.ПолноеИмя, "Задача.") > 0;
	
	Если ЭтоГруппа Тогда
		ЗагружаемыйОбъект = МенеджерОбъекта.СоздатьГруппу();
		
	ИначеЕсли ЭтоДокумент Тогда
		ЗагружаемыйОбъект = МенеджерОбъекта.СоздатьДокумент();
		
	ИначеЕсли ЭтоЗадача Тогда
		ЗагружаемыйОбъект = МенеджерОбъекта.СоздатьЗадачу();
		
	Иначе
		ЗагружаемыйОбъект = МенеджерОбъекта.СоздатьЭлемент();
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтруктураОбъекта.Идентификатор) Тогда
		ИдентификаторОбъекта = Новый УникальныйИдентификатор(СтруктураОбъекта.Идентификатор);
		СсылкаНовогоОбъекта = МенеджерОбъекта.ПолучитьСсылку(ИдентификаторОбъекта);
		ЗагружаемыйОбъект.УстановитьСсылкуНового(СсылкаНовогоОбъекта);
	КонецЕсли;
	
	Возврат ЗагружаемыйОбъект;
	
КонецФункции

// Выполняет поиск существующих в базе ссылок по загружаемым данным.
// 
// Параметры:
//  СтруктураОбъекта - Структура:
// 		* ПолноеИмя - Строка - полное имя метаданных базы.
// 		* ПолноеИмяИсточник - Строка - полное имя метаданных источника.
// 
// Возвращаемое значение:
//  ЛюбаяСсылка, Неопределено - ссылка на загружаемый объект.
//
Функция НайтиСсылкуПоЗагружаемымДанным(СтруктураОбъекта)
	
	МенеджерОбъекта = ПолучитьМенеджерОбъектаПоИмени(СтруктураОбъекта.ПолноеИмя);
	
	Если СтруктураОбъекта.Свойство("ЗначениеПеречисления") 
		И ЗначениеЗаполнено(СтруктураОбъекта.ЗначениеПеречисления) Тогда
		Результат = СтрокуВПеречисление(СтруктураОбъекта.ПолноеИмя, СтруктураОбъекта.ЗначениеПеречисления);
		
	ИначеЕсли СтруктураОбъекта.Свойство("Идентификатор")
		И ЗначениеЗаполнено(СтруктураОбъекта.Идентификатор) Тогда
		Результат = ПолучитьСсылкуПоИдентификатору(СтруктураОбъекта.ПолноеИмя, СтруктураОбъекта.Идентификатор);
		
	ИначеЕсли ЗначениеЗаполнено(МенеджерОбъекта) Тогда
		Результат = МенеджерОбъекта.ПустаяСсылка();
		
	Иначе
		Результат = Неопределено;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверяет существование переданной ссылки в базе данных.
//
// Параметры:
//	СсылкаНаОбъект - ЛюбаяСсылка - ссылка на объект в базе данных.
//	
// Возвращаемое значение:
// 	Булево - признак существования ссылки.
// 	
Функция СсылкаСуществует(СсылкаНаОбъект)
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|    Ссылка КАК Ссылка
	|ИЗ
	|    [ИмяТаблицы]
	|ГДЕ
	|    Ссылка = &Ссылка
	|";
	
	ТипЗначенияСсылки = ТипЗнч(СсылкаНаОбъект);
	ИмяМетаданных = Метаданные.НайтиПоТипу(ТипЗначенияСсылки).ПолноеИмя();
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяМетаданных);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", СсылкаНаОбъект);
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Получает менеджер объекта по полному имени объекта.
// 
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных.
// 
// Возвращаемое значение:
//  МенеджерОбъекта, Неопределено - менеджер объекта.
//  
Функция ПолучитьМенеджерОбъектаПоИмени(ПолноеИмя)
	
	Если Метаданные.НайтиПоПолномуИмени(ПолноеИмя) <> Неопределено Тогда
		Возврат Новый (СтрЗаменить(ПолноеИмя, ".", "Менеджер."));
		
	Иначе
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

Процедура ЗаполнитьСсылочныеРеквизиты(СтруктураОбъекта)
	
	Для Каждого КлючИЗначение Из СтруктураОбъекта Цикл
		
		ТипТекущегоЗначения = ТипЗнч(КлючИЗначение.Значение);
		 
		Если ТипТекущегоЗначения = Тип("ТаблицаЗначений") Тогда
			ЗаполнитьСсылочныеРеквизитыТаблицыЗначений(КлючИЗначение.Значение);
			
		ИначеЕсли ТипТекущегоЗначения = Тип("Структура") Тогда
			СтруктураОбъекта[КлючИЗначение.Ключ] = ПолучитьЗначениеРеквизита(КлючИЗначение.Значение);
			
		Иначе
			СтруктураОбъекта[КлючИЗначение.Ключ] = КлючИЗначение.Значение;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьСсылочныеРеквизитыТаблицыЗначений(ТаблицаЗначений)
	
	Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
		Для Каждого КолонкаТаблицы Из ТаблицаЗначений.Колонки Цикл
			ИмяКолонки = КолонкаТаблицы.Имя;
			
			Если ТипЗнч(СтрокаТаблицы[ИмяКолонки]) = Тип("Структура") Тогда
				СтрокаТаблицы[ИмяКолонки] = ПолучитьЗначениеРеквизита(СтрокаТаблицы[ИмяКолонки]);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Получает значение реквизита из переденного параметра.
// 
// Параметры:
// 	ЗначениеРеквизита - Структура, ЛюбоеЗначение - передаваемое значение.
// 	
// Возвращаемое значение:
// 	ЛюбаяСсылка, ЛюбоеЗначение - значение примитивных типов или ссылка.
// 	
Функция ПолучитьЗначениеРеквизита(ЗначениеРеквизита)
	
	Если ТипЗнч(ЗначениеРеквизита) = Тип("Структура") Тогда
		Возврат НайтиСсылкуПоЗагружаемымДанным(ЗначениеРеквизита);
		
	Иначе
		Возврат ЗначениеРеквизита;
		
	КонецЕсли;
	
КонецФункции

// Записывает загружаемый объект.
// 
// Параметры:
//  ЗагружаемыйОбъект - Неопределено, ЛюбаяСсылка - загружаемый объект.
//  
Процедура ЗаписатьЗагружаемыйОбъект(ЗагружаемыйОбъект)
	
	// Параметры записи по типу объекта.
	ПараметрыЗаписи = ПолучитьПараметрыЗаписиЗагружаемогоОбъекта(ЗагружаемыйОбъект);
	
	// При проведении и отмене проведения флаг должен быть сброшен.
	ЗагружаемыйОбъект.ОбменДанными.Загрузка = ПараметрыЗаписи.ФлагЗагрузка;
	
	// Проведение, отмена проведения, запись.
	Если ЗначениеЗаполнено(ПараметрыЗаписи.РежимЗаписи) Тогда
		ЗагружаемыйОбъект.Записать(ПараметрыЗаписи.РежимЗаписи);
	Иначе
		ЗагружаемыйОбъект.Записать();
	КонецЕсли;
	
	// Установка пометки удаления.
	Если ЗначениеЗаполнено(ПараметрыЗаписи.ПометкаУдаления) Тогда
		ЗагружаемыйОбъект.УстановитьПометкуУдаления(ПараметрыЗаписи.ПометкаУдаления);
	КонецЕсли;
	
КонецПроцедуры

// Получить параметры записи загружаемого объекта.
// 
// Параметры:
//  ЗагружаемыйОбъект - ЛюбаяСсылка - загружаемый объект.
// 
// Возвращаемое значение:
//  Структура - параметры записи:
// 		* ФлагЗагрузка - Булево - значение для флага ОбменДанными.Загрузка.
// 		* РежимЗаписи - РежимЗаписиДокумента, Неопределено - режим записи докуменнта при загрузке.
// 		* ПометкаУдаления - Булево, Неопределено - признак установки пометки на удаление при загрузке. 
// 
Функция ПолучитьПараметрыЗаписиЗагружаемогоОбъекта(ЗагружаемыйОбъект)
	
	РеквизитыИСвойства = СП_СхемыДанных.НоваяСтруктураРеквизитовИСвойств(ЗагружаемыйОбъект.Метаданные());
	
	ЭтоСсылка = РеквизитыИСвойства.Свойства.Свойство("ЭтоСсылка");
	ЗагружаемыйОбъект.ДополнительныеСвойства.Вставить("СП_ЭтоЗагрузкаДанных");
	
	ПараметрыЗаписи = Новый Структура;
	ПараметрыЗаписи.Вставить("ФлагЗагрузка", Истина);
	ПараметрыЗаписи.Вставить("РежимЗаписи", Неопределено);
	ПараметрыЗаписи.Вставить("ПометкаУдаления", Неопределено);
	
	Если ЭтоСсылка Тогда
		ДобавитьПараметрыПроведения(ПараметрыЗаписи, ЗагружаемыйОбъект);
		ДобавитьПараметрыПометкиНаУдаление(ПараметрыЗаписи, ЗагружаемыйОбъект);
	КонецЕсли;
	
	Возврат ПараметрыЗаписи;
	
КонецФункции

// Добавляет в параметры записи данные о проведении документа.
// 
// Параметры:
//  ПараметрыЗаписи - Структура - см. ПолучитьПараметрыЗаписиЗагружаемогоОбъекта().
//  ЗагружаемыйОбъект - ЛюбаяСсылка - загружаемый объект.
// 
Процедура ДобавитьПараметрыПроведения(ПараметрыЗаписи, ЗагружаемыйОбъект)
	
	ЭтоДокумент = Метаданные.Документы.Найти(ЗагружаемыйОбъект.Метаданные().Имя) <> Неопределено;
	Если Не ЭтоДокумент Тогда
		Возврат;
	КонецЕсли;
	
	БылПроведен = 
		Не ЗагружаемыйОбъект.ЭтоНовый() 
		И ЗагружаемыйОбъект.Ссылка.Проведен;
		
	СталПроведен = ЗагружаемыйОбъект.Проведен;
	
	Если Не БылПроведен И СталПроведен Тогда
		ПараметрыЗаписи.Вставить("ФлагЗагрузка", Ложь);
		ПараметрыЗаписи.Вставить("РежимЗаписи", РежимЗаписиДокумента.Проведение);
		
	ИначеЕсли БылПроведен И Не СталПроведен Тогда
		ПараметрыЗаписи.Вставить("ФлагЗагрузка", Ложь);
		ПараметрыЗаписи.Вставить("РежимЗаписи", РежимЗаписиДокумента.ОтменаПроведения);
		
	Иначе
		ПараметрыЗаписи.Вставить("ФлагЗагрузка", Истина);
		ПараметрыЗаписи.Вставить("РежимЗаписи", РежимЗаписиДокумента.Запись);
		
	КонецЕсли;
		
КонецПроцедуры

// Добавляет в параметры записи данные о пометке на удаление.
// 
// Параметры:
//  ПараметрыЗаписи - Структура - см. ПолучитьПараметрыЗаписиЗагружаемогоОбъекта().
//  ЗагружаемыйОбъект - ЛюбаяСсылка - загружаемый объект.
// 
Процедура ДобавитьПараметрыПометкиНаУдаление(ПараметрыЗаписи, ЗагружаемыйОбъект)
	
	БылПомеченНаУдаление = 
		Не ЗагружаемыйОбъект.ЭтоНовый() 
		И ЗагружаемыйОбъект.Ссылка.ПометкаУдаления;
		
	СталПомеченНаУдаление = ЗагружаемыйОбъект.ПометкаУдаления;
	
	Если Не БылПомеченНаУдаление И СталПомеченНаУдаление Тогда
		ПараметрыЗаписи.Вставить("ПометкаУдаления", Истина);
		
	ИначеЕсли БылПомеченНаУдаление И Не СталПомеченНаУдаление Тогда
		ПараметрыЗаписи.Вставить("ПометкаУдаления", Ложь);
		
	Иначе
		ПараметрыЗаписи.Вставить("ПометкаУдаления", Неопределено);
		
	КонецЕсли;
	
КонецПроцедуры

// Проверяет существование табличной части.
// 
// Параметры:
//  МетаданныеОбъекта - Метаданные - метаданные объекта.
//  ИмяТабличнойЧасти - Строка - имя табличной части.
// 
// Возвращаемое значение:
//  Булево - признак наличия табличной части.
//  
Функция ЕстьТабличнаяЧастьОбъекта(МетаданныеОбъекта, ИмяТабличнойЧасти)
	
	РеквизитыИСвойства = СП_СхемыДанных.НоваяСтруктураРеквизитовИСвойств(МетаданныеОбъекта);
	
	РеквизитНайден = Ложь;
	Если РеквизитыИСвойства.Свойство("ТабличныеЧасти") Тогда
		РеквизитНайден = МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТабличнойЧасти) <> Неопределено;
	КонецЕсли;
	
	Возврат РеквизитНайден;
	
КонецФункции

// Преобразует переданную строку в перечисление.
// 
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных.
//  ЗначениеПеречисления - Строка - значение перечисления в виде строки.
// 
// Возвращаемое значение:
//  ЗначениеПеречисления, Неопределено - значение перечисления.
//  
Функция СтрокуВПеречисление(ПолноеИмя, ЗначениеПеречисления) Экспорт
	
	МетаданныеПеречисления = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
	
	Если МетаданныеПеречисления <> Неопределено
		И МетаданныеПеречисления.ЗначенияПеречисления.Найти(ЗначениеПеречисления) <> Неопределено Тогда
		
		Менеджер = ПолучитьМенеджерОбъектаПоИмени(ПолноеИмя);
		
		Возврат Менеджер[ЗначениеПеречисления];
		
	Иначе
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции

// Получает ссылку на объект базы данных по идентификатору.
// 
// Параметры:
// 	ПолноеИмя - Строка - полное имя объекта метаданных.
// 	Идентификатор - УникальныйИдентификатор - идентификатор ссылки.
// 
// Возвращаемое значение:
//	ЛюбаяСсылка - ссылка на объект базы данных. 
//	
Функция ПолучитьСсылкуПоИдентификатору(ПолноеИмя, Идентификатор)
	
	НайденныйОбъект = РегистрыСведений.СП_ТаблицаСсылок.ПолучитьСсылку(ПолноеИмя, Идентификатор);
	
	Если НайденныйОбъект = Неопределено Тогда
		Попытка
			КлючУникальности = Новый УникальныйИдентификатор(Идентификатор);
		Исключение
			КлючУникальности = Новый УникальныйИдентификатор();
		КонецПопытки;
		
		МенеджерОбъекта = ПолучитьМенеджерОбъектаПоИмени(ПолноеИмя);
		Если МенеджерОбъекта <> Неопределено Тогда
			НайденныйОбъект = МенеджерОбъекта.ПолучитьСсылку(КлючУникальности);
		КонецЕсли;
	КонецЕсли;
	
	Возврат НайденныйОбъект;
	
КонецФункции

// Проверяет элементы отбора регистра.
// 
// Параметры:
//  МетаданныеОбъекта - Метаданные - метаданные объекта.
//  ИмяЭлементаОтбора - Строка - имя элемента отбора.
// 
// Возвращаемое значение:
//  Булево - есть элемент отбора регистра
//  
Функция ЕстьЭлементОтбораРегистра(МетаданныеОбъекта, ИмяЭлементаОтбора, ЭтоГУИД)
	
	РеквизитыИСвойства = СП_СхемыДанных.НоваяСтруктураРеквизитовИСвойств(МетаданныеОбъекта);
	Свойства = РеквизитыИСвойства.Свойства;
	ТипГУИД = Новый ОписаниеТипов("УникальныйИдентификатор");
	
	РеквизитНайден = Ложь;
	
	Если Свойства.Свойство("СтандартныеРеквизиты") Тогда
		Для Каждого СтандартныйРеквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
			РеквизитНайден = СтандартныйРеквизит.Имя = ИмяЭлементаОтбора;
			Если РеквизитНайден Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если Свойства.Свойство("Измерения") Тогда
		ИзмерениеОтбора = МетаданныеОбъекта.Измерения.Найти(ИмяЭлементаОтбора);
		РеквизитНайден = ИзмерениеОтбора <> Неопределено;
		ЭтоГУИД = РеквизитНайден И ИзмерениеОтбора.Тип = ТипГУИД;
	КонецЕсли;
	
	Возврат РеквизитНайден;
	
КонецФункции

// Получает схему данных по имени объекта.
// 
// Параметры:
//  ИмяОбъекта - Строка - полное имя объекта метаданных
//  ПространствоИмен - Неопределено, Строка - пространство имен
// 
// Возвращаемое значение:
//  СП_СхемыДанных.Ссылка, Неопределено - схема данных для обмена.
//
Функция ПолучитьСхемуДанныхПоИмениОбъекта(ИмяОбъекта, ПространствоИмен = Неопределено)
	
	Если ИмяОбъекта = "Справочник.СП_ОбъектыОбмена" 
		ИЛИ ИмяОбъекта = "Справочник.СП_СхемыДанных" Тогда
		
		Возврат СП_СхемыДанных.ПолучитьСхемуДанныхОбъектаВВидеСтроки(ИмяОбъекта); 
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПространствоИмен", ПространствоИмен);
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	СП_СхемыДанных.ТекстСхемы КАК СхемаДанных
	|ИЗ
	|	Справочник.СП_СхемыДанных КАК СП_СхемыДанных
	|ГДЕ
	|	НЕ СП_СхемыДанных.ПометкаУдаления
	|	И СП_СхемыДанных.Наименование = &ПространствоИмен";
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат Неопределено;
		
	Иначе
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		
		Возврат Выборка.СхемаДанных;
		
	КонецЕсли;
	
КонецФункции

// Преобразовать уникальные идентификаторы.
// 
// Параметры:
//  СтруктураОбъекта - Структура - набор загружаемых данных
//  ЗагружаемыйОбъект - ОбъектМетаданных - загружаемый объект метаданных
//  ЭтоРегистр - Булево - признак набора записей регистра
//  
Процедура ПреобразоватьУникальныеИдентификаторы(СтруктураОбъекта, ЗагружаемыйОбъект, ЭтоРегистр = Ложь)
	
	ПоляГУИД = ПолучитьПоляУникальныхИдентификаторовОбъекта(ЗагружаемыйОбъект, ЭтоРегистр);
	
	Для Каждого ИмяРеквизита Из ПоляГУИД.Реквизиты Цикл
		ЗначениеРеквизита = "";
		Если СтруктураОбъекта.Свойство(ИмяРеквизита, ЗначениеРеквизита) Тогда
			ЗначениеРеквизита = Новый УникальныйИдентификатор(ЗначениеРеквизита);
			СтруктураОбъекта.Вставить(ИмяРеквизита, ЗначениеРеквизита);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ТабличнаяЧасть Из ПоляГУИД.ТабличныеЧасти Цикл
		ИмяТабличнойЧасти = ТабличнаяЧасть.Ключ;
		МассивРеквизитовГУИД = ТабличнаяЧасть.Значение;
		ТаблицаОбъекта = Новый ТаблицаЗначений();
		Если СтруктураОбъекта.Свойство(ИмяТабличнойЧасти, ТаблицаОбъекта) Тогда
			Для Каждого ИмяРеквизита Из МассивРеквизитовГУИД Цикл
				Для Каждого Строка Из ТаблицаОбъекта Цикл
					Строка[ИмяРеквизита] = Новый УникальныйИдентификатор(Строка[ИмяРеквизита]);
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Получить поля уникальных идентификаторов объекта.
// 
// Параметры:
//  ЗагружаемыйОбъект - ОбъектМетаданных - загружаемый объект метаданных.
//  ЭтоРегистр - Булево - признак набора записей регистра.
// 
// Возвращаемое значение:
//  Структура - сведения о полях объекта с типом УникальныйИдентификатор:
//     * Реквизиты - Массив - имена реквизитов объекта.
//     * ТабличныеЧасти - Структура:
//         * Ключ - Строка - имя табличной части.
//         * Значение - Массив - имена реквизитов табличной части.
// 
Функция ПолучитьПоляУникальныхИдентификаторовОбъекта(ЗагружаемыйОбъект, ЭтоРегистр)
	
	ПоляГУИД = Новый Структура;
	ПоляГУИД.Вставить("Реквизиты", Новый Массив);
	ПоляГУИД.Вставить("ТабличныеЧасти", Новый Структура);
	
	Если ЭтоРегистр Тогда
		ТаблицаПредставления = Новый ТаблицаЗначений;
		ТаблицаПредставления.Колонки.Добавить("Имя");
		ТаблицаПредставления.Колонки.Добавить("Тип");
		
		ТаблицаНабора = ЗагружаемыйОбъект.Выгрузить();
		Для Каждого Колонка Из ТаблицаНабора.Колонки Цикл
			СтрокаПредставления = ТаблицаПредставления.Добавить();
			СтрокаПредставления.Имя = Колонка.Имя;
			СтрокаПредставления.Тип = Колонка.ТипЗначения;
		КонецЦикла;
		
		ДанныеОбъекта = Новый Структура;
		ДанныеОбъекта.Вставить("Реквизиты", ТаблицаПредставления);
		ДанныеОбъекта.Вставить("ТабличныеЧасти", Новый ТаблицаЗначений);
		
	Иначе
		ДанныеОбъекта = ЗагружаемыйОбъект.Метаданные();
		
	КонецЕсли;
	
	ДобавитьРеквизитыГУИД(ПоляГУИД.Реквизиты, ДанныеОбъекта.Реквизиты);
	Для Каждого ТабЧасть Из ДанныеОбъекта.ТабличныеЧасти Цикл
		КолонкиГУИД = Новый Массив;
		ДобавитьРеквизитыГУИД(КолонкиГУИД, ТабЧасть.Реквизиты);
		Если КолонкиГУИД.Количество() > 0 Тогда
			ПоляГУИД.ТабличныеЧасти.Вставить(ТабЧасть.Имя, КолонкиГУИД);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПоляГУИД;
	
КонецФункции

// Добавить реквизиты ГУИД.
// 
// Параметры:
//  РеквизитыГУИД - Массив - коллекция реквизитов с типом УникальныйИдентификатор.
//  КоллекцияРеквизитов - ТаблицаЗначений, КоллекцияОбъектовМетаданных - коллекция реквизитов объекта метаданных. 
//  
Процедура ДобавитьРеквизитыГУИД(РеквизитыГУИД, КоллекцияРеквизитов)
	
	ТипГУИД = Новый ОписаниеТипов("УникальныйИдентификатор");
	
	Для Каждого Реквизит Из КоллекцияРеквизитов Цикл
		Если Реквизит.Тип = ТипГУИД Тогда
			РеквизитыГУИД.Добавить(Реквизит.Имя);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область JSON

Функция ПреобразоватьОбъектВjson(СсылкаНаОбъект)
    
    Возврат СП_ФормированиеСообщенийОбмена.ПреобразоватьОбъектВjson(СсылкаНаОбъект);
	
КонецФункции


Функция ПолучитьОбъектИзJSON(ТелоСообщения)

    Возврат СП_ФормированиеСообщенийОбмена.ПолучитьОбъектИзJSON(ТелоСообщения);    	

КонецФункции // ПолучитьОбъектИзJSON()

// Проверяет, является ли переданная строка информацией в формате JSON.
// См. также АдресныйКлассификаторСлужебный.ЭтоКонтактнаяИнформацияВJSON
// 
// Параметры:
//  Текст - строка  - строка для проверки на соответвие формату JSON.
// 
// Возвращаемое значение:
//  Булево - Истина - преданная строка - корректный JSON.
//
Функция ЭтоИнформацияВJSON(Знач Текст) Экспорт
    
	Возврат ТипЗнч(Текст) = Тип("Строка") И СтрНачинаетсяС(СокрЛ(Текст), "{"); 
        // ПроверитьСтрокуПоШаблону(Текст,"[{\[]{1}([,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]|"".*?"")+[}\]]{1}");
	
КонецФункции

// Проверяет, является ли переданная строка информацией в формате XML.
// См. также АдресныйКлассификаторСлужебный.ЭтоКонтактнаяИнформацияВXML
// 
// Параметры:
//  Текст - строка  - строка для проверки на соответвие формату XML.
// 
// Возвращаемое значение:
//  Булево - Истина - преданная строка - XML.
//
Функция ЭтоИнформацияВXML(Знач Текст) Экспорт
    
	Возврат ТипЗнч(Текст) = Тип("Строка") И СтрНачинаетсяС(СокрЛ(Текст), "<"); 
	
КонецФункции


// Переводит переданные данные в значения типы которых, пригодны для преоразования JSON.
// Примитивные типы остаются как есть, остальные преобразуются в строки по правилам XMLСтрока.
// 
// Параметры:
//  Данные - Массив, Структура, Примитивный тип, любая ссылка, двоичные данные  - данные для преобразования
//          в формат, пригодный для JSON.
// 
// Возвращаемое значение:
//  Массив, Структура, Примитивный тип - Данные, готовые для преобразования в JSON
//
Функция ПреобразоватьДанныеДляJSON(Данные) Экспорт
	
	БазовыеТипы = Новый Массив;
	БазовыеТипы.Добавить(Тип("Число"));
	БазовыеТипы.Добавить(Тип("Строка"));
	БазовыеТипы.Добавить(Тип("Дата"));
	БазовыеТипы.Добавить(Тип("Булево"));
	
	Если ТипЗнч(Данные) = Тип("Структура") Тогда
		Результат = Новый Структура;
		Для каждого ЭлементСтруктуры Из Данные Цикл
			Результат.Вставить(ЭлементСтруктуры.Ключ, ПреобразоватьДанныеДляJSON(ЭлементСтруктуры.Значение)); 
		КонецЦикла; 
		Возврат Результат;
	ИначеЕсли ТипЗнч(Данные) = Тип("Массив") Тогда 	
		Результат = Новый Массив;
		Для каждого ЭлементМассива Из Данные Цикл
			Результат.Добавить(ПреобразоватьДанныеДляJSON(ЭлементМассива)); 
		КонецЦикла; 
		Возврат Результат;                 
    ИначеЕсли ТипЗнч(Данные) = Тип("Соответствие") Тогда    
		Результат = Новый Соответствие;
		Для каждого ЭлементСтруктуры Из Данные Цикл
			Результат.Вставить(XMLСтрока(ЭлементСтруктуры.Ключ),
                    ПреобразоватьДанныеДляJSON(ЭлементСтруктуры.Значение)); 
		КонецЦикла; 
		Возврат Результат;        
	ИначеЕсли БазовыеТипы.Найти(ТипЗнч(Данные)) <> Неопределено Тогда 	
		Возврат Данные;
	КонецЕсли; 
	
	Возврат XMLСтрока(Данные);
КонецФункции	


// Переобразует переданные для данные в JSON.
// Даты переводятся в формат ISO 8601.
// Данные внутри структур преобразуются в примитивные типы.
// 
// Параметры:
//  Данные - Массив, Структура, Примитивный тип - данные для преобразования в JSON.
// 
// Возвращаемое значение:
//  Строка - Данные, преобразованные в JSON
//
Функция ДанныеВСтрокуJSON(Данные) Экспорт
	
    НастройкиСериализации = Новый НастройкиСериализацииJSON;
    НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.ISO;
    НастройкиСериализации.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.УниверсальнаяДата;
    
    ПараметрыЗаписи = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет);
    
    ЗаписьJSON = Новый ЗаписьJSON;
    ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписи);
    ЗаписатьJSON(ЗаписьJSON, ПреобразоватьДанныеДляJSON(Данные), НастройкиСериализации);
    Результат = ЗаписьJSON.Закрыть();
            
	Возврат Результат;
КонецФункции


// Переобразует из JSON в объект 1С типа Массив, Структура, Примитивный тип.
// 
// Параметры:
//  СтрокаJSON - Строка - данные в формате JSON для преобразования.
//  ИменаСвойствСоЗначениямиДата - Массив, Строка, ФиксированныйМассив -
//      элементы которые содержат имена свойств JSON, для которых нужно вызывать восстановление даты из строки.
// 
// Возвращаемое значение:
//  Массив, Структура, Примитивный Тип - преобразованные из JSON данные. В случае ошибки возвращается пустая структура.
//
Функция ДанныеИзСтрокиJSON(СтрокаJSON, ИменаСвойствСоЗначениямиДата = Неопределено, ОписаниеОшибки = "") Экспорт
	
    Попытка
        ЧтениеJSON = Новый ЧтениеJSON;
        ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
        Результат = ПрочитатьJSON(ЧтениеJSON, Ложь, ИменаСвойствСоЗначениямиДата, ФорматДатыJSON.ISO);
        ЧтениеJSON.Закрыть();    	                                                                           
    Исключение
        ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
        Результат = Новый Структура;
    КонецПопытки;
	
	Возврат Результат;
КонецФункции


// Переобразует двоичные данные в строку в формате Base64.
// В отличии от стандарного преобразования, дополнительно удаляет
// символя переноса строк, которые не понимают некоторые сторонние прасеры.
// 
// Параметры:
//  Данные - Строка - Строка для кодировки в Base64.
// 
// Возвращаемое значение:
//  Строка - строка в кодировка base64.
//
Функция СтрокаВBase64(Данные) Экспорт
	
	СтрокаВДвоичныхДанных = ПолучитьДвоичныеДанныеИзСтроки(Данные);
	СтрокаВBase64 = Base64Строка(СтрокаВДвоичныхДанных);
	СтрокаВBase64 = СтрЗаменить(СтрокаВBase64,Символы.ПС,"");
	СтрокаВBase64 = СтрЗаменить(СтрокаВBase64,Символы.ВК,"");
	
	Возврат СтрокаВBase64;
	
КонецФункции


// Формирует пакет для обмена для передачи,
// добавляя служебные заголовки к переданным данным
//
// Параметры:
//  Ссылка  - <ДокументСсылка, СправочникСсылка> - Ссылка на пердаваемый объект
//  Действие  - Строка - описание действия "insert", "update", "delete" 
//  ДанныеШапки  - Структура - Структура с данными шапки объекта 
//  ДанныеТабличнойЧасти  - Структура вида "ИмяТабличнойЧасти": Строка, ЗначениеТабличнойЧасти:ТаблицаЗначений, МассивСтруктур - данные табличной части 
//
// Возвращаемое значение:
//   Строка   - Строка JSON с сформированным пакетом для передачи
//
Функция ДанныеВПакетОбмена(СсылкаНаОбъект, Действие, ДанныеШапки = Неопределено, ДанныеТабличнойЧасти = Неопределено) Экспорт   
    
    ПоддерживаемыеОперации = ПоддерживаемыеОперации();
    Если ПоддерживаемыеОперации.Найти(НРег(Действие)) = Неопределено Тогда
        ВызватьИсключение СтрШаблон("Неподдерживаемая операция %1", Действие);
    КонецЕсли;
    
    ПакетОбмена = Новый Структура("head, caption, detail");
    
    // Заголовок
    ДанныеЗаголовкаПакета = Новый Структура("object_type, subtype, type_action, date_action, version");    
    
    МетаданныеОбъекта = СсылкаНаОбъект.Метаданные();
    ДанныеЗаголовкаПакета.subtype     = МетаданныеОбъекта.Имя;                    
    ДанныеЗаголовкаПакета.type_action = Действие;                                                      
    ДанныеЗаголовкаПакета.version = "1.0";
    
    Если ОбщегоНазначения.ЭтоДокумент(МетаданныеОбъекта) Тогда 
        ДатаДокумента = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, "Дата");
        ДанныеЗаголовкаПакета.object_type = "document";                    
        ДанныеЗаголовкаПакета.date_action = ДатаДокумента;                    
    ИначеЕсли ОбщегоНазначения.ЭтоСправочник(МетаданныеОбъекта) Тогда
        ДанныеЗаголовкаПакета.object_type = "reference";                    
        ДанныеЗаголовкаПакета.date_action = ТекущаяДатаСеанса();
	ИначеЕсли ОбщегоНазначения.ЭтоПланВидовХарактеристик(МетаданныеОбъекта) Тогда
		//Пока закосим по справочник)))
		ДанныеЗаголовкаПакета.object_type = "reference";                    
        ДанныеЗаголовкаПакета.date_action = ТекущаяДатаСеанса();
    Иначе
        ВызватьИсключение СтрШаблон("Неподдерживаемы объект для обмена %1", СсылкаНаОбъект);    
    КонецЕсли;
    
    // Шапка
    ДанныеШапкиПакета = Новый Структура;
    Если ДанныеШапки <> Неопределено Тогда
        ДанныеШапкиПакета = ДанныеШапки;    
    КонецЕсли;        
    
    // Табличная часть       
    ДанныеТабличнойЧастиПакета = Новый Структура;
    Если ДанныеТабличнойЧасти <> Неопределено Тогда
        Для каждого ТЧ Из ДанныеТабличнойЧасти Цикл
            ИмяТЧ = ТЧ.Ключ;
            Если ТипЗнч(ТЧ.Значение) = Тип("ТаблицаЗначений") Тогда
                ДанныеТЧ = ОбщегоНазначения.ТаблицаЗначенийВМассив(ДанныеТабличнойЧасти);
            ИначеЕсли ТипЗнч(ТЧ.Значение) = Тип("Массив") Тогда	
                ДанныеТЧ = ОбщегоНазначения.СкопироватьРекурсивно(ДанныеТабличнойЧасти);
            Иначе
                ВызватьИсключение СтрШаблон("Неподдерживаемый тип табличной части пакета %1", ТипЗнч(ДанныеТабличнойЧасти));
            КонецЕсли;
            ДанныеТабличнойЧастиПакета.Вставить(ИмяТЧ, ДанныеТЧ);
        КонецЦикла;
    КонецЕсли;    
    
    ПакетОбмена.head    = ДанныеЗаголовкаПакета;
    ПакетОбмена.caption = ДанныеШапкиПакета;
    ПакетОбмена.detail  = ДанныеТабличнойЧастиПакета;
    
    Возврат ДанныеВСтрокуJSON(ПреобразоватьДанныеДляJSON(ПакетОбмена));     
    
КонецФункции // ДанныеВПакетОбмена()


// Проверяет полученную структуру, на наличие соответствие
// стандарту пакета обмена справочниками и документами.                        
// В передаваемой структур должны быть следующие реквизиты:
//  head - тип Стрeктура
//  caption - тип Структура
//  detail - тип массив
//
// Параметры:
//  ДанныеПакета  - Структура - Структура с для проверки соответсвия
//
// Возвращаемое значение:
//   Булево   - да - Переданная структура содержит все необходимые реквизиты заданных типов,
//              инче - нет.
//
Функция ПроверитьСтруктуруПакета(ДанныеПакета) Экспорт
    
    Результат = Истина;
    Если ТипЗнч(ДанныеПакета) <> Тип("Структура") Тогда
        Возврат Ложь;
    КонецЕсли;       
    
    МассивТипСтруктура = Новый Массив;
    МассивТипСтруктура.Добавить(Тип("Структура"));
    
    МассивТипСтруктураМассив = ОбщегоНазначения.СкопироватьРекурсивно(МассивТипСтруктура);
    МассивТипСтруктураМассив.Добавить(Тип("Массив"));
    
    ПроверяемыеСвойства = Новый Структура;
    ПроверяемыеСвойства.Вставить("head", МассивТипСтруктура);
    ПроверяемыеСвойства.Вставить("caption", МассивТипСтруктура);
    ПроверяемыеСвойства.Вставить("detail", МассивТипСтруктураМассив);
    
    Результат = ВсеСоответствуют(ПроверяемыеСвойства, 
            "Параметр1.Свойство(Элемент.Ключ) И Элемент.Значение.Найти(ТипЗнч(Параметр1[Элемент.Ключ])) <> Неопределено ", ДанныеПакета);
    
    Возврат Результат;
КонецФункции // ПроверитьСтуртуруПакета(ДанныеПакета)()


// Возвращает список опддерживаемых операций обмена
//
// Параметры:
//  нет
//
// Возвращаемое значение:
//   Массив   - список строк с именами поддерживаемых операций.
//
Функция ПоддерживаемыеОперации() Экспорт
    
    ПоддерживаемыеОперации = Новый Массив;
    ПоддерживаемыеОперации.Добавить("insert");
    ПоддерживаемыеОперации.Добавить("update");
    ПоддерживаемыеОперации.Добавить("delete");

	Возврат ПоддерживаемыеОперации;

КонецФункции // ()

#КонецОбласти

#Область Сервис

// Проверяет строку на соответсвие шаблону по правилам регулярных выражений regexp.test
// Пример, ПроверитьСтрокуПоШаблону("01.01.2012","\d{2}\.\d{2}\.\d{4}"));
//
// Параметры:
//  СтрокаДляПроверки  - Строка  - строка, которую надо проверить
//  СтрокаШаблон  - Строка  - шаблон, содержащий регулярные выражение regexp.test
// 
// Возвращаемое значение:
//  Булево - да, если строка соответсвует шаблону, нет, если не соотвествует
//
Функция ПроверитьСтрокуПоШаблону(СтрокаДляПроверки, СтрокаШаблон) Экспорт
    Чтение = Новый ЧтениеXML;
    Чтение.УстановитьСтроку(СтрШаблон(
                "<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
                |<package targetNamespace=""sample-my-package"">
                |<valueType name=""testtypes"" base=""xs:string"">
                |<pattern>%1</pattern>
                |</valueType>
                |<objectType name=""TestObj"">
                |<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
                |</objectType>
                |</package>
                |</Model>", СтрокаШаблон));

    Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
    МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
    Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
    Тест = МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));

    Попытка
        Тест.TestItem = СтрокаДляПроверки;
        Возврат Истина
    Исключение
        Возврат Ложь
    КонецПопытки;

КонецФункции


// Формирование структуры для первой (единственной) записи результата запроса
//
//Параметры:
//	РезультатЗапроса - РезультатЗапроса, источник данных
//
//Возвращаемое значение: 
//	Структура - Набор ключей повторяет набор колонок результат запроса, значения заполняются
//				значениями первой записи выборки
//
Функция РезультатЗапросаВСтруктуру(РезультатЗапроса) Экспорт
	
	СтруктураРезультат = Новый Структура;   
    
    Если РезультатЗапроса.Пустой() Тогда
        Возврат СтруктураРезультат;
    КонецЕсли;
    
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();	

	Для каждого Колонка Из РезультатЗапроса.Колонки Цикл
		
		Если Выборка.Количество() = 0 Тогда
			МассивТипов = Колонка.ТипЗначения.Типы();
			ОбщегоНазначенияКлиентСервер.УдалитьЗначениеИзМассива(МассивТипов, Тип("Null"));
			ОписаниеТиповБезNULL = Новый ОписаниеТипов(МассивТипов);
			ЗначениеПоля = ОписаниеТиповБезNULL.ПривестиЗначение();
			
		Иначе
			ЗначениеПоля = Выборка[Колонка.Имя];		
			
		КонецЕсли;  
		
		СтруктураРезультат.Вставить(Колонка.Имя, ЗначениеПоля);		
	КонецЦикла; 
	
	Возврат СтруктураРезультат;
	
КонецФункции

#КонецОбласти     

#Область РаботаСКоллекциями

// ВсеСоответствуют(МассивРеквизитов, "ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Параметр1, Элемент)", Документ);
Функция ВсеСоответствуют(Коллекция, Код, Параметр1 = Неопределено, Параметр2 = Неопределено, Параметр3 = Неопределено) Экспорт
	Результат = Истина;
	Для Каждого Элемент из Коллекция Цикл
		Результат = (Результат И Вычислить(Код));	
		Если Не Результат Тогда
			Прервать;
		КонецЕсли;	
	КонецЦикла;
	Возврат Результат;		
КонецФункции	


// ЛюбойСоответствует(СтруктураРеквизитов, "Не ЗначениеЗаполнено(Элемент.Значение)");
Функция ЛюбойСоответствует(Коллекция, Код, Параметр1 = Неопределено, Параметр2 = Неопределено, Параметр3 = Неопределено) Экспорт
	Результат = Ложь;
	Для Каждого Элемент из Коллекция Цикл
		Результат = (Результат ИЛИ Вычислить(Код));	
		Если Результат Тогда
			Прервать;
		КонецЕсли;	
	КонецЦикла;
	Возврат Результат;		
КонецФункции	

// Структура1 = Новый Струкутра("Наименование, Количество", "Имя1", 10);
// Массив1 = Новый Массив; Массив1.Добавить(Структура1);
// ПересечениеМножеств(МассивСтруктур1, МассивСтруктур2, "Элемент.Наименование = Параметр1.Наименование И Элемент.Количество = Параметр1.Количество")
// ПересечениеМножеств(ТаблицаЗначений1, ТаблицаЗначений2, "Элемент.Нимаенование = Параметр1.Наименование")
// Использование в УсоловниеСранения: "Элемент" - из множества2, "параметр1" - из множества1
Функция ПересечениеМножеств(Множество1, Множество2, УсловиеСравнения = "", Разность = Ложь) Экспорт
	
	Результат = Новый Массив;
	
	ПростоеСравнение = ПустаяСтрока(УсловиеСравнения);

	Для Каждого Элемент Из Множество1 Цикл

		Если ПростоеСравнение Тогда
			Найдено = (Множество2.Найти(Элемент) <> Неопределено);
		Иначе
			Найдено = ЛюбойСоответствует(Множество2, УсловиеСравнения, Элемент)
		КонецЕсли;
		Если Разность Тогда
			Найдено = Не Найдено;
		КонецЕсли;	

		Если Найдено Тогда
			Результат.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Фильтр(СписокПользователей, "Не Элемент.ПолныеПрава", "Элемент.УникальныйИдентификатор")
Функция Фильтр(Множество1, УсловияОтбора, ФормулаРезультата = "") Экспорт
	Результат = Новый Массив;
	
	ПростоеДобавление = ПустаяСтрока(ФормулаРезультата);
	Для Каждого Элемент Из Множество1 Цикл

		Подходит = Вычислить(УсловияОтбора);
		Если Подходит Тогда                 
			Если ПростоеДобавление Тогда
				Результат.Добавить(Элемент);	
			Иначе
				Результат.Добавить(Вычислить(ФормулаРезультата));
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции


#КонецОбласти
