#Область ПрограммныйИнтерфейс

// Выполняет регистрацию сообщений для обмена данными.
// 
// Параметры:
//  Источник - ЛюбаяСсылка, НаборЗаписей - ссылка на измененный объект или набор записей.
//
Процедура ЗарегистрироватьИсходящееСообщение(Источник) Экспорт

	ИмяОбъекта = Источник.Метаданные().ПолноеИмя();
	ЭтоСхемаДанных = (ИмяОбъекта = "Справочник.СП_СхемыДанных");
	Если Не ОбъектЗарегистрированДляОбмена(ИмяОбъекта) Тогда
		Возврат;
	КонецЕсли;

	НовоеСообщение = СоздатьСообщениеОбмена(Источник, ИмяОбъекта);

	НовоеСообщение.ТипСообщения       = Перечисления.СП_ТипыСообщений.Исходящее;
	НовоеСообщение.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Зарегистрировано;
	НовоеСообщение.СсылкаНаОбъект     = ПолучитьСсылкуНаОбъект(Источник, ИмяОбъекта);
	НовоеСообщение.ИмяОбъекта         = ИмяОбъекта;
	НовоеСообщение.ЭтоСхема           = ЭтоСхемаДанных;
	НовоеСообщение.ТелоСообщения      = "";
	НовоеСообщение.Кластер            = Справочники.СП_Кластеры.ПустаяСсылка();
	НовоеСообщение.ИмяТопика          = "";

	Попытка
		НовоеСообщение.Записать();

	Исключение
		ВызватьИсключение "Не удалось зарегистрировать исходящее сообщение!
						  |" + ОписаниеОшибки();

	КонецПопытки;

КонецПроцедуры

// Выполняет обработку зарегистрированных исходящих сообщений.
//
Процедура ВыполнитьОбработкуИсходящихСообщений(json = Ложь) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("СостояниеСообщения", Перечисления.СП_СостоянияСообщений.Зарегистрировано);
	СообщенияВ_РС = Константы.СП_каф_СообщенияВРегистре.Получить();
	Если НЕ СообщенияВ_РС Тогда
		Запрос.Текст =
		"ВЫБРАТЬ
		|	СП_СообщенияОбмена.Ссылка КАК Ссылка,
		|	СП_СообщенияОбмена.ЭтоСхема КАК ЭтоСхемаДанных,
		|	СП_СообщенияОбмена.СсылкаНаОбъект КАК СсылкаНаОбъект,
		|	СП_СообщенияОбмена.ИмяОбъекта КАК ИмяОбъекта,
		|	СП_СообщенияОбмена.Отбор.(
		|		Имя КАК Имя,
		|		Значение КАК Значение) КАК Отбор
		|ИЗ
		|	Справочник.СП_СообщенияОбмена КАК СП_СообщенияОбмена
		|ГДЕ
		|	НЕ СП_СообщенияОбмена.ПометкаУдаления
		|	И СП_СообщенияОбмена.СостояниеСообщения = &СостояниеСообщения";
	Иначе
		Запрос.Текст =
		"ВЫБРАТЬ
		|	Неопределено КАК Ссылка,
		|	СП_СообщенияОбмена.ЭтоСхема КАК ЭтоСхемаДанных,
		|	СП_СообщенияОбмена.СсылкаНаОбъект КАК СсылкаНаОбъект,
		|	СП_СообщенияОбмена.ИмяОбъекта КАК ИмяОбъекта,
		|	Неопределено КАК Отбор
		|ИЗ
		|	РегистрСведений.СП_СообщенияОбмена КАК СП_СообщенияОбмена
		|ГДЕ
		|	СП_СообщенияОбмена.СостояниеСообщения = &СостояниеСообщения";
	КонецЕсли;
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат;
	КонецЕсли;

	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл

		Источник = ПолучитьИсточникСообщенияОбмена(Выборка);
		ИмяОбъекта = Выборка.ИмяОбъекта;
		ЭтоСхемаДанных = Выборка.ЭтоСхемаДанных;
		СообщениеДляОбработки = Выборка.Ссылка;

		ТаблицаОтправки = ПолучитьТаблицуОтправки(Источник, ИмяОбъекта, ЭтоСхемаДанных);

		Для Каждого СтрокаОтправки Из ТаблицаОтправки Цикл

			ИдентификаторСообщения = XMLСтрока(Новый УникальныйИдентификатор);
			
			Форматjson = НЕ ЗначениеЗаполнено(СтрокаОтправки.СхемаДанных);// Лопатин. Определения формата отправляемого сообщения
			ТелоСообщения = СП_ОбменДанными.СформироватьТелоСообщения(
					Источник, ИдентификаторСообщения, СтрокаОтправки.СхемаДанных, Форматjson);

			НовоеСообщение = СоздатьСообщениеОбмена(Источник, ИмяОбъекта, СообщениеДляОбработки);

			НовоеСообщение.ТипСообщения                = Перечисления.СП_ТипыСообщений.Исходящее;
			НовоеСообщение.СостояниеСообщения          = Перечисления.СП_СостоянияСообщений.Новое;
			НовоеСообщение.ДатаВремяСообщения          = ТекущаяДатаСеанса();
			НовоеСообщение.ДатаСообщенияВМиллисекундах = ТекущаяУниверсальнаяДатаВМиллисекундах();
			НовоеСообщение.ИдентификаторСообщения      = ИдентификаторСообщения;
			НовоеСообщение.СсылкаНаОбъект              = ПолучитьСсылкуНаОбъект(Источник, ИмяОбъекта);
			НовоеСообщение.ИмяОбъекта                  = ИмяОбъекта;
			НовоеСообщение.ТелоСообщения               = ТелоСообщения;
			НовоеСообщение.Кластер                     = СтрокаОтправки.Кластер;
			НовоеСообщение.ИмяТопика                   = СтрокаОтправки.ИмяТопика;
			НовоеСообщение.ЭтоСхема                    = ЭтоСхемаДанных;

			Попытка
				НовоеСообщение.Записать();

			Исключение
				ВызватьИсключение "Не удалось зарегистрировать исходящее сообщение!
								  |" + ОписаниеОшибки();

			КонецПопытки;

		КонецЦикла;

	КонецЦикла;

КонецПроцедуры

// Выполняет отправку зарегистрированных сообщений.
// 
// Параметры:
//  Кластер - СправочникСсылка.СП_Кластеры - кластер для обмена.
//
Процедура ВыполнитьОтправкуИсходящихСообщений(Кластер) Экспорт

	Если Кластер = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ТипИсходящее = Перечисления.СП_ТипыСообщений.Исходящее;
	ВыборкаПоСообщениям = ПолучитьВыборкуСообщенийДляОбработки(Кластер, ТипИсходящее);
	Если ВыборкаПоСообщениям = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ВариантыСостояния = Перечисления.СП_СостоянияСообщений;
	БрокерыКафка      = Кластер.Брокеры.Выгрузить();
	ПараметрыКафка    = Справочники.СП_Кластеры.ПараметрыКонфигурацииВПримитивномВиде(Кластер.ПараметрыКонфигурации);
	
	Если Кластер.ЧерезRestAPI Тогда // Лопатин. Основной сценарий рабоы кафки - через RestAPI. Алгоритмы работы через компоненту оставлены "на всякий случай".
		КлиентКафка = Обработки.СП_КлиентКафкаRestAPI.НовыйОбъект(БрокерыКафка, ПараметрыКафка, Кластер.Таймаут);
	Иначе
		КлиентКафка = Обработки.СП_КлиентКафка.НовыйОбъект(БрокерыКафка, ПараметрыКафка);
	КонецЕсли;
	КлиентКафка.СоздатьОтправителя();

	Пока ВыборкаПоСообщениям.Следующий() Цикл

		СообщениеСсылка = ВыборкаПоСообщениям.Сообщение;
		СообщениеОбъект = СообщениеСсылка.ПолучитьОбъект();

		Попытка
			КлиентКафка.ОтправитьСообщение(СообщениеСсылка.ТелоСообщения, ВыборкаПоСообщениям.ИмяТопика);
			ТекстОшибки = "";
			СостояниеОтправки = ВариантыСостояния.Отправлено;

		Исключение
			ТекстОшибки = ОписаниеОшибки();
			СостояниеОтправки = ВариантыСостояния.Ошибка;

		КонецПопытки;

		СообщениеОбъект.СостояниеСообщения = СостояниеОтправки;
		СообщениеОбъект.ДатаВремяОбработки = ТекущаяДатаСеанса();
		СообщениеОбъект.ТекстОшибки = ТекстОшибки;

		Попытка
			СообщениеОбъект.Записать();

		Исключение
			ШаблонОшибки = "Произошла ошибка при попытке записи сообщения: %1
						   |Состояние сообщения и время обработки не будут изменены.
						   |Причина: %2";

			ТекстОшибки = СтрШаблон(ШаблонОшибки, СообщениеСсылка.ИдентификаторСообщения, ОписаниеОшибки());

			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = ТекстОшибки;
			Сообщение.Сообщить();

		КонецПопытки;

	КонецЦикла;

КонецПроцедуры

// Выполняет получение входящих сообщений.
// 
// Параметры:
//  Кластер - СправочникСсылка.СП_Кластеры - кластер для обмена.
//
Процедура ВыполнитьПолучениеВходящихСообщений(Кластер) Экспорт

	Если Кластер = Неопределено Тогда
		Возврат;
	КонецЕсли;

	БрокерыКафка   = Кластер.Брокеры.Выгрузить();
	ПараметрыКафка = Справочники.СП_Кластеры.ПараметрыКонфигурацииВПримитивномВиде(Кластер.ПараметрыКонфигурации);
	
	Если Кластер.ЧерезRestAPI Тогда // Лопатин. Основной сценарий рабоы кафки - через RestAPI. Алгоритмы работы через компоненту оставлены "на всякий случай".
		КлиентКафка = Обработки.СП_КлиентКафкаRestAPI.НовыйОбъект(БрокерыКафка, ПараметрыКафка, Кластер.Таймаут);
	Иначе
		КлиентКафка = Обработки.СП_КлиентКафка.НовыйОбъект(БрокерыКафка, ПараметрыКафка);
    КонецЕсли;
    
    ДанныеПолучателя = КлиентКафка.СоздатьПолучателя();
    
    
	ТаблицаТем = ПолучитьТемыДляОбработки(Кластер);
    

    Если НЕ Кластер.ЧерезRestAPI Тогда
        
        Для Каждого Строка Из ТаблицаТем Цикл
            
            КоличествоПолученных = 0;
            Смещение = 0;
            
            КлиентКафка.Подписаться(Строка.Тема);
            
            ЭтоСхемаДанных = (Строка.Тема = Кластер.ТемаДляСхем);
            
            Сообщение = "";
            КлючСообщения = "";
            МоментВремени = 0;
            
            Пока КлиентКафка.ПолучитьСообщение(Сообщение, КлючСообщения, МоментВремени) Цикл
                
                Попытка
                    СоздатьВходящееСообщение(Сообщение, Строка, Кластер, МоментВремени, ЭтоСхемаДанных);
                    КоличествоПолученных = КоличествоПолученных + 1;
                    
                    КлиентКафка.ЗафиксироватьСмещение();
                    
                Исключение
                    ВызватьИсключение "Не удалось зарегистрировать входящее сообщение!
                    |" + ОписаниеОшибки();
                    Прервать;
                КонецПопытки;
            КонецЦикла;
        КонецЦикла;
        
    Иначе
        
        // REST API подписывает одно подписчика на все темы 
        СтруктураСмещений = Новый Структура("Смещение, КоличествоПолученных", 0,0);

        СмещенияТем = Новый Соответствие;
        МассивТем = ТаблицаТем.ВыгрузитьКолонку("Тема");
        Для каждого Тема Из МассивТем Цикл
            СмещенияТем.Вставить(Тема, ОбщегоНазначения.СкопироватьРекурсивно(СтруктураСмещений));
        КонецЦикла;
        
    
        Запрос = Новый Запрос;
        Запрос.Текст = 
            "ВЫБРАТЬ
            |   СП_каф_СессииОбменаСрезПоследних.Кластер КАК Кластер,
            |   СП_каф_СессииОбменаСрезПоследних.Топик КАК Топик,
            |   СП_каф_СессииОбменаСрезПоследних.КоличествоСообщений КАК КоличествоСообщений,
            |   СП_каф_СессииОбменаСрезПоследних.Смещение КАК Смещение
            |ИЗ
            |   РегистрСведений.СП_каф_СессииОбмена.СрезПоследних(
            |           &Период,
            |           Кластер = &Кластер
            |               И Топик В (&МассивТопиков)) КАК СП_каф_СессииОбменаСрезПоследних";
        
        Запрос.УстановитьПараметр("Период", ТекущаяДатаСеанса());
        Запрос.УстановитьПараметр("Кластер", Кластер);
        Запрос.УстановитьПараметр("МассивТопиков", МассивТем);
        
        ПоследниеСессии = Запрос.Выполнить().Выгрузить();
       
        
        КлиентКафка.Подписаться(МассивТем);

        
        Сообщение = "";
        КлючСообщения = "";
        МоментВремени = 0;
        
        Пока КлиентКафка.ПолучитьСообщение(Сообщение, КлючСообщения, МоментВремени) Цикл
            Попытка
                
                ДанныеКафки = СП_ОбменДанными.ДанныеИзСтрокиJSON(Сообщение);
                Если ДанныеКафки.Количество() = 0 Тогда
                    Прервать;
                КонецЕсли;
                Если ТипЗнч(ДанныеКафки) = Тип("Массив") Тогда
                    Для каждого Сообщение Из ДанныеКафки Цикл
                        Тема = Сообщение.topic;
                        Смещение = Сообщение.offset;
                        
                        ДанныеПоследнейСессии = ПоследниеСессии.Найти(Тема, "Топик");
                        Если ДанныеПоследнейСессии <> Неопределено Тогда
                            Если ДанныеПоследнейСессии.Смещение >= Смещение Тогда
                                Продолжить;
                            КонецЕсли;
                        КонецЕсли;
                        
                        Строка = ТаблицаТем.Найти(Тема, "Тема");
                        ЭтоСхемаДанных = (Тема = Кластер.ТемаДляСхем);
                        
                        Если СП_ОбменДанными.ЭтоИнформацияВJSON(Сообщение.Value) ИЛИ 
                            СП_ОбменДанными.ЭтоИнформацияВXML(Сообщение.Value) Тогда
                            СтрокаСообщения = Сообщение.Value;
                        Иначе
                            СтрокаСообщения = ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(Сообщение.Value));
                        КонецЕсли;
                        
                        СоздатьВходящееСообщение(СтрокаСообщения, Строка, Кластер, МоментВремени, ЭтоСхемаДанных);
                        СмещенияТем[Тема].Смещение = Смещение;
                        СмещенияТем[Тема].КоличествоПолученных = СмещенияТем[Тема].КоличествоПолученных + 1;
                        
                    КонецЦикла;
                КонецЕсли;
                                                
            Исключение
                ВызватьИсключение "Не удалось зарегистрировать входящее сообщение!
                |" + ОписаниеОшибки();
                Прервать;
            КонецПопытки;
            
        КонецЦикла;
        
        Для каждого Строка Из ТаблицаТем Цикл
            
            КоличествоПолученных = СмещенияТем[Строка.Тема].КоличествоПолученных;
            Смещение = СмещенияТем[Строка.Тема].Смещение;
            
            Если Смещение > 0 Тогда
            
                СтруктураПараметров = Новый Структура("Кластер, Топик, КоличествоСообщений, Смещение, Период",
                Кластер, Строка.Тема, КоличествоПолученных, Смещение, ТекущаяДатаСеанса());
                РегистрыСведений.СП_каф_СессииОбмена.ЗафиксироватьСессию(СтруктураПараметров);
            	            
            КонецЕсли;
            
            
        КонецЦикла;
        
        // для REST PROXY удаляем коннект подписчика
        // если не удалить - будет обрушение REST PROXY на перебалансировке
        КлиентКафка.УдалитьПолучателя(ДанныеПолучателя);
    КонецЕсли;


КонецПроцедуры

// Выполняет обработку полученных входящих сообщений.
//
Процедура ВыполнитьОбработкуВходящихСообщений(json = Ложь,МассивОбъектов=неопределено) Экспорт
	
	ллл_ВыполнитьОбработкуВходящихСообщений(json,МассивОбъектов);
	
	возврат;
	//Далее - старая версия
	
	
	ТипВходящее = Перечисления.СП_ТипыСообщений.Входящее;

	МассивКластеров = ПолучитьКластерыОбмена();
	Для Каждого Кластер Из МассивКластеров Цикл

		ВыборкаПоСообщениям = ПолучитьВыборкуСообщенийДляОбработки(Кластер, ТипВходящее);
		Если ВыборкаПоСообщениям = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Пока ВыборкаПоСообщениям.Следующий() Цикл
			СообщениеСсылка = ВыборкаПоСообщениям.Сообщение;
			Попытка
                
                ЭтоСообщениеJson = СП_ОбменДанными.ЭтоИнформацияВJSON(ВыборкаПоСообщениям.ТелоСообщения);
                Успех = Ложь;
                
				//// Сообщения в формате JSON пробуем обновить через механизм шаблонов в справочнике инт_СоответствиеОбъектовЗначениямИнтеграции
				//Если ЭтоСообщениеJson Тогда
				//    //Конилов. Будем читать сообщения обмена асинхронно 
				//	инт_ПроцедурыПоискаСоответствийОбмена.ОбработатьСП_СообщениеВФоне(СообщениеСсылка, Неопределено,ложь);
				//КонецЕсли;
                
				// Если не получилось пробуем через исходный механизм.
				Если Не Успех Тогда     
					СообщениеОбъект=ВыборкаПоСообщениям.Сообщение.ПолучитьОбъект();
					ДанныеСообщения = СП_ОбменДанными.ПрочитатьТелоСообщения(ВыборкаПоСообщениям.ТелоСообщения, ЭтоСообщениеJson);
					ЗаписатьРезультатОбработки(ДанныеСообщения, СообщениеОбъект);
					
					Если НадоВыполнитьДальнейшиеДействия(СообщениеОбъект.СсылкаНаОбъект) тогда
							тз=Новый ТаблицаЗначений();
							тз.Колонки.Добавить("Сообщение");
							тз.Колонки.Добавить("необходимыДальнейшиеДействия");
							стр=тз.Добавить();
							стр.необходимыДальнейшиеДействия=истина;
							стр.Сообщение=СообщениеОбъект.Ссылка;
							ВыполнениеДальнейшихДействийВФоне(тз);
					КонецЕсли;
					
				КонецЕсли;
			Исключение 
				СообщениеОбъект=СообщениеСсылка.ПолучитьОбъект();
				ТекстОшибки = СтрШаблон("Не удалось обработать входящее сообщение, по причине:
										|%1", ОписаниеОшибки());
				ЗаписьЖурналаРегистрации("Интеграция.ОбработкаВходящегоСообщения", УровеньЖурналаРегистрации.Ошибка, СообщениеОбъект, СообщениеОбъект.Ссылка, ТекстОшибки);
				СообщениеОбъект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Ошибка;
				СообщениеОбъект.ТекстОшибки = ТекстОшибки;
				СообщениеОбъект.Записать();
			КонецПопытки;
		КонецЦикла;

	КонецЦикла;

КонецПроцедуры


Функция СформирироватьМассивСообщенийДляРазбора(Кластер) экспорт
	
	ТипСообщения = Перечисления.СП_ТипыСообщений.Входящее;
	МассивОбъектов=Новый Массив();
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Кластер", Кластер);
	Запрос.УстановитьПараметр("ТипСообщения", ТипСообщения);
    Запрос.Текст =
	"ВЫБРАТЬ
	|	СП_Сообщения.Ссылка КАК Сообщение
	|ИЗ
	|	Справочник.СП_СообщенияОбмена КАК СП_Сообщения
	|ГДЕ
	|	НЕ СП_Сообщения.ПометкаУдаления
	|	И НЕ СП_Сообщения.РезультатВ1С = ""Обрабатывается""
	|	И СП_Сообщения.СостояниеСообщения = ЗНАЧЕНИЕ(Перечисление.СП_СостоянияСообщений.Новое)
	|	И СП_Сообщения.Кластер = &Кластер
	|	И СП_Сообщения.ТипСообщения = &ТипСообщения";
	
	
	Результат = Запрос.Выполнить();
	Выборка=Результат.Выбрать();
	пока Выборка.Следующий() цикл
		МассивОбъектов.Добавить(Выборка.Сообщение);
		СП_Объект=Выборка.Сообщение.ПолучитьОбъект();
		СП_Объект.РезультатВ1С="Обрабатывается";
		СП_Объект.Записать();
	КонецЦикла;

	
КонецФункции

Процедура ллл_ВыполнитьОбработкуВходящихСообщений(json=ложь,МассивОбъектов=неопределено,ВыводитьОтладочныеСообщения=ложь,Правило=неопределено) Экспорт
	
	МассивКластеров = ПолучитьКластерыОбмена();
	Для Каждого Кластер Из МассивКластеров Цикл 
		
		
		Если не ЗначениеЗаполнено(МассивОбъектов) тогда
			МассивОбъектов=СформирироватьМассивСообщенийДляРазбора(Кластер);
			
		КонецЕсли;
		
		
		ТаблицаСправочниковДляЗагрузки=ллл_ПолучитьУпорядоченнуюТаблицуСправочниковДляЗагрузки(Кластер,МассивОбъектов);
		ЗапущеноРаспознаваниеДокументов=ложь;
		Если ТаблицаСправочниковДляЗагрузки.Количество()=0 тогда 
			ллл_РаспознатьДокументы(Кластер,json,МассивОбъектов,ВыводитьОтладочныеСообщения,Правило);
			ЗапущеноРаспознаваниеДокументов=истина;
			Продолжить;
		конецЕсли;
		для каждого стр из ТаблицаСправочниковДляЗагрузки цикл
			Если стр.Приоритет>5 и не ЗапущеноРаспознаваниеДокументов тогда
					ЗапущеноРаспознаваниеДокументов=истина;
					ллл_РаспознатьДокументы(Кластер,json,МассивОбъектов,ВыводитьОтладочныеСообщения,Правило);
			КонецЕсли;
				
			ЭтоСообщениеJson = СП_ОбменДанными.ЭтоИнформацияВJSON(стр.ТелоСообщения);
			Если ЭтоСообщениеJson Тогда 
				СообщениеОбъект=стр.Сообщение.ПолучитьОбъект();
				Попытка

					инт_ПроцедурыПоискаСоответствийОбмена.ОбработатьСП_Сообщение(СообщениеОбъект, Правило,ВыводитьОтладочныеСообщения);
				
				исключение
					
					
					ТекстОшибки = СтрШаблон("Не удалось обработать входящее сообщение %1, по причине:
										|%2", Строка(СообщениеОбъект.Код),ОписаниеОшибки());

					ЗаписьЖурналаРегистрации("Интеграция.ОбработкаВходящегоСообщения", УровеньЖурналаРегистрации.Ошибка, СообщениеОбъект, СообщениеОбъект.Ссылка, ТекстОшибки);
					СообщениеОбъект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Ошибка;
					СообщениеОбъект.ТекстОшибки = ТекстОшибки;
					СообщениеОбъект.Результатв1С="Ошибка. Объект не записан";
					СообщениеОбъект.Записать();
	                
				
				
				КонецПопытки
            КонецЕсли;

		КонецЦикла;
		Если не ЗапущеноРаспознаваниеДокументов тогда
					ЗапущеноРаспознаваниеДокументов=истина;
					ллл_РаспознатьДокументы(Кластер,json,МассивОбъектов,ВыводитьОтладочныеСообщения,Правило);
		КонецЕсли;
		
	КонецЦикла;
КонецПроцедуры 

Процедура ллл_РаспознатьДокументыВФоне(Кластер,json,МассивОбъектов)  экспорт
	ТаблицаДокументовДляЗагрузки=ллл_ПолучитьУпорядоченнуюТаблицуДокументовДляЗагрузки(Кластер,МассивОбъектов);
	ллл_РаспознатьУменьшеннуюТаблицуДокументовВФоне(ТаблицаДокументовДляЗагрузки,json);
	
	
	//КолвоЗаписей=ТаблицаДокументовДляЗагрузки.Количество();
	//КоличествоУменьшенныхТаблицДляФоновогоЗадания=цел(КолвоЗаписей/10);
	//МассивУменьшенныхТаблицДляФоновыхЗаданий=Новый Массив();
	//для Счетчик=0 по КоличествоУменьшенныхТаблицДляФоновогоЗадания цикл
	//	УменьшеннаяТаблица=ТаблицаДокументовДляЗагрузки.СкопироватьКолонки();
	//	для Счетчик2=1 по 50 цикл
	//		Если Счетчик*10+Счетчик2<=КолвоЗаписей тогда
	//			стр=УменьшеннаяТаблица.Добавить();
	//			ЗаполнитьЗначенияСвойств(стр,ТаблицаДокументовДляЗагрузки[Счетчик*10+Счетчик2-1]);
	//		КонецЕсли;
	//	КонецЦикла;
	//	
	//	Если УменьшеннаяТаблица.Количество()>0 тогда
	//		МассивУменьшенныхТаблицДляФоновыхЗаданий.Добавить(УменьшеннаяТаблица);
	//	КонецЕсли;
	//КонецЦикла;
	//УменьшеннаяТаблица=неопределено;
	//
	//Для каждого УменьшеннаяТаблица из МассивУменьшенныхТаблицДляФоновыхЗаданий цикл
	//	ПараметрыФоновогоЗадания=Новый Массив();
	//	ПараметрыФоновогоЗадания.Добавить(Уменьшеннаятаблица);
	//	ПараметрыФоновогоЗадания.Добавить(json);
	//	Задание=ФоновыеЗадания.Выполнить("СП_РаботаССообщениями.ллл_РаспознатьУменьшеннуюТаблицуДокументовВФоне",ПараметрыФоновогоЗадания);
	//КонецЦикла;
КонецПроцедуры  

Процедура ллл_РаспознатьУменьшеннуюТаблицуДокументовВФоне(ТаблицаДокументов,json) экспорт
	для каждого стр из ТаблицаДокументов Цикл
		ЭтоСообщениеJson = СП_ОбменДанными.ЭтоИнформацияВJSON(стр.ТелоСообщения);
		Сообщ=стр.Сообщение;
		Если ЭтоСообщениеJson Тогда 
				СообщОбъект=Сообщ.ПолучитьОбъект();
				инт_ПроцедурыПоискаСоответствийОбмена.ОбработатьСП_Сообщение(СообщОбъект, Неопределено,ложь);
				Если СообщОбъект.Результатв1С="Обрабатывается" тогда
					СообщОбъект.Результатв1С="Объект не записан";
					СообщОбъект.Записать();
				КонецЕсли;
					
        КонецЕсли;	
		
		Если значениеЗаполнено(Сообщ.СсылканаОбъект) тогда 
			стр.СозданНайденОбъект=истина;
			стр.НеобходимыДальнейшиеДействия = НадоВыполнитьДальнейшиеДействия(Сообщ.ссылкаНаОбъект);
		КонецЕсли;
		
	КонецЦикла;
	
	МассивПараметров=Новый Массив();
	МассивПараметров.Добавить(ТаблицаДокументов);
	ФоновыеЗадания.Выполнить("СП_РаботаССообщениями.ВыполнениеДальнейшихДействийВФоне",МассивПараметров);
	
	
КонецПроцедуры

//переопределено в расширении
Функция НадоВыполнитьДальнейшиеДействия(ссылкаНаОбъект) экспорт
	
	//Если типЗнч(СсылкаНаОбъект)=тип("ДокументСсылка.ЗаказПоставщику") тогда
	//	
	//	Если СсылкаНаОбъект.Хозяйственнаяоперация =Перечисления.ХозяйственныеОперации.ЗакупкаПоИмпорту тогда
	//	
	//		Если не Документы.ЗаказПоставщику.ллл_ПоЗаказуЕстьСозданныеЗаявкиБезПометкиУдаления(СсылкаНаОбъект) тогда 
	//			возврат истина;
	//		конецЕсли;
	//	КонецЕсли;
	//КонецЕсли;
	
	Если типЗнч(СсылкаНаОбъект)=тип("ДокументСсылка.ПриобретениеТоваровУслуг") тогда
		возврат(истина);
	КонецЕсли;
	
    возврат ложь;

КонецФункции

//переопределено в расширении
Процедура ВыполнениеДальнейшихДействийВФоне(ТаблицаДокументов) экспорт
	
	для каждого стр из ТаблицаДокументов цикл
		Если стр.необходимыДальнейшиеДействия тогда
			Если типЗнч(стр.Сообщение)=тип("СправочникСсылка.СП_СообщенияОбмена") тогда
				Док=стр.Сообщение.СсылкаНаОбъект;
			иначе
				Док=стр.Сообщение;
			КонецЕсли;
			если значениеЗаполнено(Док) тогда
				Если типЗнч(Док)=тип("ДокументСсылка.ЗаказПоставщику") и Док.Проведен тогда
					
							ПараметрыФоновогоЗадания=Новый Массив;
							ПараметрыФоновогоЗадания.Добавить(Док);
							ПараметрыФоновогоЗадания.Добавить(Док.Автор);
							ПараметрыФоновогоЗадания.Добавить('00010101');
							ПараметрыФоновогоЗадания.Добавить(0);
		                    ПараметрыФоновогоЗадания.Добавить("");
		
							ФоновыеЗадания.Выполнить("ллл_МодульКазначействоОбщегоНазначения.ллл_АвтоматическоеСозданиеЗаявкиНаОплатуИмпортИОповещение",
							ПараметрыФоновогоЗадания,
							строка(Новый УникальныйИдентификатор),
							"Создание заявки к заказу "+строка(Док.Ссылка));
				КонецЕсли;
				
				
				
				
				Если типЗнч(Док)=тип("ДокументСсылка.ПриобретениеТоваровУслуг") тогда
					Если Док.ХозяйственнаяОперация=Перечисления.ХозяйственныеОперации.ЗакупкаПоИмпорту тогда	
											
						
						СовпадаетсЗаказом=ллл_МодульКазначействоОбщегоНазначения.СовпадаетНаполнениеЗаказаИПТУ(Док);
						Если СовпадаетСЗаказом тогда 
							Заказ=Док.ЗаказПоставщику;
							Запрос=Новый Запрос();
							Запрос.Текст="ВЫБРАТЬ
							             |	ПриобретениеТоваровУслуг.* 
							             |ИЗ
							             |	Документ.ПриобретениеТоваровУслуг КАК ПриобретениеТоваровУслуг где ПриобретениеТоваровУслуг.Ссылка=&Ссылка";
							Запрос.УстановитьПараметр("Ссылка",Док);
							стрИсходнаяшапкаДокумента=Запрос.Выполнить().Выгрузить()[0];
							
							
							
							
					        ВидЗапасов=Справочники.Видызапасов.Найтипонаименованию("Собственный товар;Группа: 41 счет;Организация: Новый Ай Ти Проект ООО");
                            
							
							
							
							
							ПТУ_Объект=Док.ПолучитьОбъект();
							ПТУ_Объект.записать(РежимЗаписиДокумента.ОтменаПроведения);
							
							
							ПТУ_Объект.Заполнить(заказ);
							ПТУ_Объект.Товары.Очистить();
							ОбъектРасчетов=ОбъектыРасчетовСервер.ПолучитьОбъектРасчетовПоСсылке(Док);
							для каждого стр из Док.ЗаказПОставщику.товары цикл
								стрПТУ=ПТУ_Объект.Товары.Добавить();
								ЗаполнитьЗначенияСвойств(стрПТУ,стр);
								стрПТУ.СуммаВзаиморасчетов=стрПТУ.Сумма;
								стрПТУ.СуммаНДСВзаиморасчетов=стрПТУ.СуммаНДС;
								стрПТУ.Склад=ПТУ_Объект.Склад;
								стрПТУ.КодСтроки=0;
								стрПТУ.Подразделение=ПТУ_Объект.Подразделение;
								стрПТУ.ЗаказПоставщику=Док.ЗаказПоставщику;
								стрПТУ.Объектрасчетов=ОбъектРасчетов;
								стрПТУ.АналитикаУчетаНоменклатуры = НайтиКлючАналитикиУчетаНоменклатуры(стрПТУ.Склад,стрПТУ.Номенклатура);
								стрПТУ.ВидЗапасов=ВидЗапасов;
							КонецЦикла;
							
							ЗаполнитьЗначенияСвойств(ПТУ_Объект,стрИсходнаяшапкаДокумента,"Дата,Номер,НомерВходящегоДокумента,ДатаВходящегоДокумента,
							| Организация,Контрагент,Договор,Соглашение,Партнер,Менеджер,Автор,Подразделение,Склад");
							
							ПТУ_Объект.СуммаДокумента=ПТУ_Объект.Товары.Итог("СуммаСНДС");
							ПТУ_Объект.СуммаВзаиморасчетовПоЗаказу=ПТУ_Объект.СуммаДокумента;
							ПТУ_Объект.СуммаВзаиморасчетов=ПТУ_Объект.СуммаДокумента;
							ПТУ_Объект.Комментарий="";
							ПТУ_Объект.ПометкаУдаления=ложь;
							//АналитикиПланированияДокументов.ДоговорКонтрагентаПриИзменении(ПТУ_Объект);
							//ПТУ_Объект.Записать(РежимЗаписиДокумента.ОтменаПроведения);
							ПТУ_Объект.Записать(РежимЗаписиДокумента.Проведение,РежимПроведенияДокумента.Неоперативный);
							
							
							СтруктураДанныхПоЗадолженностиПоПТУ=ллл_МодульКазначействоОбщегоНазначения.ллл_ОпределениеЗадолженностиПоДокументуПТУ(Док);
							КОплате=СтруктураДанныхПоЗадолженностиПоПТУ.КОплате;

							ПТУ=Док;
							Если ЗначениеЗаполнено(ПТУ.ЗаказПоставщику) и ЗначениеЗаполнено(ПТУ.Договор) и 
								ПТУ.ЗаказПоставщику.Дата>
								л3_СерверПовтИсп.ЗначениеНетиповойКонстанты("Дата начала применения автоматического создания заявок на оплату на осн. ПТУ (3l)")
							и СтруктураДанныхПоЗадолженностиПоПТУ.Ошибка=""	и КОплате>0.1							
							
							и л3_СерверПовтИсп.ЗначениеНетиповойКонстанты("Формировать заявки на оплату для ПТУ Импорт")=истина тогда
							 	ллл_МодульКазначействоОбщегоНазначения.СоздатьЗаявкуНаОплатуНаОснованииПТУ(Док);
							 
							КонецЕсли;
							
						иначе                               
							ПТУ_Объект=Док.ПолучитьОбъект();
							ПТУ_Объект.Комментарий="Товарное наполнение не соответствует заказу.";
							ПТУ_Объект.ПОметкаУдаления=истина;
							ПТУ_Объект.Записать(РежимЗаписиДокумента.ОтменаПроведения);
							
							
			ТемаСообщения="В документе ПТУ номер "+ док.Номер+" от " + Формат(Док.Дата,"ДЛФ=Д")+", связанному с заказом поставщику "+ Док.заказпоставщику.номер +" от " + 
			Формат(Док.заказпоставщику.Дата,"ДЛФ=Д")+" товарное наполнение не соответствует заказу.";
			
			ТекстСообщения="Товарное наполнение ПТК не соответствует заказу." +Символы.ВК+"Документы: "+Символы.ВК+"%Ссылка1"+Символы.ВК+"%Ссылка2";
			
			ТаблицаСсылок=Новый таблицаЗначений();
			ТаблицаСсылок.Колонки.Добавить("HTMLПредставлениеСсылки");
			ТаблицаСсылок.Колонки.Добавить("Ссылка");

			стр=ТаблицаСсылок.Добавить();
			стр.HTMLПредставлениеСсылки=ПолучитьНавигационнуюСсылку(док);
			стр.Ссылка=Док;
			
			стр=ТаблицаСсылок.Добавить();
			стр.HTMLПредставлениеСсылки=ПолучитьНавигационнуюСсылку(Док.заказпоставщику);
			стр.Ссылка=Док.заказпоставщику;
			
			СтруктураТекстовДляОповещения=ллл_МодульКазначействоОповещения.СформироватьHTMLТекстОповещенияПОльзователяССсылками(ТекстСообщения,ТаблицаСсылок);
			
			
	
	
		
			СобытияоповещенийСерверУх.СоздатьЗаписьСобытия(перечисления.СпособыОповещения.ВСистеме, Док.Автор, Справочники.ВидыСобытийОповещений.ПредписаниеИсполнителю, 
		Док.Ссылка, , ТекущаяДата(), , , ,,  ТемаСообщения,
		//ЗадачаОповещения.Ссылка 
		,
		, СтруктураТекстовДляОповещения.ТекстHTML, ,Неопределено);
		
		СобытияоповещенийСерверУх.СоздатьЗаписьСобытия(перечисления.СпособыОповещения.ВСистеме, Док.Автор, Справочники.ВидыСобытийОповещений.ПредписаниеИсполнителю, 
		Док.Ссылка, , ТекущаяДата(), , , ,,  ТемаСообщения,
		//ЗадачаОповещения.Ссылка 
		,
		, СтруктураТекстовДляОповещения.Текст, ,Неопределено);

							
						
						КонецЕсли;
						
					КонецЕсли;
			    КонецЕсли;
				
				
				Если типЗнч(Док)=тип("ДокументСсылка.ПриобретениеТоваровУслуг") тогда
					ПТУ=Док;
					ФормироватьЗаявку=ложь;
					
					Если Док.ХозяйственнаяОперация=Перечисления.ХозяйственныеОперации.ЗакупкаУПоставщика тогда   
						
						СтруктураДанныхПоЗадолженностиПоПТУ=ллл_МодульКазначействоОбщегоНазначения.ллл_ОпределениеЗадолженностиПоДокументуПТУ(Док);
							КОплате=СтруктураДанныхПоЗадолженностиПоПТУ.КОплате;

							
							Если ЗначениеЗаполнено(ПТУ.ЗаказПоставщику) и ЗначениеЗаполнено(ПТУ.Договор) и 
								ПТУ.ЗаказПоставщику.Дата>
								л3_СерверПовтИсп.ЗначениеНетиповойКонстанты("Дата начала применения автоматического создания заявок на оплату на осн. ПТУ (3l)")
							и СтруктураДанныхПоЗадолженностиПоПТУ.Ошибка=""	и КОплате>0.1							
							
						и л3_СерверПовтИсп.ЗначениеНетиповойКонстанты("Формировать заявки на оплату для ПТУ Закупка у поставщика")=истина	
						
						тогда
						ФормироватьЗаявку=истина;
						КонецЕсли;
						
					КонецЕсли;
					
					
					Если Док.ХозяйственнаяОперация=Перечисления.ХозяйственныеОперации.ЗакупкаВСтранахЕАЭС тогда 
						СтруктураДанныхПоЗадолженностиПоПТУ=ллл_МодульКазначействоОбщегоНазначения.ллл_ОпределениеЗадолженностиПоДокументуПТУ(Док);
							КОплате=СтруктураДанныхПоЗадолженностиПоПТУ.КОплате;
							
							
							
							Если ЗначениеЗаполнено(ПТУ.ЗаказПоставщику) и ЗначениеЗаполнено(ПТУ.Договор) и 
								ПТУ.ЗаказПоставщику.Дата>
								л3_СерверПовтИсп.ЗначениеНетиповойКонстанты("Дата начала применения автоматического создания заявок на оплату на осн. ПТУ (3l)")
							и СтруктураДанныхПоЗадолженностиПоПТУ.Ошибка=""	и КОплате>0.1							
							
						и л3_СерверПовтИсп.ЗначениеНетиповойКонстанты("Формировать заявки на оплату для ПТУ Ввоз из ЕАЭС")=истина	 тогда
						
						          Формироватьзаявку=истина;
						
						КонецЕсли;
						
					КонецЕсли;
						
					Если ФормироватьЗаявку тогда
							МассивПараметров=Новый Массив();
							МассивПараметров.Добавить(Док);
							ФоновыеЗадания.Выполнить("ллл_МодульКазначействоОбщегоНазначения.СоздатьЗаявкуНаОплатуНаОснованииПТУ",Массивпараметров,
							строка(Новый уНИКАЛЬНЫЙиДЕНТИФИКАТОР),
							"создание заявки на оплату к "+строка(Док));
					КонецЕсли;
				 КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры




Процедура ллл_РаспознатьДокументы(Кластер,json,МассивОбъектов,ВыводитьОтладочныеСообщения,Правило=неопределено)
	
	Если ВыводитьОтладочныеСообщения и типЗнч(МассивОбъектов)=тип("Массив") и МассивОбъектов.Количество()=1 тогда
		
		СообщениеОбъект=МассивОбъектов[0].ПолучитьОбъект();
		попытка
			инт_ПроцедурыПоискаСоответствийОбмена.ОбработатьСП_Сообщение(СообщениеОбъект, Правило,ВыводитьОтладочныеСообщения);
		исключение
				
					ТекстОшибки = СтрШаблон("Не удалось обработать входящее сообщение %1, по причине:
										|%2", Строка(СообщениеОбъект.Код),ОписаниеОшибки());
					ЗаписьЖурналаРегистрации("Интеграция.ОбработкаВходящегоСообщения", УровеньЖурналаРегистрации.Ошибка, СообщениеОбъект, СообщениеОбъект.Ссылка, ТекстОшибки);
					СообщениеОбъект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Ошибка;
					СообщениеОбъект.ТекстОшибки = ТекстОшибки;
					СообщениеОбъект.результатв1С="Объект не записан";
					СообщениеОбъект.Записать();
	
			
		КонецПОпытки;
		
		Если НадоВыполнитьДальнейшиеДействия(МассивОбъектов[0].СсылкаНаОбъект) тогда
			тз=Новый ТаблицаЗначений();
			тз.Колонки.Добавить("Сообщение");
			тз.Колонки.Добавить("НеобходимыДальнейшиеДействия");
			стр=тз.Добавить();
			стр.Сообщение=МассивОбъектов[0];
			стр.НеобходимыДальнейшиеДействия=истина;
			ВыполнениеДальнейшихДействийВФоне(тз);
			
		КонецЕсли;
		
	иначе	
		ПараметрыФоновогоЗадания=Новый Массив();
		ПараметрыФоновогоЗадания.Добавить(Кластер);
		ПараметрыФоновогоЗадания.Добавить(json);
		ПараметрыФоновогоЗадания.Добавить(МассивОбъектов);
		
		
		ФоновыеЗадания.Выполнить("СП_РаботаССообщениями.ллл_РаспознатьДокументыВФоне",
		ПараметрыФоновогозадания,
		строка(Новый УникальныйИдентификатор),
		"Распознавание документов, запуск "+Формат(текущаядата(),"ДЛФ=В"));
	КонецЕсли;
КонецПроцедуры




Функция ллл_ПолучитьУпорядоченнуюТаблицуДокументовДляЗагрузки(Кластер,МассивОбъектов=неопределено) 
	ТипСообщения = Перечисления.СП_ТипыСообщений.Входящее;
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Кластер", Кластер);
	Запрос.УстановитьПараметр("ТипСообщения", ТипСообщения);
	Запрос.УстановитьПараметр("МассивОбъектов",МассивОбъектов);

	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 50
	|	СП_Сообщения.Ссылка КАК Сообщение,
	|	СП_Сообщения.ТелоСообщения КАК ТелоСообщения,
	|	СП_Сообщения.ИмяТопика КАК ИмяТопика,
	|	СП_Сообщения.ДатаСообщенияВМиллисекундах КАК ДатаСообщенияВМиллисекундах,
	|	ЛОЖЬ КАК Обработано,
	|	ЛОЖЬ КАК СозданНайденОбъект,
	|	ЛОЖЬ КАК НеобходимыДальнейшиеДействия,
	|	ВЫБОР
	|		КОГДА СП_Сообщения.ИмяОбъекта = ""Документ.ЗаказПоставщику""
	|			ТОГДА 1
	|		КОГДА СП_Сообщения.ИмяОбъекта = ""Документ.ПриобретениеТоваровУслуг""
	|			ТОГДА 2
	|		ИНАЧЕ 3
	|	КОНЕЦ КАК приоритет
	|ИЗ
	|	Справочник.СП_СообщенияОбмена КАК СП_Сообщения
	|ГДЕ
	|	НЕ СП_Сообщения.ПометкаУдаления
	|	И СП_Сообщения.Кластер = &Кластер
	|	И СП_Сообщения.ТипСообщения = &ТипСообщения
	|	И СП_Сообщения.СостояниеСообщения = ЗНАЧЕНИЕ(Перечисление.СП_СостоянияСообщений.Новое)
	|	И СП_Сообщения.ИмяОбъекта ПОДОБНО ""Документ.%""
	|	И СП_Сообщения.Ссылка В(&МассивОбъектов)
	|
	|УПОРЯДОЧИТЬ ПО
	|	приоритет,
	|	ДатаСообщенияВМиллисекундах";
	
	Если не ЗначениеЗаполнено(МассивОбъектов) тогда
		Запрос.Текст=стрЗаменить(Запрос.Текст,"СП_Сообщения.Ссылка В(&МассивОбъектов)","ИСТИНА");
	КонецЕсли;
	
	Результат = Запрос.Выполнить();
	Возврат Результат.Выгрузить();
	
КонецФункции




Функция ллл_ПолучитьУпорядоченнуюТаблицуСправочниковДляЗагрузки(Кластер,МассивОбъектов)
	ТипСообщения = Перечисления.СП_ТипыСообщений.Входящее;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Кластер", Кластер);
	Запрос.УстановитьПараметр("ТипСообщения", ТипСообщения);
    Запрос.УстановитьПараметр("МассивОбъектов",МассивОбъектов);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	з.Сообщение КАК Сообщение,
	|	з.ТелоСообщения КАК ТелоСообщения,
	|	з.ИмяТопика КАК ИмяТопика,
	|	з.Приоритет КАК Приоритет,
	|	з.ДатаСообщенияВМиллисекундах КАК ДатаСообщенияВМиллисекундах
	|ИЗ
	|	(ВЫБРАТЬ
	|		СП_Сообщения.Ссылка КАК Сообщение,
	|		СП_Сообщения.ТелоСообщения КАК ТелоСообщения,
	|		СП_Сообщения.ИмяТопика КАК ИмяТопика,
	|		ВЫБОР
	|			КОГДА СП_Сообщения.Событие = ""insert""
	|				ТОГДА 1
	|			КОГДА СП_Сообщения.Событие = """"
	|					И СП_Сообщения.ИмяОбъекта = ""Справочник.Контрагенты""
	|				ТОГДА 2
	|			КОГДА СП_Сообщения.Событие = ""update""
	|					И СП_Сообщения.ИмяОбъекта = ""Справочник.Контрагенты""
	|				ТОГДА 3
	|			КОГДА СП_Сообщения.Событие = """"
	|					И СП_Сообщения.ИмяОбъекта = ""Справочник.ДоговорыКонтрагентов""
	|				ТОГДА 4
	|			КОГДА СП_Сообщения.Событие = ""update""
	|					И СП_Сообщения.ИмяОбъекта = ""Справочник.ДоговорыКонтрагентов""
	|				ТОГДА 5
	|			КОГДА СП_Сообщения.Событие = ""delete""
	|				ТОГДА 10
	|			ИНАЧЕ 6
	|		КОНЕЦ КАК Приоритет,
	|		СП_Сообщения.ДатаСообщенияВМиллисекундах КАК ДатаСообщенияВМиллисекундах,
	|		СП_Сообщения.ИмяОбъекта КАК ИмяОбъекта
	|	ИЗ
	|		Справочник.СП_СообщенияОбмена КАК СП_Сообщения
	|	ГДЕ
	|		НЕ СП_Сообщения.ПометкаУдаления
	|		И СП_Сообщения.Кластер = &Кластер
	|		И СП_Сообщения.ТипСообщения = &ТипСообщения
	|		И СП_Сообщения.СостояниеСообщения = ЗНАЧЕНИЕ(Перечисление.СП_СостоянияСообщений.Новое)
	|		И СП_Сообщения.ИмяОбъекта ПОДОБНО ""Справочник.%""
	|       И СП_Сообщения.Ссылка в(&МассивОбъектов)) КАК з
	|
	|УПОРЯДОЧИТЬ ПО
	|	Приоритет,
	|	ДатаСообщенияВМиллисекундах";
	Если не ЗначениеЗаполнено(МассивОбъектов) тогда
		Запрос.Текст=стрЗаменить(Запрос.Текст,"СП_Сообщения.Ссылка в(&МассивОбъектов)","ИСТИНА");
	КонецЕсли;
	
	Результат = Запрос.Выполнить();
	Возврат Результат.Выгрузить();
	
КонецФункции	





// Возвращает массив доступных для обмена кластеров.
// 
// Возвращаемое значение:
//  Неопределено - нет доступных для обмена кластеров.
//	Массив - массив доступных кластеров.
//
Функция ПолучитьКластерыОбмена() Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СП_Кластеры.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.СП_Кластеры КАК СП_Кластеры
	|ГДЕ
	|	НЕ СП_Кластеры.ПометкаУдаления";

	Результат = Запрос.Выполнить();

	Если Результат.Пустой() Тогда
		Возврат Неопределено;

	Иначе
		Возврат Результат.Выгрузить().ВыгрузитьКолонку("Ссылка");

	КонецЕсли;

КонецФункции

// Возвращает текст запроса по имени объекта.
// 
// Параметры:
//  ИмяОбъекта - Строка - имя объекта
//  СтруктураОтбора - Структура, Строка - структура отбора.
// 
// Возвращаемое значение:
//  Строка - текст запроса
//
Функция ПолучитьТекстЗапросаПоИмениОбъекта(ИмяОбъекта, СтруктураОтбора = "") Экспорт

	Если Не ТипЗнч(СтруктураОтбора) = Тип("Структура") Тогда
		СтруктураОтбора = Новый Структура;
	КонецЕсли;

	ШаблонЗапроса =
	"ВЫБРАТЬ
	|	%1
	|ИЗ
	|	%2
	|ГДЕ
	|	%3";

	ТекстОтбора = "ИСТИНА";
	Для Каждого ЭлементОтбора Из СтруктураОтбора Цикл
		ТекстОтбора = СтрШаблон("%1 И %2 = &%2", ТекстОтбора, ЭлементОтбора.Ключ);
	КонецЦикла;

	ДоступныеРеквизиты = ДоступныеРеквизитыПоИмениОбъекта(ИмяОбъекта);
	СписокРеквизитов = СтрСоединить(ДоступныеРеквизиты, ",");

	Возврат СтрШаблон(ШаблонЗапроса, СписокРеквизитов, ИмяОбъекта, ТекстОтбора);

КонецФункции

// Формирует и возвращает схему компоновки данных по тексту запроса.
// 
// Параметры:
//  ТекстЗапроса - Строка - текст запроса
// 
// Возвращаемое значение:
//  СхемаКомпоновки - схема компоновки данных
//
Функция НоваяСхемаКомпоновкиДанных(ТекстЗапроса) Экспорт

	СхемаКомпоновки = Новый СхемаКомпоновкиДанных;

	ИсточникДанных = СхемаКомпоновки.ИсточникиДанных.Добавить();
	ИсточникДанных.Имя = "Источник1";
	ИсточникДанных.ТипИсточникаДанных = "Local";

	НаборДанных = СхемаКомпоновки.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	НаборДанных.Имя = "НаборДанных1";
	НаборДанных.ИсточникДанных = "Источник1";
	НаборДанных.Запрос = ТекстЗапроса;
	НаборДанных.АвтоЗаполнениеДоступныхПолей = Истина;

	Возврат СхемаКомпоновки;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает признак регистрации объекта метаданных для обмена.
// 
// Параметры:
//  ИмяОбъекта - Строка	- полное имя объекта метаданных.
// 
// Возвращаемое значение:
// 	Булево - признак регистрации объекта метаданных для обмена.
//  
Функция ОбъектЗарегистрированДляОбмена(ИмяОбъекта)

	Если ИмяОбъекта = "Справочник.СП_СхемыДанных" Тогда
		Возврат Истина;

	Иначе
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ИмяОбъекта", ИмяОбъекта);
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	СП_ОбъектыОбмена.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.СП_ОбъектыОбмена КАК СП_ОбъектыОбмена
		|ГДЕ
		|	НЕ СП_ОбъектыОбмена.ПометкаУдаления
		|	И СП_ОбъектыОбмена.ИмяОбъекта = &ИмяОбъекта
		|	И СП_ОбъектыОбмена.ФлагОтправка";

		Результат = Запрос.Выполнить();

		Возврат Не Результат.Пустой();

	КонецЕсли;

КонецФункции

// Получает выборку сообщений, готовых для обработки.
// 
// Параметры:
//  Кластер - СправочникСсылка.СП_Кластеры - кластер для обмена.
//  ТипСообщения - ПеречислениеСсылка.СП_ТипыСообщений - тип сообщения (входящее/исходящее).
// 
// Возвращаемое значение:
//  ВыборкаИзРезультатаЗапроса, Неопределено - выборка из результата запроса.
//
Функция ПолучитьВыборкуСообщенийДляОбработки(Кластер, ТипСообщения)

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Кластер", Кластер);
	Запрос.УстановитьПараметр("ТипСообщения", ТипСообщения);

	Запрос.Текст =
	"ВЫБРАТЬ
	|	СП_Сообщения.Ссылка КАК Сообщение,
	|	СП_Сообщения.ТелоСообщения КАК ТелоСообщения,
	|	СП_Сообщения.ИмяТопика КАК ИмяТопика
	|ИЗ
	|	Справочник.СП_СообщенияОбмена КАК СП_Сообщения
	|ГДЕ
	|	НЕ СП_Сообщения.ПометкаУдаления
	|	И СП_Сообщения.Кластер = &Кластер
	|	И СП_Сообщения.ТипСообщения = &ТипСообщения
	|	И СП_Сообщения.СостояниеСообщения = ЗНАЧЕНИЕ(Перечисление.СП_СостоянияСообщений.Новое)
	|УПОРЯДОЧИТЬ ПО
	|	СП_Сообщения.ДатаСообщенияВМиллисекундах";

	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат Неопределено;

	Иначе
		Возврат Результат.Выбрать();

	КонецЕсли;

КонецФункции

// Возвращает таблицу тем для обработки сообщений.
// 
// Параметры:
// 	Кластер - СправочникСсылка.СП_Кластеры - ссылка на кластер.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица тем для обработки входящих сообщений.
//
Функция ПолучитьТемыДляОбработки(Кластер)

	ТаблицаТем = Новый ТаблицаЗначений;
	ТаблицаТем.Колонки.Добавить("ОбъектОбмена");
	ТаблицаТем.Колонки.Добавить("Тема");
	
	// Добавляем тему для схем, если она есть.
	Если ЗначениеЗаполнено(Кластер.ТемаДляСхем) Тогда
		НоваяСтрока = ТаблицаТем.Добавить();
		НоваяСтрока.ОбъектОбмена = Справочники.СП_ОбъектыОбмена.ПустаяСсылка();
		НоваяСтрока.Тема = Кластер.ТемаДляСхем;
	КонецЕсли;
	
	// Заполняем доступные темы для получения.
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	СП_ОбъектыОбмена.Ссылка КАК ОбъектОбмена,
	|	СП_ОбъектыОбмена.ТемаДляПолучения КАК Тема
	|ИЗ
	|	Справочник.СП_ОбъектыОбмена КАК СП_ОбъектыОбмена
	|ГДЕ
	|	НЕ СП_ОбъектыОбмена.ПометкаУдаления
	|	И СП_ОбъектыОбмена.ФлагПолучение";

	Результат = Запрос.Выполнить();
	Если Не Результат.Пустой() Тогда
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			НоваяСтрока = ТаблицаТем.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);
		КонецЦикла;
	КонецЕсли;

	Возврат ТаблицаТем;

КонецФункции

// Возвращает сообщение обмена.
// 
// Параметры:
//  ВыгружаемыйОбъект - ЛюбаяСсылка, НаборЗаписей - выгружаемый объект.
//  ИмяОбъекта - Строка - полное имя объекта метаданных.
//  СообщениеСсылка - СправочникСсылка.СП_СообщенияОбмена - ссылка на сообщение обмена.
// 
// Возвращаемое значение:
//  СправочникОбъект.СП_СообщенияОбмена - объект сообщения обмена.
//  
Функция СоздатьСообщениеОбмена(ВыгружаемыйОбъект, ИмяОбъекта, СообщениеСсылка = Неопределено)

	Если ЗначениеЗаполнено(СообщениеСсылка) Тогда
		Сообщение = СообщениеСсылка.ПолучитьОбъект();
		СообщениеСсылка = Неопределено;

	ИначеЕсли СП_ОбменДанными.ЭтоРегистр(ИмяОбъекта) Тогда
		ТаблицаОтбора = ПолучитьТаблицуОтбора(ВыгружаемыйОбъект);
		ХешОтбора     = ПолучитьХешОтбора(ТаблицаОтбора, ИмяОбъекта);
		Сообщение     = НайтиСуществующееСообщениеОбмена(ХешОтбора, ТаблицаОтбора);

	Иначе
		Сообщение = Справочники.СП_СообщенияОбмена.СоздатьЭлемент();

	КонецЕсли;

	Возврат Сообщение;

КонецФункции

// Получает таблицу отбора по набору записей.
// 
// Параметры:
//  НаборЗаписей - Регистр.НаборЗаписей - набор записей выгружаемого регистра.
// 
// Возвращаемое значение:
//  ТаблицаЗначений:
// 		* Имя - Строка - имя отбора.  
// 		* Значение - Строка, Число, Булево, ЛюбаяСсылка - значение отбора.
// 		
Функция ПолучитьТаблицуОтбора(НаборЗаписей)

	ТаблицаОтбора = Новый ТаблицаЗначений;
	ТаблицаОтбора.Колонки.Добавить("Имя");
	ТаблицаОтбора.Колонки.Добавить("Значение");

	Для Каждого Элемент Из НаборЗаписей.Отбор Цикл
		НоваяСтрока = ТаблицаОтбора.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Элемент);
	КонецЦикла;

	Возврат ТаблицаОтбора;

КонецФункции

// Получает хеш отбора по таблице отбора.
// 
// Параметры:
//  ТаблицаОтбора - ТаблицаЗначений - см. ПолучитьТаблицуОтбора
//  ИмяРегистра - Строка - имя регистра.
// 
// Возвращаемое значение:
//  Строка - хеш сумма отбора в виде строки.
//  
Функция ПолучитьХешОтбора(ТаблицаОтбора, ИмяРегистра)

	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, ТаблицаОтбора);
	СтрокаXML = ЗаписьXML.Закрыть();

	ХешОтбора = Новый ХешированиеДанных(ХешФункция.MD5);
	ХешОтбора.Добавить(ИмяРегистра + СтрокаXML);

	Возврат Строка(ХешОтбора.ХешСумма);

КонецФункции

// Находит существующее сообщение обмена по хеш сумме отбора.
// 
// Параметры:
//  ХешОтбора - Строка - хеш сумма отбора набора записей регистра.
//  ТаблицаОтбора - ТаблицаЗначений - таблица отбора набора записей регистра.
// 
// Возвращаемое значение:
//  СправочникОбъект.СП_СообщенияОбмена - сообщение обмена для набора записей.
//  
Функция НайтиСуществующееСообщениеОбмена(ХешОтбора, ТаблицаОтбора)

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ХешОтбора", ХешОтбора);
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	СообщенияОбмена.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.СП_СообщенияОбмена КАК СообщенияОбмена
	|ГДЕ
	|	СообщенияОбмена.СостояниеСообщения = ЗНАЧЕНИЕ(Перечисление.СП_СостоянияСообщений.Зарегистрировано)
	|	И СообщенияОбмена.ХешОтбора = &ХешОтбора";

	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Сообщение = Справочники.СП_СообщенияОбмена.СоздатьЭлемент();
		Сообщение.ХешОтбора = ХешОтбора;
		Сообщение.Отбор.Загрузить(ТаблицаОтбора);

	Иначе
		Выборка = Результат.Выбрать();
		Выборка.Следующий();

		Сообщение = Выборка.Ссылка.ПолучитьОбъект();

	КонецЕсли;

	Возврат Сообщение;

КонецФункции

Функция ПолучитьСсылкуНаОбъект(Источник, ИмяОбъекта)

	Если СП_ОбменДанными.ЭтоРегистр(ИмяОбъекта) Тогда
		Возврат "";
	Иначе
		Возврат Источник;
	КонецЕсли;

КонецФункции

// Получить таблицу отправки.
// 
// Параметры:
//  Источник - ЛюбаяСсылка - источник
//  ИмяОбъекта - Строка - имя объекта
//  ЭтоСхемаДанных - Булево - признак отношения источника к схемам данных
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица отправки:
// 		* Кластер - СправочникСсылка.СП_Кластеры - кластер для отправки.  
// 		* СхемаДанных - СправочникСсылка.СП_СхемыДанных - используемая схема данных. 
// 		* ИмяТопика - Строка - имя топика для отправки сообщения.
// 
Функция ПолучитьТаблицуОтправки(Источник, ИмяОбъекта, ЭтоСхемаДанных)
	
	// Инициализация таблицы отправки.
	ТаблицаОтправки = Новый ТаблицаЗначений;
	ТаблицаОтправки.Колонки.Добавить("Кластер");
	ТаблицаОтправки.Колонки.Добавить("СхемаДанных");
	ТаблицаОтправки.Колонки.Добавить("ИмяТопика");

	Если Источник = Неопределено Тогда
		Возврат ТаблицаОтправки;
	КонецЕсли;

	Если ЭтоСхемаДанных Тогда
		ЗаполнитьТаблицуОтправкиДляСхемДанных(ТаблицаОтправки);

	Иначе
		ЗаполнитьТаблицуОтправкиДляОбъектовОбмена(Источник, ИмяОбъекта, ТаблицаОтправки);

	КонецЕсли;

	Возврат ТаблицаОтправки;

КонецФункции

Процедура ЗаполнитьТаблицуОтправкиДляСхемДанных(ТаблицаОтправки)

	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СП_Кластеры.Ссылка КАК Кластер,
	|	"""" КАК СхемаДанных,
	|	СП_Кластеры.ТемаДляСхем КАК ИмяТопика
	|ИЗ
	|	Справочник.СП_Кластеры КАК СП_Кластеры
	|ГДЕ
	|	НЕ СП_Кластеры.ПометкаУдаления";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		НоваяСтрока = ТаблицаОтправки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);
	КонецЦикла;

КонецПроцедуры

Процедура ЗаполнитьТаблицуОтправкиДляОбъектовОбмена(Источник, ИмяОбъекта, ТаблицаОтправки)

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИмяОбъекта", ИмяОбъекта);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СП_Кластеры.Ссылка КАК Кластер,
	|	СП_ОбъектыОбмена.Ссылка КАК ОбъектОбмена,
	|	СП_ОбъектыОбмена.ХранилищеОтбора КАК ХранилищеОтбора,
	|	СП_ОбъектыОбмена.СхемаДанныхСсылка КАК СхемаДанных,
	|	СП_ОбъектыОбмена.ТемаДляОтправки КАК ИмяТопика
	|ИЗ
	|	Справочник.СП_ОбъектыОбмена КАК СП_ОбъектыОбмена,
	|	Справочник.СП_Кластеры КАК СП_Кластеры
	|ГДЕ
	|	НЕ СП_ОбъектыОбмена.ПометкаУдаления
	|	И НЕ СП_Кластеры.ПометкаУдаления
	|	И СП_ОбъектыОбмена.ФлагОтправка
	// Лопатин. Пока обмениваемся без схем.
    // Если есть схема - то формат XML, Инчае - JSON
	//|	И СП_ОбъектыОбмена.СхемаДанныхСсылка <> ЗНАЧЕНИЕ(Справочник.СП_СхемыДанных.ПустаяСсылка)
	|	И СП_ОбъектыОбмена.ИмяОбъекта = &ИмяОбъекта";

	СтруктураОтбора = СтруктураДоступногоОтбораПоИсточнику(Источник, ИмяОбъекта);
	ТекстЗапроса = ПолучитьТекстЗапросаПоИмениОбъекта(ИмяОбъекта, СтруктураОтбора);
	СхемаКомпоновки = НоваяСхемаКомпоновкиДанных(ТекстЗапроса);

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл

		НастройкиСКД = Выборка.ХранилищеОтбора.Получить();

		СоответствуетОтборуСКД = ВыгружаемыйОбъектСоответствуетОтборуСКД(
				СхемаКомпоновки, НастройкиСКД, СтруктураОтбора);

		СоответствуетОтбору = СП_ОбменДаннымиПереопределяемый.ВыгружаемыйОбъектСоответствуетОтбору(
				Источник, Выборка.ИмяТопика, СоответствуетОтборуСКД);

		Если СоответствуетОтбору Тогда
			НоваяСтрока = ТаблицаОтправки.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Выборка);
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

Функция ДоступныеРеквизитыПоИмениОбъекта(ИмяОбъекта)

	МассивРеквизитов = Новый Массив;

	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ИмяОбъекта);

	Если СП_ОбменДанными.ЭтоРегистр(ИмяОбъекта) Тогда
		Для Каждого РеквизитМетаданные Из ОбъектМетаданных.Измерения Цикл
			МассивРеквизитов.Добавить(РеквизитМетаданные.Имя);
		КонецЦикла;

	Иначе
		Для Каждого РеквизитМетаданные Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
			МассивРеквизитов.Добавить(РеквизитМетаданные.Имя);
		КонецЦикла;

		Для Каждого РеквизитМетаданные Из ОбъектМетаданных.Реквизиты Цикл
			Если Не РеквизитМетаданные.Тип.СодержитТип(Тип("ХранилищеЗначения")) Тогда
				МассивРеквизитов.Добавить(РеквизитМетаданные.Имя);
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;

	Возврат МассивРеквизитов;

КонецФункции

Функция СтруктураДоступногоОтбораПоИсточнику(Источник, ИмяОбъекта)

	СтруктураОтбора = Новый Структура;

	Если СП_ОбменДанными.ЭтоРегистр(ИмяОбъекта) Тогда
		Для Каждого ЭлементОтбора Из Источник.Отбор Цикл
			СтруктураОтбора.Вставить(ЭлементОтбора.Имя, ЭлементОтбора.Значение);
		КонецЦикла;

	Иначе
		СтруктураОтбора.Вставить("Ссылка", Источник);

	КонецЕсли;

	Возврат СтруктураОтбора;

КонецФункции

Функция УстановитьНастройкиКомпоновкиДанных(СхемаКомпоновки, НастройкиСКД, СтруктураОтбора)

	Если НастройкиСКД = Неопределено Тогда
		НастройкиСКД = СхемаКомпоновки.НастройкиПоУмолчанию;
	КонецЕсли;

	АдресСхемыКомпоновки = ПоместитьВоВременноеХранилище(СхемаКомпоновки);

	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(АдресСхемыКомпоновки));
	КомпоновщикНастроек.ЗагрузитьНастройки(НастройкиСКД);

	ПараметрыКомпоновщика = КомпоновщикНастроек.Настройки.ПараметрыДанных;
	Для Каждого ЭлементОтбора Из СтруктураОтбора Цикл
		ПараметрыКомпоновщика.УстановитьЗначениеПараметра(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
	КонецЦикла;

	ГруппировкаДетальныеЗаписи = КомпоновщикНастроек.Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	ГруппировкаДетальныеЗаписи.Использование = Истина;

	АвтоПоле = ГруппировкаДетальныеЗаписи.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	АвтоПоле.Использование = Истина;

	Для Каждого ЭлементОтбора Из СтруктураОтбора Цикл
		НовоеПоле = КомпоновщикНастроек.Настройки.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		НовоеПоле.Поле = Новый ПолеКомпоновкиДанных(ЭлементОтбора.Ключ);
		НовоеПоле.Заголовок = ЭлементОтбора.Ключ;
		НовоеПоле.Использование = Истина;
	КонецЦикла;

	Возврат КомпоновщикНастроек.Настройки;

КонецФункции

Функция ПолучитьРезультатКомпоновкиДанных(СхемаКомпоновки, НастройкиКомпоновки)

	ДанныеРасшифровки = Новый ДанныеРасшифровкиКомпоновкиДанных;
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;

	ТипГенератора = Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений");
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновки, НастройкиКомпоновки, ДанныеРасшифровки, ,
		ТипГенератора);

	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки, , ДанныеРасшифровки);

	Результат = Новый ТаблицаЗначений;

	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.УстановитьОбъект(Результат);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);

	Возврат Результат;

КонецФункции

Функция ВыгружаемыйОбъектСоответствуетОтборуСКД(СхемаКомпоновки, НастройкиСКД, СтруктураОтбора)

	Если ТипЗнч(НастройкиСКД) = Тип("НастройкиКомпоновкиДанных") И ЗначениеЗаполнено(НастройкиСКД.Отбор.Элементы) Тогда

		НастройкиКомпоновки = УстановитьНастройкиКомпоновкиДанных(СхемаКомпоновки, НастройкиСКД, СтруктураОтбора);
		Результат = ПолучитьРезультатКомпоновкиДанных(СхемаКомпоновки, НастройкиКомпоновки);
		СоответствуетОтборуСКД = ЗначениеЗаполнено(Результат);

	Иначе
		СоответствуетОтборуСКД = Истина;

	КонецЕсли;

	Возврат СоответствуетОтборуСКД;

КонецФункции

Процедура ЗаписатьРезультатОбработки(ДанныеСообщения, СообщениеОбъект)

	Если ДанныеСообщения.Свойство("БылиОшибки") И ДанныеСообщения.БылиОшибки Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ДанныеСообщения.ТекстОшибки;
		Сообщение.Сообщить();

		СообщениеОбъект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Ошибка;
		СообщениеОбъект.ТекстОшибки = ДанныеСообщения.ТекстОшибки;

	Иначе
		СообщениеОбъект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Загружено;
		СообщениеОбъект.ДатаВремяОбработки = ТекущаяДатаСеанса();
		СообщениеОбъект.ИдентификаторСообщения = ДанныеСообщения.ИдентификаторСообщения;
		СообщениеОбъект.ИмяОбъекта = ДанныеСообщения.ИмяОбъекта;

		Если ЗначениеЗаполнено(ДанныеСообщения.ЗагруженныеОбъекты) Тогда
			СообщениеОбъект.СсылкаНаОбъект = ДанныеСообщения.ЗагруженныеОбъекты[0];
		КонецЕсли;

	КонецЕсли;

	Попытка
		СообщениеОбъект.Записать();

	Исключение
		ТекстОписанияОшибки = ОписаниеОшибки();
		ТекстИсключения = СтрШаблон("Не удалось обработать входящее сообщение: %1
									|%2", СообщениеОбъект.Код, ТекстОписанияОшибки);

		ВызватьИсключение ТекстИсключения;

	КонецПопытки;

КонецПроцедуры

// Получает источник сообщения обмена.
// 
// Параметры:
//  ДанныеОбъекта - ВыборкаИзРезультатаЗапроса, ЛюбаяСсылка, Структура - данные объекта обмена.
// 
// Возвращаемое значение:
//	ЛюбаяСсылка, НаборЗаписей - источник сообщения обмена.
//  
Функция ПолучитьИсточникСообщенияОбмена(ДанныеОбъекта)

	Если ЗначениеЗаполнено(ДанныеОбъекта.СсылкаНаОбъект) Тогда
		Возврат ДанныеОбъекта.СсылкаНаОбъект;

	ИначеЕсли ЗначениеЗаполнено(ДанныеОбъекта.Отбор) Тогда
		СтруктураОтбора = Новый Структура;
		ТаблицаОтбора = ДанныеОбъекта.Отбор.Выгрузить();
		Для Каждого Строка Из ТаблицаОтбора Цикл
			СтруктураОтбора.Вставить(Строка.Имя, Строка.Значение);
		КонецЦикла;

		НаборЗаписей = СП_ОбменДанными.СоздатьНаборЗаписейРегистра(СтруктураОтбора, ДанныеОбъекта.ИмяОбъекта);
		НаборЗаписей.Прочитать();

		Возврат НаборЗаписей;

	Иначе
		Возврат Неопределено;

	КонецЕсли;

КонецФункции

#КонецОбласти

Функция СуществуютПравилаСоответствияЗагружаемыхСообщенийБазе()
	Запрос=Новый Запрос();
	Запрос.Текст="ВЫБРАТЬ
	             |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазе.Ссылка КАК Ссылка
	             |ИЗ
	             |	Справочник.инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазе КАК инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазе
	             |ГДЕ
	             |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазе.ПометкаУдаления = ЛОЖЬ
	             |	И инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазе.Активность = ИСТИНА";
	Результат=Запрос.Выполнить();
	возврат(не Результат.Пустой());
	
	
КонецФункции


Функция ВСтруктуреЕстьСвойство(РассматриваемаяСтруктура,знач НаименованиеСвойства, ПрочитанноеЗначениеСвойства) экспорт
	 Если РассматриваемаяСтруктура.Свойство(НаименованиеСвойства,ПрочитанноеЗначениеСвойства) тогда 
		возврат(истина);
	 иначе	
		для каждого КлючЗначение из РассматриваемаяСтруктура цикл
			Если типЗнч(КлючЗначение.Значение)=тип("Структура") тогда
				Если ВСтруктуреЕстьСвойство(КлючЗначение.Значение,НаименованиеСвойства, ПрочитанноеЗначениеСвойства) тогда
					 возврат(истина);
					 прервать;
				КонецЕсли;
			КонецЕсли;
		 КонецЦикла;
	 КонецЕсли;
	 возврат(ложь);
КонецФункции




Функция СтрочкаУсловияВыполнена(СтрочкаУсловия,СтруктураHEAD)
	НаименованиеСвойства=СтрочкаУсловия.НаименованиеСвойства;
	ПрочитанноеЗначениеСвойства=неопределено;
	
	
	
	Если не ВСтруктуреЕстьСвойство(СтруктураHEAD,НаименованиеСвойства,ПрочитанноеЗначениеСвойства) тогда 
		возврат(ложь);
	КонецЕсли;
	
	Если типЗнч(ПрочитанноеЗначениеСвойства)<>ТипЗнч(СтрочкаУсловия.ЗначениеСвойства) тогда возврат(ложь);конецЕсли;
	
	Если СтрочкаУсловия.ЛогическийОператор="=" и ПрочитанноеЗначениеСвойства=СтрочкаУсловия.ЗначениеСвойства тогда возврат(истина);конецЕсли;
	Если СтрочкаУсловия.ЛогическийОператор="не равно" и ПрочитанноеЗначениеСвойства<>СтрочкаУсловия.ЗначениеСвойства тогда возврат(истина);конецЕсли;
	Если СтрочкаУсловия.ЛогическийОператор=">" и ПрочитанноеЗначениеСвойства>СтрочкаУсловия.ЗначениеСвойства тогда возврат(истина);конецЕсли;
	Если СтрочкаУсловия.ЛогическийОператор="<" и ПрочитанноеЗначениеСвойства<СтрочкаУсловия.ЗначениеСвойства тогда возврат(истина);конецЕсли;
	
	Возврат(ложь);
	
	
КонецФункции



Функция ПроверитьСоответствиеВходящегоСообщенияБазе(СтруктураHEAD) 
	
	     Запрос=Новый Запрос();
		 Запрос.Текст="ВЫБРАТЬ
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.Ссылка КАК Ссылка,
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.НаименованиеСвойства КАК НаименованиеСвойства,
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.ЗначениеСвойства КАК ЗначениеСвойства,
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.ЛогическийОператор КАК ЛогическийОператор,
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.ЛогическоеУсловие КАК ЛогическоеУсловие
		              |ИЗ
		              |	Справочник.инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазе.ЗначенияJSON КАК инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD
		              |ГДЕ
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.Ссылка.ПометкаУдаления = ЛОЖЬ
		              |	И инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.Ссылка.Активность = ИСТИНА
		              |
		              |СГРУППИРОВАТЬ ПО
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.Ссылка,
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.ЛогическоеУсловие,
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.НаименованиеСвойства,
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.ЗначениеСвойства,
		              |	инт_ПроверкаСоответствияЗагружаемыхПакетовОбменаТекущейБазеЗначенияHEAD.ЛогическийОператор
		              |ИТОГИ ПО
		              |	Ссылка,
		              |	ЛогическоеУсловие";
		Результат=Запрос.Выполнить();
		Выборка=Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		пока ВЫборка.Следующий() цикл
			бЛОКуСЛОВИЙиЛИвЫПОЛНЕН=ложь;
			ЕстьУсловияИли=ложь;
			БлокУсловийИВыполнен=истина;
			
			Выборка2=Выборка.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			
			
			пока Выборка2.Следующий() цикл
					
				Если Выборка2.ЛогическоеУсловие="Условие ""Или""" тогда	
					ЕстьУсловияИли=истина;
					Выборка3=Выборка2.Выбрать();
					пока ВЫборка3.Следующий() цикл
						Если СтрочкаУсловияВыполнена(Выборка3,СтруктураHEAD) тогда
							бЛОКуСЛОВИЙиЛИвЫПОЛНЕН=истина;
							
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
				
				
				Если Выборка2.ЛогическоеУсловие="Условие ""И""" тогда				
					Выборка3=Выборка2.Выбрать();
					пока ВЫборка3.Следующий() цикл
						Если не СтрочкаУсловияВыполнена(Выборка3,СтруктураHEAD) тогда		
							БлокУсловийИВыполнен=ложь;
						КонецЕсли;
					КонецЦикла;
					
				КонецЕсли;
			КонецЦикла;
			
			Если БлокУсловийИВыполнен и ((ЕстьУсловияИли и БлокУсловийИлиВыполнен) или не ЕстьУсловияИли) тогда
				возврат(истина);
				
			КонецЕсли;
			
			
			
		КонецЦикла;
		
		возврат(ложь);
		 
		 
		 
	
КонецФункции


Процедура СоздатьВходящееСообщение(Сообщение, СтрокаТемы, Кластер, МоментВремени, ЭтоСхемаДанных) Экспорт
	
	
	
	Если СуществуютПравилаСоответствияЗагружаемыхСообщенийБазе() тогда 
	
		ТекстОшибки="";
		структураСообщения=инт_JSONОбмен.ПолучитьСтруктуруСообщенияJSON(Сообщение,ТекстОшибки);
		
		Если ТекстОшибки<>"" тогда 
			возврат;
		конецЕсли;
		
		//Успех=истина;
		//СтруктураHEAD=инт_JSONОбмен.ПолучитьСтруктуруHeadРаспознаннойСтруктурыФайлаJSON(структураСообщения,ТекстОшибки,Успех);
		//Если не Успех тогда
		//	возврат;
		//КонецЕсли;
	
		если не ПроверитьСоответствиеВходящегоСообщенияБазе(структураСообщения) тогда
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
	
	
	
	
	НовоеСообщение = Справочники.СП_СообщенияОбмена.СоздатьЭлемент();

	НовоеСообщение.ТипСообщения                = Перечисления.СП_ТипыСообщений.Входящее;
	НовоеСообщение.ДатаВремяСообщения          = ТекущаяДатаСеанса();
	НовоеСообщение.ДатаСообщенияВМиллисекундах = МоментВремени;
	НовоеСообщение.ТелоСообщения               = Сообщение;
	НовоеСообщение.Кластер                     = Кластер;
	НовоеСообщение.ОбъектОбмена                = СтрокаТемы.ОбъектОбмена;
	НовоеСообщение.ИмяТопика                   = СтрокаТемы.Тема;
	НовоеСообщение.ЭтоСхема                    = ЭтоСхемаДанных;
	
	
	
	Попытка
		НовоеСообщение.Событие=структураСообщения.Head.type_action;
		инт_JSONОбмен.РаспознатьИмяОбъектаСообщенияОбмена(НовоеСообщение);
		
		Если не ЗначениеЗаполнено(НовоеСообщение.ИмяОбъекта) тогда
			subtype = Справочники.СП_СообщенияОбмена.ОпределитьSubtype(НовоеСообщение);
			Если значениеЗаполнено(subtype) тогда
				НовоеСообщение.ИмяОбъекта = subtype;
			КонецЕсли;
		КонецЕсли;
		Если ЗначениеЗаполнено(НовоеСообщение.ИмяОбъекта) Тогда
			СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Новое;
		Иначе
			СостояниеСообщения = Перечисления.СП_СостоянияСообщений.ОшибкаОпределенияПравилСоответствия;
		КонецЕсли;
	Исключение
		СостояниеСообщения = Перечисления.СП_СостоянияСообщений.ОшибкаЧтенияJSON;
	КонецПопытки;
	
	НовоеСообщение.СостояниеСообщения          = СостояниеСообщения;

	НовоеСообщение.Записать();
	
КонецПроцедуры

Функция НайтиКлючАналитикиУчетаНоменклатуры(Склад,Номенклатура)
Запрос = Новый Запрос;
Запрос.УстановитьПараметр("Номенклатура", Номенклатура);
Запрос.УстановитьПараметр("МестоХранения", Склад);

Запрос.Текст =
"ВЫБРАТЬ
|	КлючиАналитикиУчетаНоменклатуры.Ссылка КАК Ссылка
|ИЗ
|	Справочник.КлючиАналитикиУчетаНоменклатуры КАК КлючиАналитикиУчетаНоменклатуры
|ГДЕ
|	КлючиАналитикиУчетаНоменклатуры.МестоХранения = &МестоХранения
|	И КлючиАналитикиУчетаНоменклатуры.Номенклатура = &Номенклатура";
Результат = Запрос.Выполнить();


Выборка = Результат.Выбрать();
Если Выборка.Следующий() тогда
	возврат(Выборка.Ссылка);
иначе
	возврат(Справочники.КлючиАналитикиУчетаНоменклатуры.ПустаяСсылка());
КонецЕсли;
	
КонецФункции
