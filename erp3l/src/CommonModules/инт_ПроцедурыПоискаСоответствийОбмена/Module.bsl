
Функция ПолучитьОбрабатываемыйОбъектПоСправочникуСоответствия(ВходящаяСтруктура, знач СправочникСоответствия, 
	СтруктураРаспознанныхЗначений  =  Неопределено,ОписаниеОшибки="",ВЫводитьОтладочныеСообщения,ЭтоНовыйОбъект=ложь) экспорт
	
	НачатьТранзакцию();
	Блокировка=Новый БлокировкаДанных();
	ЭлементБлокировки=Блокировка.Добавить("Справочник.инт_СоответствиеОбъектовЗначениямИнтеграции");
	ЭлементБлокировки.УстановитьЗначение("Ссылка",СправочникСоответствия);
	ЭлементБлокировки.Режим=РежимБлокировкиДанных.Разделяемый;
	Блокировка.Заблокировать();
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.Ссылка.ИмяОбъектаМетаданных КАК ИмяОбъектаМетаданных,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.Ссылка.ИмяОбъекта КАК ИмяОбъекта,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ИмяМетаданных КАК ИмяМетаданных,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ТипМетаданных КАК ТипМетаданных,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ПроцедураПоискаСоответствия КАК ПроцедураПоискаСоответствия,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ПроцедураЗаполнения КАК ПроцедураЗаполнения,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ИмяСвойстваИнтеграции КАК ИмяСвойстваИнтеграции
	|ИЗ
	|	Справочник.инт_СоответствиеОбъектовЗначениямИнтеграции.Реквизиты КАК инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты
	|ГДЕ
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ЭтоКлюч  =  ИСТИНА
	|	И инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.Ссылка  =  &Ссылка";
	Запрос.УстановитьПараметр("Ссылка",СправочникСоответствия);
	
	Результат = Запрос.Выполнить(); 
	ЗафиксироватьТранзакцию();
	Выборка = Результат.Выбрать();
	если Выборка.Следующий() тогда
		структураКлюча = Новый Структура("ИмяОбъектаМетаданных,ИмяОбъекта,ИмяМетаданных,ТипМетаданных,ПроцедураПоискаСоответствия,ПроцедураЗаполнения,ИмяСвойстваИнтеграции");
		заполнитьЗначенияСвойств(структураКлюча,Выборка);
		ОписаниеОшибки=структураКлюча.ИмяСвойстваИнтеграции;
	иначе
		ОписаниеОшибки="Не обнаружили имя ключа для поиска объекта";
		возврат(Неопределено);
	КонецЕсли;
	
	ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ = неопределено;
	Если ВходящаяСтруктура.Свойство(структураКлюча.ИмяСвойстваИнтеграции,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ) = ложь тогда
		ОписаниеОшибки="не нашли значение ключа "+структураКлюча.ИмяСвойстваИнтеграции;
		возврат(неопределено);
		
	КонецЕсли;
	
	//текстПроцедурыПоискаПоКлючу = СтруктураКлюча.ПроцедураПоискаСоответствия;
	//текстПроцедурыПоискаПоКлючу = стрЗаменить(текстПроцедурыПоискаПоКлючу,"ПОДСТАНОВКАИМЕНИСВОЙСТВА",СтруктураКлюча.ИмяМетаданных);
	
	
	ВозвращаемаяСсылка = неопределено;
	//выполнить(текстПроцедурыПоискаПоКлючу); 
	
	
	ВыполнитьКодИзСправочникаНастроек(СтруктураКлюча.ПроцедураПоискаСоответствия,ОписаниеОшибки,ВЫводитьОтладочныеСообщения,
			"Поиск ссылочного объекта по ключу",СтруктураКлюча.ИмяМетаданных,,ВозвращаемаяСсылка,неопределено,ВходящаяСтруктура,СтруктураРаспознанныхЗначений,
			,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ,истина);

	
	
	НадоДелатьПостОбработку = ложь;
	Если ВозвращаемаяСсылка = неопределено или не ЗначениеЗаполнено(ВозвращаемаяСсылка) тогда
		ОписаниеОшибки=ОписаниеОшибки+ ". Не нашли объект по процедуре поиска";	
		ОбрабатываемыйОбъект = неопределено;
		
		строкаСозданияОбъекта = ПолучитьСтрокуСозданияОбъектаПоСтрокеИмениМетаданных(структураКлюча.ИмяОбъектаМетаданных);
		
		Выполнить(строкаСозданияОбъекта);
		
		Если ОбрабатываемыйОбъект = неопределено тогда возврат(неопределено);конецЕсли;
		ЭтоНовыйОбъект=истина;
		//СтрокаЗаполненияОбъекта = структураКлюча.ПроцедураЗаполнения;
		//СтрокаЗаполненияОбъекта = стрЗаменить(СтрокаЗаполненияОбъекта,"ПОДСТАНОВКАИМЕНИСВОЙСТВА",СтруктураКлюча.ИмяМетаданных);
		//Выполнить(СтрокаЗаполненияОбъекта);
		
		
		
		ВыполнитьКодИзСправочникаНастроек(СтруктураКлюча.ПроцедураЗаполнения,ОписаниеОшибки,ВЫводитьОтладочныеСообщения,
			"Заполнение созданного объекта ссылочного типа",СтруктураКлюча.ИмяМетаданных,ОбрабатываемыйОбъект,ВозвращаемаяСсылка,неопределено,ВходящаяСтруктура,СтруктураРаспознанныхЗначений,
			,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ,истина);
			
			
			ОбрабатываемыйОбъект.ОбменДанными.Загрузка=истина;
			ОбрабатываемыйОбъект.Записать();
			ОбрабатываемыйОбъект.ОбменДанными.Загрузка=ложь;
			
		
		
		
	иначе
		
		
		ОбрабатываемыйОбъект = ВозвращаемаяСсылка.ПолучитьОбъект();
		
		
	КонецЕсли;
	
	
	
	
	возврат(ОбрабатываемыйОбъект);
	
КонецФункции

Процедура Постобработка(ОбрабатываемыйОбъект, знач СправочникСоответствия, СтруктураШапки = неопределено, СтруктураРаспознанныхЗначений = Неопределено,ГоловнойОбъект=неопределено,ОписаниеОшибки="",ВыводитьОтладочныеСообщения=ложь) экспорт  
	Если ГоловнойОбъект=неопределено тогда ГоловнойОбъект=ОбрабатываемыйОбъект; конецЕсли;
	СтруктураСтрокиТабЧасти = СтруктураШапки;    
	СтруктураШапки=СтруктураРаспознанныхЗначений;                                         
	
	ИсточникКода=строка(типзнч(ОбрабатываемыйОбъект));
	для каждого стрПостОбработка из СправочникСоответствия.Постобработка Цикл
		Если стрПостОбработка.НеИспользовать = истина тогда продолжить;конецЕсли;
		
		
		
		Если не ЗначениеЗаполнено(стрПостОбработка.УсловиеПримененияПроцедурыЗаполнения) тогда
			УсловиеВыполнено = истина;
		Иначе
			УсловиеВыполнено = ложь;  
			
			ВыполнитьКодИзСправочникаНастроек(стрПостОбработка.УсловиеПримененияПроцедурыЗаполнения,ОписаниеОшибки,ВЫводитьОтладочныеСообщения,
			ИсточникКода+". Постобработка. Условие применения процедуры заполнения. ",стрПостОбработка.ИмяМетаданных,ОбрабатываемыйОбъект,,ГоловнойОбъект,СтруктураШапки,СтруктураРаспознанныхЗначений,
			СтруктураСТрокиТабЧасти,,УсловиеВЫполнено);
			
			
			//СтрокаПроцедурыПроверки = стрПостОбработка.УсловиеПримененияПроцедурыЗаполнения;
			//СтрокаПроцедурыПроверки = стрЗаменить(СтрокаПроцедурыПроверки,"ПОДСТАНОВКАИМЕНИСВОЙСТВА",стрПостОбработка.ИмяМетаданных);
			//Выполнить(СтрокаПроцедурыПроверки);
		КонецЕсли;
		
		Если не УсловиеВыполнено тогда продолжить;конецЕсли;
		
		ВозвращаемаяСсылка = неопределено;
		Если ЗначениеЗаполнено(стрПОстОбработка.ПроцедураЗаполнения) тогда
			//ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ = стрПостОбработка.Значение;
			//СтрокаЗаполненияОбъекта = стрПостОбработка.ПроцедураЗаполнения;
			//СтрокаЗаполненияОбъекта = стрЗаменить(СтрокаЗаполненияОбъекта,"ПОДСТАНОВКАИМЕНИСВОЙСТВА",стрПостОбработка.ИмяМетаданных);
			//ВЫполнить(СтрокаЗаполненияОбъекта); 
			
			ВыполнитьКодИзСправочникаНастроек(стрПостОбработка.ПроцедураЗаполнения,ОписаниеОшибки,ВЫводитьОтладочныеСообщения,
			ИсточникКода+". Постобработка. Процедура заполнения. ",стрПостОбработка.ИмяМетаданных,ОбрабатываемыйОбъект,ВозвращаемаяСсылка,ГоловнойОбъект,СтруктураШапки,СтруктураРаспознанныхЗначений,
			СтруктураСТрокиТабЧасти,,УсловиеВыполнено);
		КонецЕсли;
		
		Если СтрПОстОбработка.Значение<>неопределено и значениеЗаполнено(СтрПОстОбработка.Значение)  тогда
			ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ = стрПостОбработка.Значение;
			//Если ВозвращаемаяСсылка = неопределено тогда
				выполнить("ОбрабатываемыйОбъект."+стрПостОбработка.ИмяМетаданных+" = ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ;");
			//иначе
			//	выполнить("ВозвращаемаяСсылка."+стрПостОбработка.ИмяМетаданных+" = ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ;");
			//КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры 

функция ОбработатьУдалениеОбъекта(СП_Объект,СтруктураРаспознанныхЗначений)
	          // Заглушка. Здесь потом напишем что делать с сообщениями удаления объекта
			  Успех=истина;
			  Возврат(Успех);
	
КонецФункции


Функция ПрочитанаСтруктураJSON(СП_Объект,ТекстФайлаJSON,СтруктураРаспознанныхЗначений=неопределено)
	JSON = Новый ЧтениеJSON(); 
	попытка
	JSON.УстановитьСтроку(ТекстФайлаJSON);
	Исключение
		СП_Объект.ТекстОшибки = ОписаниеОшибки();
		СП_Объект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.ОшибкаЧтенияJSON;
		СП_Объект.Записать();
        возврат ложь;;
	КонецПопытки;
	СтруктураРаспознанныхЗначений = Новый Структура();
	пока JSON.Прочитать() Цикл
		Если JSON.ТипТекущегоЗначения = ТипЗначенияJson.НачалоОбъекта тогда
			инт_JSONОбмен.НачалоОбъекта(JSON,СтруктураРаспознанныхЗначений);
		иначеЕсли JSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоМассива тогда
			НачальныйМассив = Новый Массив();
			СтруктураРаспознанныхЗначений.Вставить("Объекты",НачальныйМассив);
			инт_JSONОбмен.ЧитатьМассив(JSON,НачальныйМассив);
		иначеЕсли JSON.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства тогда	
			инт_JSONОбмен.ЧитатьСвойство(JSON,СтруктураРаспознанныхЗначений);
		иначе	
			СП_Объект.ТекстОшибки = "Не найдено начало объекта или массива в файле JSON";
			СП_Объект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.ОшибкаЧтенияJSON;
			СП_Объект.Записать();
            возврат ложь;
		КонецЕсли;
	КонецЦикла;	        
	возврат истина;
КонецФункции  

Функция УдалосьОпределитьПравилаСоответствия(текПравило,СтруктураРаспознанныхЗначений,СП_Объект)
	Успех=истина;
	Если не ЗначениеЗаполнено(ТекПравило) тогда
		текПравило = ОпределитьНастройкиСоответствияДляПрочитаннойСтруктуры(СтруктураРаспознанныхЗначений);
		Если не ЗначениеЗаполнено(ТекПравило) тогда 
			СП_Объект.ТекстОшибки = "Не удалось найти правила соответствия";
			СП_Объект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.ОшибкаОпределенияПравилСоответствия;
			СП_Объект.Записать();
			Успех=Ложь;
		конецЕсли; 
	КонецЕсли;
	Возврат(Успех);
КонецФункции


Процедура ПроверкаПереопределенияПравилаСоответствия(текПравило,СтруктураРаспознанныхЗначений,ВыводитьОтладочныеСообщения, КодСправочникаПакетовJSON,ГоловнойОбъект=неопределено)
	ТекстОшибки="";
	УсловиеВыполнено=ложь;
	НаименованиеСтарогоПравила=текПравило.наименование;
	для каждого стр из текПравило.УсловияПереопределенияПравилаОбработки цикл
		ВыполнитьКодИзСправочникаНастроек(стр.УсловиеПереопределения,ТекстОшибки,ВыводитьОтладочныеСообщения,"Условия переопределения правила обработки",
			строка(стр.НомерСтроки),неопределено,,ГоловнойОбъект,СтруктураРаспознанныхЗначений.CAPTION,СтруктураРаспознанныхЗначений,,,УсловиеВЫполнено);
			Если УсловиеВыполнено тогда
				текПравило=стр.Правило;
			Если ВыводитьОтладочныеСообщения тогда                                                      
				
				Сообщить(СтрШаблон("Переопределено правило %1 для сообщения JSON %2 на правило %3",
				НаименованиеСтарогоПравила,строка(КодСправочникаПакетовJSON), стр.Правило.Наименование));
			КонецЕсли;
			прервать; 
		Конецесли;
	КонецЦикла
КонецПроцедуры

Функция УспешноПолучениеОбрабатываемогоОбъектаПоСправочникуПравил(СП_Объект,ОбрабатываемыйОбъект,СтруктураРаспознанныхЗначений,знач текПравило,ВыводитьОтладочныеСообщения,ЭтоНовыйОбъект=ложь)
	Успех=истина;  
	ТекстОшибки="";
	ОбрабатываемыйОбъект = ПолучитьОбрабатываемыйОбъектПоСправочникуСоответствия(
	СтруктураРаспознанныхЗначений.caption,текПравило, СтруктураРаспознанныхЗначений,ТекстОшибки,ВыводитьОтладочныеСообщения,ЭтоНовыйОбъект);
	
	Если ОбрабатываемыйОбъект = неопределено тогда 
		СП_Объект.ТекстОшибки = ТекстОшибки+" Не удалось найти или создать объект для сообщения JSON "+строка(СП_Объект.Код)+", правило "+текПравило.наименование ; 
		Если ВыводитьОтладочныеСообщения тогда
			Сообщить(СП_Объект.ТекстОшибки);
		КонецЕсли;
		СП_Объект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Ошибка;
		СП_Объект.Записать();
		Успех= Ложь;
	конецЕсли;
	            
				
	//Попытка 
	//	
	//Если не ОбрабатываемыйОбъект.Заблокирован() тогда	
	//	
	//ОбрабатываемыйОбъект.Прочитать();
	//ОбрабатываемыйОбъект.Заблокировать();            
	//
	//КонецЕсли;
	//
	//	исключение
	//	СП_Объект.ТекстОшибки = ТекстОшибки+" Не удалось заблокировать объект "+строка(СП_Объект.Код)+", правило "+текПравило.наименование +", "+ОписаниеОшибки()+строка(типЗнч(ОбрабатываемыйОбъект))+" "+ 
	//	строка(ОбрабатываемыйОбъект.Ссылка.УникальныйИдентификатор()); 
	//	Если ВыводитьОтладочныеСообщения тогда
	//		Сообщить(СП_Объект.ТекстОшибки);
	//	КонецЕсли;
	//	СП_Объект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Ошибка;
	//	СП_Объект.Записать();
	//	Успех= Ложь;
	//	
	//КонецПопытки;
	
	возврат(Успех);

	
КонецФункции



Функция НайденоУсловиеОтказаПерезаписи(СП_Объект,ОбрабатываемыйОбъект,знач текПравило,ВыводитьОтладочныеСообщения,Структурашапки,СТруктураРаспознанныхЗначений)
	ТекстОшибки="";
	УсловиеОтказаЗаписиОбъекта	= ПроверкаВыполненияУсловийИзТабЧастиУсловиеОтказаПерезаписи(ОбрабатываемыйОбъект,текПравило.УсловияОтказаПерезаписи,"УсловиеОтказаПерезаписи",строка(ТипЗнч(ОбрабатываемыйОбъект))+". Условия отказа перезаписи",ВыводитьОтладочныеСообщения,ТекстОшибки,СтруктураШапки,СтруктурараспознанныхЗначений);
	Если УсловиеОтказаЗаписиОбъекта=истина тогда
		СП_Объект.ТекстОшибки = "Отказ от перезаписи объекта по условиям, описанным в правилах соответствия, для сообщения JSON "+строка(СП_Объект.Код);
		СП_Объект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Загружено;
		СП_Объект.СсылкаНаОбъект = неопределено;
		СП_Объект.ДатаВремяОбработки = ТекущаяДата();
		СП_Объект.РезультатВ1С="Перезапись объекта заблокирована настройками правил распознания пакетов JSON";
        СП_Объект.Записать();
	КонецЕсли;	

	возврат УсловиеОтказаЗаписиОбъекта;
	
КонецФункции 


Процедура ОжидатьОкончаниеЧтенияJSONВФоне(ИД_ФоновогоЗаданияЧтения,КодСообщенияJSON) экспорт
	
	//Задание=ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ИД_ФоновогоЗаданияЧтения);
	
	//Если не Задание=неопределено тогда
	пока не ДлительныеОперации.ЗаданиеВыполнено(ИД_ФоновогозаданияЧтения) цикл
		
		
		
	КонецЦикла;	                      
	//КонецЕсли;
	
	Запрос=Новый Запрос();
	Запрос.Текст="ВЫБРАТЬ
	             |	СП_СообщенияОбмена.РезультатВ1С КАК РезультатВ1С,
	             |	СП_СообщенияОбмена.Событие КАК Событие,
	             |	СП_СообщенияОбмена.ТекстОшибки КАК ТекстОшибки,
	             |	СП_СообщенияОбмена.СсылкаНаОбъект КАК СсылкаНаОбъект
	             |ИЗ
	             |	Справочник.СП_СообщенияОбмена КАК СП_СообщенияОбмена
	             |ГДЕ
	             |	СП_СообщенияОбмена.Код = &Код";
	Запрос.УстановитьПараметр("Код",КодСообщенияJSON);
	Результат=Запрос.Выполнить();
	Выборка=Результат.Выбрать();
	если ВЫборка.Следующий() и значениеЗаполнено(Выборка.СсылкаНаОбъект) тогда
		  МассивПараметров=Новый Массив;
		  МассивПараметров.Добавить(Выборка.СсылкаНаОбъект);
		  МассивПараметров.Добавить(Выборка.РезультатВ1С); 
  		  МассивПараметров.Добавить(Выборка.Событие);
		  МассивПараметров.Добавить(Выборка.ТекстОшибки);
		  
		  УИД=строка(Новый УникальныйИдентификатор());
		  ФоновыеЗадания.Выполнить("инт_ПроцедурыПоискаСоответствийОбмена.ОбработкаСозданногоОбъекта",МассивПараметров,УИД,"Процедуры после обработки сообщения JSON "+КодСообщенияJSON);
		  
		  
		  
		  
		
	КонецЕсли;
КонецПроцедуры






Процедура ОбработкаСозданногоОбъекта(Ссылка,РезультатВ1С,Событие,ТекстОшибки) экспорт
	Если ТипЗнч(Ссылка)=тип("ДокументСсылка.ЗаказПоставщику") и Ссылка.Проведен тогда		
       	МассивПараметров=Новый Массив();
		МассивПараметров.Добавить(Ссылка);
		МассивПараметров.Добавить(Ссылка.Автор);
		МассивПараметров.Добавить('00010101');
		МассивПараметров.Добавить(0);
		
		
		ФоновыеЗадания.Выполнить("ллл_МодульКазначействоОбщегоНазначения.ллл_АвтоматическоеСозданиеЗаявкиНаОплатуИмпортИОповещение",
		Массивпараметров,строка(Новый уНИКАЛЬНЫЙиДЕНТИФИКАТОР),
		"создание заявки на оплату к "+строка(Ссылка));
	иначеесли типЗнч(Ссылка)=тип("ДокументСсылка.ПриобретениеТоваровУслуг") и Ссылка.Проведен тогда
		
		МассивПараметров=Новый Массив();
		МассивПараметров.Добавить(Ссылка);
		ФоновыеЗадания.Выполнить("ллл_МодульКазначействоОбщегоНазначения.СоздатьЗаявкуНаОплатуНаОснованииПТУ",Массивпараметров,строка(Новый уНИКАЛЬНЫЙиДЕНТИФИКАТОР),
		"создание заявки на оплату к "+строка(Ссылка));
	иначе
		возврат;
	КонецЕсли;
	
		
КонецПроцедуры



Процедура ОбработатьСП_СообщениеВФоне(СП_Объект, ТекПравило,ОжидатьВыполнение=ложь) экспорт
	ЗаданиеЗавершено=ложь;  
	МассивПараметровФоновогоЗадания=Новый Массив();
	МассивПараметровФоновогоЗадания.Добавить(СП_Объект);
	МассивПараметровФоновогоЗадания.Добавить(текПравило);
	МассивПараметровФоновогоЗадания.Добавить(ложь); 
	//МассивПараметровФоновогоЗадания.Добавить(РазрешеноМенятьПравило);
	
	ИД_ФоновогоЗадания=строка(Новый УНикальныйИдентификатор);
	ФЗадание=ФоновыеЗадания.Выполнить("инт_ПроцедурыПоискаСоответствийОбмена.ОбработатьСП_Сообщение",
		МассивПараметровФоновогоЗадания,
		ИД_ФоновогоЗадания,"Обработка сообщения "+СП_Объект.Код); 
    УИД_Фзадания=ФЗадание.УникальныйИдентификатор;
	Если ОжидатьВыполнение тогда	
		ФЗадание.ОжидатьЗавершенияВыполнения();
		ЗаданиеЗавершено=истина;                                                                             
		Если СП_Объект.Событие<>"delete" тогда
			ОбработкаСозданногоОбъекта(СП_Объект,СП_Объект.результатв1С,СП_Объект.Событие,СП_Объект.ТекстОшибки);
		КонецЕсли;
	иначе	                                  
		Если СП_Объект.Событие<>"delete" тогда
			МассивПараметровФоновогоЗаданияОжидания=Новый Массив();
			МассивПараметровФоновогоЗаданияОжидания.Добавить(УИД_Фзадания);
			МассивПараметровФоновогоЗаданияОжидания.Добавить(СП_Объект.Код);
		
			ФЗаданиеОжидания=ФоновыеЗадания.Выполнить("инт_ПроцедурыПоискаСоответствийОбмена.ОжидатьОкончаниеЧтенияJSONВФоне",МассивПараметровФоновогоЗаданияОжидания,
			строка(Новый УНикальныйИдентификатор),"Ожидание окончания чтения сообщения JSON " +СП_Объект.Код);		
		КонецЕсли;	
		
	КонецЕсли;
		
	
		
КонецПроцедуры	










Функция ОбработатьСП_Сообщение(СП_Объект, знач ВходящееПравило,ВыводитьОтладочныеСообщения=ложь) экспорт
	
	ТекПравило=ВходящееПравило;
	Если типЗнч(СП_Объект)=тип("СправочникСсылка.СП_СообщенияОбмена") тогда
		СП_Объект=СП_Объект.ПолучитьОбъект();
		ВыводитьОтладочныеСообщения=ложь;
	КонецЕсли;	
	
	
    ТекстОшибки = ""; 
	СП_Объект.ТекстОшибки="";
	СП_Объект.Результатв1С="";
	
	СтруктураРаспознанныхЗначений=неопределено;
	ТекстФайлаJSON = СП_Объект.ТелоСообщения;
	Если не ПрочитанаСтруктураJSON(СП_Объект,ТекстФайлаJSON,СтруктураРаспознанныхЗначений) тогда
		возврат(ложь);
	КонецЕсли;
		
	//Заглушка для сообщений удаления объекта
	Если СП_Объект.Событие="delete" тогда
		 возврат(ОбработатьУдалениеОбъекта(СП_Объект,СтруктураРаспознанныхЗначений));     	
	КонецЕсли;	
	
	Если не УдалосьОпределитьПравилаСоответствия(текПравило,СтруктураРаспознанныхЗначений,СП_Объект) тогда
		возврат ложь;		
	КонецЕсли;

	//Если РазрешеноМенятьПравило тогда
		ПроверкаПереопределенияПравилаСоответствия(текПравило,СтруктураРаспознанныхЗначений,ВыводитьОтладочныеСообщения, СП_Объект.Код);
	//КонецЕсли;
	
	
	
	
	
	ОбрабатываемыйОбъект=неопределено;                                                                                                                                   
	
	
	Если НайденоУсловиеОтказаПерезаписи(СП_Объект,ОбрабатываемыйОбъект,текПравило,ВыводитьОтладочныеСообщения,СтруктураРаспознанныхЗначений.caption,СтруктураРаспознанныхЗначений) тогда
		возврат истина;
	КонецЕсли;

	
	
	
	
	ЭтоНовыйОбъект=ложь;
	Если не УспешноПолучениеОбрабатываемогоОбъектаПоСправочникуПравил(СП_Объект,ОбрабатываемыйОбъект,СтруктураРаспознанныхЗначений,текПравило,ВыводитьОтладочныеСообщения,ЭтоНовыйОбъект) тогда
		возврат ложь;
	КонецЕсли;
	
	
		
	

	
	//Заполнение шапки
	// В том порядке, в котором они следуют в справочнике инт_СоответствиеОбъектов
	РеквизитыПравила = ТабЧастьРеквизитыПравилСоответствияСвойств(текПравило);
	Для Каждого ТекСтрока Из РеквизитыПравила Цикл
		ИмяКлюча = ТекСтрока.ИмяСвойстваИнтеграции;
		ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ = Неопределено;
		
		Если ИмяКлюча = "detail" Тогда
			ОбрабатываемаяСтруктура = СтруктураРаспознанныхЗначений; 
		ИначеЕсли  ТекСтрока.ТипМетаданных = Перечисления.инт_ТипыМетаданных.ОбъектТабличнаяЧасть ИЛИ ТекСтрока.ТипМетаданных = Перечисления.инт_ТипыМетаданных.РегистрСведения Тогда 
			Если СтруктураРаспознанныхЗначений.Свойство("detail") И ТипЗнч(СтруктураРаспознанныхЗначений.detail) = ТИП("Структура") Тогда								
				ОбрабатываемаяСтруктура = СтруктураРаспознанныхЗначений.detail;				                                                                            			
			КонецЕсли;	
		Иначе
			ОбрабатываемаяСтруктура = СтруктураРаспознанныхЗначений.caption;
		КонецЕсли;
		
		Если ОбрабатываемаяСтруктура.Свойство(ИмяКлюча, ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ) Тогда
			СтруктураПравилСоответствия = Новый Структура("ИмяМетаданных,ТипМетаданных,ПроцедураПоискаСоответствия,ПроцедураЗаполнения,ПравилоСоответствия,ИмяСвойстваИнтеграции,УсловиеОтказаПерезаполнения");
			ЗаполнитьЗначенияСвойств(СтруктураПравилСоответствия, ТекСтрока);
			ЗаписатьЗначениеИзСтруктурыРаспознанныхЗначений(ОбрабатываемыйОбъект, СтруктураПравилСоответствия, ОбрабатываемаяСтруктура,,,ТекстОшибки,ВыводитьОтладочныеСообщения);
		КонецЕсли;
	КонецЦикла;
	
	Постобработка(ОбрабатываемыйОбъект, текПравило, СтруктураРаспознанныхЗначений.caption, СтруктураРаспознанныхЗначений,,ТекстОшибки,ВЫводитьОтладочныеСообщения);
	
	ОбъектЯвляетсяДокументом=ЭтоДокумент(ТекПравило);
	ПроводитьДокумент=ложь;
	
	Если ОбъектЯвляетсяДокументом тогда
		ПроводитьДокумент=ПроверкаВыполненияУсловийИзТабЧасти(ОбрабатываемыйОбъект,текПравило.УсловияПерепроведения,"УсловиеПерепроведения",строка(ТипЗнч(ОбрабатываемыйОбъект))+". Условия перепроведения",ВыводитьОтладочныеСообщения,ТекстОшибки);
	КонецЕсли;	
	
	попытка 
		Если ВыводитьОтладочныеСообщения тогда
			Сообщить(строка(ОбрабатываемыйОбъект.Ссылка));
			Если ОбрабатываемыйОбъект=неопределено тогда
				ТекстОшибки=ТекстОшибки+"В процессе обработки потерян обрабатываемый объект";
				СП_Объект.Прочитать();
				СП_Объект.ТекстОшибки = ТекстОшибки; 
				СП_Объект.РезультатВ1С="не загружено";
				СП_Объект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Ошибка;
				СП_Объект.СсылкаНаОбъект = неопределено;
				СП_Объект.ДатаВремяОбработки = ТекущаяДата();
				СП_Объект.Записать();
				возврат(ложь);
	
			КонецЕсли;	
			
			
		КонецЕсли;	
			ОбрабатываемыйОбъект.Записать();
	исключение         
			ТекстОшибки=ТекстОшибки+"Ошибка записи в обычном режиме, сооб. " +строка(СП_Объект.Код)+Символы.ПС+ОписаниеОшибки();
			ОбрабатываемыйОбъект.ОбменДанными.Загрузка = истина; 
			ПроводитьДокумент=ложь;
			попытка
				ОбрабатываемыйОбъект.Записать();
				
			исключение
			    ТекстОшибки=ТекстОшибки+"Ошибка записи в режиме загрузки, сооб. " +строка(СП_Объект.Код)+ Символы.ПС+ОписаниеОшибки();
			
			КонецПопытки;
	КонецПопытки;     
			

	
	Если ПроводитьДокумент  тогда 
		
		Если не ОбрабатываемыйОбъект.ПометкаУдаления тогда
			попытка                  
			ОбрабатываемыйОбъект.ОбменДанными.Загрузка = ложь;
			ОбрабатываемыйОбъект.записать(РежимЗаписиДокумента.Проведение,РежимПроведенияДокумента.Неоперативный);
			исключение
				ТекстОшибки=ТекстОшибки+"Сбой проведения документа"+Символы.ПС+ОписаниеОшибки();
				СП_Объект.Прочитать();
				СП_Объект.ТекстОшибки = ТекстОшибки;
				СП_Объект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Ошибка;
				СП_Объект.СсылкаНаОбъект = ОбрабатываемыйОбъект.Ссылка;
				СП_Объект.ДатаВремяОбработки = ТекущаяДата();
				СП_Объект.Записать();
				возврат(ложь);
			КонецПопытки;   
		иначе
		    ТекстОшибки=ТекстОшибки+Символы.пс+"Не удалось провести документ, т.к. он помечен на удаление";
		КонецЕсли;
	КонецЕсли;	
	//ОбрабатываемыйОбъект.Разблокировать();
	
	//ТекстОшибки = "";
	СП_Объект.ТекстОшибки = ТекстОшибки;
	СП_Объект.СостояниеСообщения = Перечисления.СП_СостоянияСообщений.Загружено;
	СП_Объект.СсылкаНаОбъект = ОбрабатываемыйОбъект.Ссылка; 
	Если ЭтоНовыйОбъект тогда
		СП_Объект.РезультатВ1С="Создан новый объект";
	иначе
		СП_Объект.РезультатВ1С="Обновлен существующий объект";
	КонецЕсли;	
	
	СП_Объект.ДатаВремяОбработки = ТекущаяДата();
	СП_Объект.Записать();
	
	//Оповестить("РаспознаноСообщениJSON",Новый Структура("КодСообщенияJSON",СП_объект.Код),);
	
    Возврат Истина;
КонецФункции 


Функция ПроверкаВыполненияУсловийИзТабЧасти(ОбрабатываемыйОбъект,ТабЧасть,ИмяУсловия,ИсточникКода,ВыводитьОтладочныеСообщения=ложь,ОписаниеОшибки="")  
	
	Если ИмяУсловия="УсловиеОтказаПерезаписи" тогда
		УсловиеВыполнено=ложь;
	иначе
		УсловиеВыполнено=истина;
	КонецЕсли;	
	
	
	для каждого стр из ТабЧасть цикл 
		ИдентификаторСтрочкиПравил=строка(стр.НомерСтроки);
		Если не УсловиеВыполнено тогда 
			прервать;
		иначе
			ВыполнитьКодИзСправочникаНастроек(стр[ИмяУсловия],ОписаниеОшибки,ВыводитьОтладочныеСообщения,ИсточникКода,
			ИдентификаторСтрочкиПравил,ОбрабатываемыйОбъект,,,,,,,УсловиеВыполнено);
		конецЕсли;	
	КонецЦикла;	
		
	возврат(УсловиеВыполнено);	
КонецФункции   


Функция ПроверкаВыполненияУсловийИзТабЧастиУсловиеОтказаПерезаписи(ОбрабатываемыйОбъект,ТабЧасть,ИмяУсловия,ИсточникКода,ВыводитьОтладочныеСообщения=ложь,ОписаниеОшибки="",СтруктураШапки,СтруктураРаспознанныхЗначений)  
	
УсловиеВыполнено=ложь;	
	
	
	для каждого стр из ТабЧасть цикл 
		ИдентификаторСтрочкиПравил=строка(стр.НомерСтроки);
		Если УсловиеВыполнено тогда 
			прервать;
		иначе
			ВыполнитьКодИзСправочникаНастроек(стр[ИмяУсловия],ОписаниеОшибки,ВыводитьОтладочныеСообщения,ИсточникКода,
			ИдентификаторСтрочкиПравил,ОбрабатываемыйОбъект,,,Структурашапки,СтруктураРаспознанныхЗначений,,,УсловиеВыполнено);
		конецЕсли;	
	КонецЦикла;	
		
	возврат(УсловиеВыполнено);	
КонецФункции 





Функция ЭтоДокумент(ТекПравило)
	Если стрНайти(текПравило.ИмяОбъектаМетаданных,"Документ.")>0 тогда
		возврат(истина);
	иначе
		возврат(ложь);
	КонецЕсли;
	
КонецФункции


Функция НайтиВидХарактеристикиДопРеквизитаПоИмени(имя) экспорт
	Ответ = ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.ПустаяСсылка();
	Запрос  =  Новый Запрос("
	|ВЫБРАТЬ
	|	ДополнительныеРеквизитыИСведения.Ссылка КАК Ссылка
	|ИЗ
	|	ПланВидовХарактеристик.ДополнительныеРеквизитыИСведения КАК ДополнительныеРеквизитыИСведения
	|ГДЕ
	|	ДополнительныеРеквизитыИСведения.Имя  =  &Имя");
	
	Запрос.УстановитьПараметр("Имя",имя);
	РезультатЗапроса  =  Запрос.Выполнить();
	Выборка  =  РезультатЗапроса.Выбрать();
	если Выборка.Следующий() тогда
		Ответ = Выборка.Ссылка;
	КонецЕсли;
	возврат(Ответ);
КонецФункции	

Функция ПолучитьСправочникНастроекСоответствияПоИмениМетаданных(строкаИмениМетаданных,СтрокаОшибок, Успех,subtype = неопределено) экспорт
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	инт_СоответствиеОбъектовЗначениямИнтеграции.Ссылка КАК Ссылка
	               |ИЗ
	               |	Справочник.инт_СоответствиеОбъектовЗначениямИнтеграции КАК инт_СоответствиеОбъектовЗначениямИнтеграции
	               |ГДЕ
	               |	инт_СоответствиеОбъектовЗначениямИнтеграции.ПометкаУдаления = ЛОЖЬ
	               |	И (инт_СоответствиеОбъектовЗначениямИнтеграции.ИмяОбъектаМетаданных = &строкаИмениМетаданных
	               |			ИЛИ инт_СоответствиеОбъектовЗначениямИнтеграции.ИмяОбъекта = &subtype
	               |				И &ИскатьSubtype)
	               |	И инт_СоответствиеОбъектовЗначениямИнтеграции.АвтоматическоеИспользованиеПравила = ИСТИНА
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	инт_СоответствиеОбъектовЗначениямИнтеграции.ДатаИзменения УБЫВ";
	Запрос.УстановитьПараметр("строкаИмениМетаданных",строкаИмениМетаданных);
	Запрос.УстановитьПараметр("subtype",subtype);
	Запрос.УстановитьПараметр("Искатьsubtype",значениеЗаполнено(subtype));
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	Если Выборка.Следующий() тогда
		Успех = истина;
		возврат(ВЫборка.Ссылка);
	иначе	                    
		Успех = ложь;
		СтрокаОшибок = "Не задан справочник соответствия для распознанной структуры файла JSON";
		возврат(Справочники.инт_СоответствиеОбъектовЗначениямИнтеграции.ПустаяСсылка());
	КонецЕсли;
	
КонецФункции	

Функция ПолучитьСтрокуСозданияОбъектаПоСтрокеИмениМетаданных(ИмяМетаданных)  
	
	
	
	Для каждого мет из Метаданные.Справочники Цикл
		Если мет.ПолноеИмя() = имяМетаданных тогда
			строкаСозданияОбъекта = "ОбрабатываемыйОбъект = Справочники."+мет.имя+".СоздатьЭлемент();";
			возврат(СтрокаСозданияОбъекта);
		КонецЕсли;
	КонецЦикла;
	
	Для каждого мет из Метаданные.Документы Цикл
		Если мет.ПолноеИмя() = имяМетаданных тогда
			строкаСозданияОбъекта = "ОбрабатываемыйОбъект = Документы."+мет.имя+".СоздатьДокумент();";
			возврат(СтрокаСозданияОбъекта);
		КонецЕсли;
	КонецЦикла;
	
	Для каждого мет из Метаданные.РегистрыСведений Цикл
		Если мет.ПолноеИмя() = имяМетаданных тогда
			строкаСозданияОбъекта = "ОбрабатываемыйОбъект = РегистрыСведений."+мет.имя+".СоздатьМенеджерЗаписи();";
			возврат(СтрокаСозданияОбъекта);
		КонецЕсли;
	КонецЦикла;
	
КонецФункции	


Функция ПолучитьСтруктуруПравилСоответствияСвойстваJSONРеквизитамОбъекта(ИмяСвойства,СправочникПравилСоответствия,СтруктураПравилСоответствия) экспорт
	Успех = ложь;
	СтруктураПравилСоответствия = Новый Структура("ИмяМетаданных,ТипМетаданных,ПроцедураПоискаСоответствия,ПроцедураЗаполнения,ПравилоСоответствия,ИмяСвойстваИнтеграции,УсловиеОтказаПерезаполнения");
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ИмяМетаданных КАК ИмяМетаданных,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ТипМетаданных КАК ТипМетаданных,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ПроцедураПоискаСоответствия КАК ПроцедураПоискаСоответствия,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ПроцедураЗаполнения КАК ПроцедураЗаполнения,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ПравилоСоответствия КАК ПравилоСоответствия,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ИмяСвойстваИнтеграции КАК ИмяСвойстваИнтеграции,
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.УсловиеОтказаПерезаполнения КАК УсловиеОтказаПерезаполнения
	|ИЗ
	|	Справочник.инт_СоответствиеОбъектовЗначениямИнтеграции.Реквизиты КАК инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты
	|ГДЕ
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ИмяСвойстваИнтеграции  =  &ИмяСвойстваИнтеграции
	|	И инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.Ссылка  =  &Ссылка
	|	И инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ЭтоКлюч  =  ЛОЖЬ
	|	И инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.НеИспользовать  =  ЛОЖЬ";
	Запрос.УстановитьПараметр("ИмяСвойстваИнтеграции",ИмяСвойства);
	Запрос.УстановитьПараметр("Ссылка",СправочникПравилСоответствия);
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	Если Выборка.Следующий() тогда
		ЗаполнитьЗначенияСвойств(СтруктураПравилСоответствия,Выборка);
		Успех = истина;
	КонецЕсли;
	
	возврат(Успех);
	
КонецФункции

Функция ТабЧастьРеквизитыПравилСоответствияСвойств(СправочникПравилСоответствия)
	
	Запрос = Новый Запрос();
	Запрос.Текст = 
		"ВЫБРАТЬ
        |   Т.ИмяМетаданных КАК ИмяМетаданных,
        |   Т.ТипМетаданных КАК ТипМетаданных,
        |   Т.ПроцедураПоискаСоответствия КАК ПроцедураПоискаСоответствия,
        |   Т.ПроцедураЗаполнения КАК ПроцедураЗаполнения,
        |   Т.ПравилоСоответствия КАК ПравилоСоответствия,
        |   Т.ИмяСвойстваИнтеграции КАК ИмяСвойстваИнтеграции,
        |   Т.УсловиеОтказаПерезаполнения КАК УсловиеОтказаПерезаполнения,
        |   Т.ТипМетаданных = ЗНАЧЕНИЕ(Перечисление.инт_ТипыМетаданных.ОбъектТабличнаяЧасть) КАК Порядок
        |ИЗ
        |   Справочник.инт_СоответствиеОбъектовЗначениямИнтеграции.Реквизиты КАК Т
        |ГДЕ
        |   Т.Ссылка = &Ссылка
        |   И Т.ЭтоКлюч = ЛОЖЬ
        |   И Т.НеИспользовать = ЛОЖЬ
        |
        |УПОРЯДОЧИТЬ ПО
        |   Т.НомерСтроки,
        |   Порядок";
	
	Запрос.УстановитьПараметр("Ссылка",СправочникПравилСоответствия);
	Результат = Запрос.Выполнить().Выгрузить();
	
	Возврат Результат;
	
КонецФункции


Функция ЗаписатьЗначениеИзСтруктурыРаспознанныхЗначений(
	ОбрабатываемыйОбъект,
	СтруктураПравилСоответствия, 
	СтруктураРаспознанныхЗначений,
	СтруктураШапки = неопределено,
	ГоловнойОбъект=неопределено,
	ОписаниеОшибки="",
	ВыводитьОтладочныеСообщения=ложь) экспорт       
	
	ИсточникКода=строка(ТипЗнч(ОбрабатываемыйОбъект));
	ИдентификаторСтрочкиПравил=структураПравилСоответствия.ИмяМетаданных;
	
	Если ГоловнойОбъект=неопределено тогда
		ГоловнойОбъект=ОбрабатываемыйОбъект;	
	КонецЕсли;
	
	Если СтруктураШапки = неопределено тогда
		СтруктураШапки = СтруктураРаспознанныхЗначений;
		СтруктураСтрокиТабЧасти = Новый Структура(); 
	иначе
		СтруктураСтрокиТабЧасти = СтруктураРаспознанныхЗначений;
	КонецЕсли;
	Успех = ложь;
	ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ = неопределено;
	Если СтруктураРаспознанныхЗначений.Свойство(структураПравилСоответствия.ИмяСвойстваИнтеграции,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ) = ложь тогда 
		возврат(ложь);
	КонецЕсли;
	
	ОтказПерезаполнения = ложь;
	Если ЗначениеЗаполнено(СтруктураПравилСоответствия.УсловиеОтказаПерезаполнения) тогда
		УсловиеВЫполнено = ложь;
		ВыполнитьКодИзСправочникаНастроек(СтруктураПравилСоответствия.УсловиеОтказаПерезаполнения,ОписаниеОшибки,ВыводитьОтладочныеСообщения,
		ИсточникКода+". Условие отказа перезаполнения.",структураПравилСоответствия.ИмяМетаданных,
		ОбрабатываемыйОбъект,,ГоловнойОбъект,СтруктураШапки,СтруктураРаспознанныхЗначений,СтруктураСтрокиТабЧасти,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ,УсловиеВыполнено);
		
		//Выполнить(СтруктураПравилСоответствия.УсловиеОтказаПерезаполнения);
		Если УсловиеВЫполнено тогда возврат(ложь);конецЕсли;
	КонецЕсли;
	
	Если СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.ПолеСтрокиТабличнойЧасти или 
		СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.ДополнительныеРеквизиты или 
		СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.РегистрСведения тогда
		
		ВозвращаемаяСсылка = неопределено;
		_Команда = СтруктураПравилСоответствия.ПроцедураПоискаСоответствия;
		
		Если ЗначениеЗаполнено(_Команда) тогда
			
			ВыполнитьКодИзСправочникаНастроек(_Команда,ОписаниеОшибки,ВыводитьОтладочныеСообщения,
				ИсточникКода+". Процедура поиска соответствия.",структураПравилСоответствия.ИмяМетаданных,
				ОбрабатываемыйОбъект,ВозвращаемаяСсылка,ГоловнойОбъект,СтруктураШапки,СтруктураРаспознанныхЗначений,СтруктураСтрокиТабЧасти,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ,истина);
			
		КонецЕсли;
		
		Если ВозвращаемаяСсылка = неопределено и ЗначениеЗаполнено(СтруктураПравилСоответствия.ПроцедураЗаполнения) тогда  
			_Команда = СтруктураПравилСоответствия.ПроцедураЗаполнения;
			Если ЗначениеЗаполнено(_Команда) тогда
				//_команда = стрЗаменить(_Команда,"ПОДСТАНОВКАИМЕНИСВОЙСТВА",СтруктураПравилСоответствия.ИмяМетаданных);
				//выполнить(_команда); 
				ВыполнитьКодИзСправочникаНастроек(_Команда,ОписаниеОшибки,ВыводитьОтладочныеСообщения,
				ИсточникКода+". Процедура заполнения.",структураПравилСоответствия.ИмяМетаданных,
				ОбрабатываемыйОбъект,,ГоловнойОбъект,СтруктураШапки,СтруктураРаспознанныхЗначений,СтруктураСтрокиТабЧасти,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ,истина);
			КонецЕсли;
			
			Если ВозвращаемаяСсылка = неопределено тогда возврат(ложь);конецЕсли;
		конецЕсли;
		
		
		Если ВозвращаемаяСсылка<>неопределено тогда
			выполнить("ВозвращаемаяСсылка."+СтруктураПравилСоответствия.ИмяМетаданных+" = ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ;");
			возврат(истина);
		конецЕсли;
		
		Если СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.РегистрСведения И  ЗначениеЗаполнено(СтруктураПравилСоответствия.ПравилоСоответствия) Тогда	
				СтруктураРегистра = ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ;			
			ОбработкаРегистраСведений(СтруктураРегистра,СтруктураПравилСоответствия.ПравилоСоответствия, ОбрабатываемыйОбъект);
		КонецЕсли;
		
		
	иначеЕсли (
		СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.НезависимыйОбъект
		или
		СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.ПодчиненныйОбъект
		
		) и ЗначениеЗаполнено(СтруктураПравилСоответствия.ПравилоСоответствия) тогда 
		
		возврат(ВыполнитьПрисвоениеСсылочногоТипа(СтруктураПравилСоответствия,ПодстановкаПараметраЗначения,ОбрабатываемыйОбъект,СтруктураРаспознанныхЗначений));
		
	иначеЕсли СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.ОбъектТабличнаяЧасть и 
		ЗначениеЗаполнено(СтруктураПравилСоответствия.ПравилоСоответствия) тогда	
		СсылкаНаТабЧасть = неопределено;
		Выполнить("СсылкаНаТабЧасть = ОбрабатываемыйОбъект."+СтруктураПравилСоответствия.ИмяМетаданных+";");
		ТелоМассиваJSON = ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ;
		ОбработкаТабличнойЧасти(СсылкаНаТабЧасть,ТелоМассиваJSON,СтруктураПравилСоответствия.ПравилоСоответствия,СтруктураШапки,ОбрабатываемыйОбъект,ОписаниеОшибки,ВЫводитьОтладочныеСообщения);
        // выполняем процедуру заполнения после обработки табличной части
        КомандаЗаполнения = СтруктураПравилСоответствия.ПроцедураЗаполнения;
        
        Если Не ПустаяСтрока(КомандаЗаполнения) тогда
            ВыполнитьКодИзСправочникаНастроек(КомандаЗаполнения,ОписаниеОшибки,ВыводитьОтладочныеСообщения,
				ИсточникКода+". Процедура заполнения.",структураПравилСоответствия.ИмяМетаданных,
				ОбрабатываемыйОбъект,,ГоловнойОбъект,СтруктураШапки,СтруктураРаспознанныхЗначений,СтруктураСтрокиТабЧасти,"",истина);
        КонецЕсли;
		
	иначе
		Если  ЗначениеЗаполнено(СтруктураПравилСоответствия.ПроцедураПоискаСоответствия) тогда 
			
			_Команда = СтруктураПравилСоответствия.ПроцедураПоискаСоответствия;
			ВозвращаемаяСсылка = неопределено;
			//_команда = стрЗаменить(_Команда,"ПОДСТАНОВКАИМЕНИСВОЙСТВА",СтруктураПравилСоответствия.ИмяМетаданных);
			//Выполнить(_Команда);
			
			ВыполнитьКодИзСправочникаНастроек(_Команда,ОписаниеОшибки,ВыводитьОтладочныеСообщения,
				ИсточникКода+". Процедура поиска соответствия.",структураПравилСоответствия.ИмяМетаданных,
				ОбрабатываемыйОбъект,ВозвращаемаяСсылка,ГоловнойОбъект,СтруктураШапки,СтруктураРаспознанныхЗначений,СтруктураСтрокиТабЧасти,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ,истина);
			
			
			Если значениеЗаполнено(ВозвращаемаяСсылка) тогда			
				Выполнить("ОбрабатываемыйОбъект."+СтруктураПравилСоответствия.ИмяМетаданных+" = ВозвращаемаяСсылка;");
			иначе
				Если ЗначениеЗаполнено(СтруктураПравилСоответствия.ПроцедураЗаполнения) тогда 
					_Команда = СтруктураПравилСоответствия.ПроцедураЗаполнения;
					ВыполнитьКодИзСправочникаНастроек(_Команда,ОписаниеОшибки,ВыводитьОтладочныеСообщения,
						ИсточникКода+". Процедура заполнения.",структураПравилСоответствия.ИмяМетаданных,
						ОбрабатываемыйОбъект,ВозвращаемаяСсылка,ГоловнойОбъект,СтруктураШапки,СтруктураРаспознанныхЗначений,СтруктураСтрокиТабЧасти,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ,истина);
					Если значениеЗаполнено(ВозвращаемаяСсылка) тогда			
						Выполнить("ОбрабатываемыйОбъект."+СтруктураПравилСоответствия.ИмяМетаданных+" = ВозвращаемаяСсылка;");
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		иначеЕсли ЗначениеЗаполнено(СтруктураПравилСоответствия.ПроцедураЗаполнения) тогда 
			ВыполнитьКодИзСправочникаНастроек(СтруктураПравилСоответствия.ПроцедураЗаполнения,
				ОписаниеОшибки,ВыводитьОтладочныеСообщения, ИсточникКода, ИдентификаторСтрочкиПравил, 
				ОбрабатываемыйОбъект, ,	ГоловнойОбъект,	СтруктураШапки,СтруктураРаспознанныхЗначений,
				СтруктураСТрокиТабЧасти,ПодстановкаПараметраЗначения,истина);
		Иначе
			ВыполнитьПрисвоениеПростейшегоТипа(СтруктураПравилСоответствия,ПодстановкаПараметраЗначения,ОбрабатываемыйОбъект);			
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции 


Функция ВыполнитьПрисвоениеСсылочногоТипа(СтруктураПравилСоответствия,ПодстановкаПараметраЗначения,ОбрабатываемыйОбъект,СтруктураРаспознанныхЗначений,ОписаниеОшибки="",ВыводитьОтладочныеСообщения=ложь)
	    _ИмяКлючаВСправочникеСоответствия = НайтиИмяКлючаПОСправочникуСоответствия(СтруктураПравилСоответствия.ПравилоСоответствия);
		СтруктураДляПоискаОбъекта = Новый Структура();
		Если Значениезаполнено(_ИмяКлючаВСправочникеСоответствия) тогда
			СтруктураДляПоискаОбъекта.Вставить(_ИмяКлючаВСправочникеСоответствия,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ);
		иначе
			СтруктураДляПоискаОбъекта.Вставить(структураПравилСоответствия.ИмяСвойстваИнтеграции,ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ);
		КонецЕсли;
		
		НайденныйСозданныйОбъект = ПолучитьОбрабатываемыйОбъектПоСправочникуСоответствия(СтруктураДляПоискаОбъекта,
		СтруктураПравилСоответствия.ПравилоСоответствия,
		СтруктураРаспознанныхЗначений,ОписаниеОшибки,ВыводитьОтладочныеСообщения);
		
		Если НайденныйСозданныйОбъект<>неопределено тогда 
			Постобработка(НайденныйСозданныйОбъект,СтруктураПравилСоответствия.ПравилоСоответствия,СтруктураДляПоискаОбъекта, СтруктураРаспознанныхЗначений,,ОписаниеОшибки,ВыводитьОтладочныеСообщения);
			Если НайденныйСозданныйОбъект.ЭтоНовый() тогда
				НайденныйСозданныйОбъект.ОбменДанными.Загрузка = истина;
				Если СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.ПодчиненныйОбъект тогда
					НайденныйСозданныйОбъект.Владелец = ОбрабатываемыйОбъект.Ссылка;
				КонецЕсли;
				
				НайденныйСозданныйОбъект.Записать();
			КонецЕсли;
			ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ = НайденныйСозданныйОбъект.Ссылка;
			Выполнить("ОбрабатываемыйОбъект."+СтруктураПравилСоответствия.ИмяМетаданных+" = ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ;");
			возврат(истина);
		иначе	
			возврат(ложь);
		КонецЕсли;
КонецФункции


Процедура ВыполнитьПрисвоениеПростейшегоТипа(СтруктураПравилСоответствия,ПодстановкаПараметраЗначения,ОбрабатываемыйОбъект)
	Если СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.Булево тогда
		ПодстановкаПараметраЗначения = Булево(ПодстановкаПараметраЗначения);
	КонецЕсли;
	
	Если СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.Строка тогда
		ПодстановкаПараметраЗначения = Строка(ПодстановкаПараметраЗначения);
		ПодстановкаПараметраЗначения = Стрзаменить(ПодстановкаПараметраЗначения,Символы.Нпп,"");
		ПодстановкаПараметраЗначения = СокрЛП(ПодстановкаПараметраЗначения);
	КонецЕсли;
	
	Если СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.Число тогда
		ПодстановкаПараметраЗначения = Число(ПодстановкаПараметраЗначения);
		
	КонецЕсли;
	
	Если СтруктураПравилСоответствия.ТипМетаданных = Перечисления.инт_ТипыМетаданных.Дата тогда
		
	КонецЕсли;
	
	
	Выполнить("ОбрабатываемыйОбъект."+СтруктураПравилСоответствия.ИмяМетаданных+" = ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ;");

КонецПроцедуры


Процедура ОбработкаТабличнойЧасти(ТабЧасть,МассивJSON,знач ПравилоОбработкиТабЧасти,СтруктураШапки,ГоловнойОбъект,ОписаниеОшибки="",ВыводитьОтладочныеСообщения=ложь)
	
	Если ЗначениеЗаполнено(ПравилоОбработкиТабЧасти) тогда
		
		ПроверкаПереопределенияПравилаСоответствия(ПравилоОбработкиТабЧасти,СтруктураШапки,ВыводитьОтладочныеСообщения, "",ГоловнойОбъект);
		
	КонецЕсли;
	
	ТабЧасть.Очистить();
	для каждого ЭлементМассива из МассивJSON Цикл
		ОбработкаСТрокиТабличнойЧасти(ТабЧасть.Добавить(),ЭлементМассива,ПравилоОбработкиТабЧасти,СтруктураШапки,ГоловнойОбъект,ОписаниеОшибки,	ВыводитьОтладочныеСообщения);
	КонеЦЦикла;
	
КонецПроцедуры

Процедура ОбработкаСтрокиТабличнойЧасти(ОбрабатываемыйОбъект, СтруктураJSON, знач ПравилоОбработкиТабЧасти, СтруктураШапки,ГоловнойОбъект,ОписаниеОшибки="",ВыводитьОтладочныеСообщения=ложь)
	РеквизитыПравила = ТабЧастьРеквизитыПравилСоответствияСвойств(ПравилоОбработкиТабЧасти);
	Для Каждого ТекСтрока Из РеквизитыПравила Цикл
		ИмяКлюча = ТекСтрока.ИмяСвойстваИнтеграции;
		ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ = Неопределено;
		
		Если СтруктураJSON.Свойство(ИмяКлюча, ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ) Тогда
			СтруктураПравилСоответствия = Новый Структура("ИмяМетаданных,ТипМетаданных,ПроцедураПоискаСоответствия,ПроцедураЗаполнения,ПравилоСоответствия,ИмяСвойстваИнтеграции,УсловиеОтказаПерезаполнения");
			ЗаполнитьЗначенияСвойств(СтруктураПравилСоответствия, ТекСтрока);
			ЗаписатьЗначениеИзСтруктурыРаспознанныхЗначений(ОбрабатываемыйОбъект, СтруктураПравилСоответствия, СтруктураJSON, СтруктураШапки,ГоловнойОбъект,ОписаниеОшибки,ВыводитьОтладочныеСообщения);
		КонецЕсли;
	КонецЦикла;
	
	Постобработка(ОбрабатываемыйОбъект, ПравилоОбработкиТабЧасти, СтруктураJSON,СтруктураШапки,ГоловнойОбъект,ОписаниеОшибки,ВЫводитьОтладочныеСообщения);
	
КонецПРоцедуры

Функция НайтиИмяКлючаПОСправочникуСоответствия(СправочникСоответствия) экспорт
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ИмяСвойстваИнтеграции КАК ИмяСвойстваИнтеграции
	|ИЗ
	|	Справочник.инт_СоответствиеОбъектовЗначениямИнтеграции.Реквизиты КАК инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты
	|ГДЕ
	|	инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.ЭтоКлюч  =  ИСТИНА
	|	И инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.Ссылка  =  &Ссылка
	|	И инт_СоответствиеОбъектовЗначениямИнтеграцииРеквизиты.Ссылка.ПометкаУдаления  =  ЛОЖЬ";
	Запрос.УстановитьПараметр("Ссылка",СправочникСоответствия);
	Результат = Запрос.Выполнить();
	Выборка = Результат.ВЫбрать();
	Если Выборка.Следующий() тогда
		возврат(Выборка.ИмяСвойстваИнтеграции);
	иначе
		возврат("");
	КонецЕсли;
	
КонецФункции	

Функция ПолучитьСвойствоКодРС() экспорт
	
	СвойствоКодРС = ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.ПустаяСсылка();
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ
	|	ДополнительныеРеквизитыИСведения.Ссылка КАК Ссылка
	|ИЗ
	|	ПланВидовХарактеристик.ДополнительныеРеквизитыИСведения КАК ДополнительныеРеквизитыИСведения
	|ГДЕ
	|	ДополнительныеРеквизитыИСведения.Имя  =  ""КодРС""";
	Результат = Запрос.Выполнить();
	Выборка = результат.Выбрать();
	Если Выборка.Следующий() тогда
		СвойствоКодРС = Выборка.Ссылка;
		//иначе
		//	возврат;
	КонецЕсли;
	
	возврат(СвойствоКодРС);
	
	
КонецФункции	

Функция ОпределитьНастройкиСоответствияДляПрочитаннойСтруктуры(РаспознаннаяСтруктура) экспорт
	перем head;
	перем Object_type;
	перем subtype;
	перем МетаданныеВерхнегоУровня;
	
	
	
	МетаданныеВерхнегоУровня = неопределено;
	
	УспехОперации = истина;
	ТекстОшибки = "";
	head = инт_JSONОбмен.ПолучитьСтруктуруHeadРаспознаннойСтруктурыФайлаJSON(РаспознаннаяСтруктура,ТекстОшибки,УспехОперации);
	
	Если не УспехОперации  тогда возврат(неопределено);конецЕсли;
	
	МетаданныеВерхнегоУровня = инт_JSONОбмен.ПолучитьМетаданныеВерхнегоУровня(head,ТекстОшибки,Успехоперации);
	
	Если не УспехОперации  тогда возврат(неопределено);конецЕсли;
	
	МетаданныеВторогоУровня = инт_JSONОбмен.ПолучитьМетаданныеВторогоУровня(МетаданныеВерхнегоУровня,head,ТекстОшибки,Успехоперации);
	
	Если УспехОперации  тогда 
		
		СтрокаДляПоискаНастроекСоответствияДляПрочитаннойСтруктуры = инт_JSONОбмен.ПолучитьСтрокуПоискаНастроекПоМетаданным(МетаданныеВторогоУровня);
		
	Иначе
		
		СтрокаДляПоискаНастроекСоответствияДляПрочитаннойСтруктуры = "";
		
	КонецЕсли;
	ТекстОшибки = "";
	Правило = ПолучитьСправочникНастроекСоответствияПОИмениМетаданных(
		СтрокаДляПоискаНастроекСоответствияДляПрочитаннойСтруктуры, ТекстОшибки, Успехоперации,РаспознаннаяСтруктура.head.subtype);
	
	Возврат Правило;
	
	
КонецФункции 

Функция ПолучитьСоставныеЧастиDOC_ID(знач DOC_ID) экспорт
	//Устарело, не используется
	СтруктураВозврата = Новый Структура("DA_DATE,DA_DATE_Строкой,DA_NO",'00010101',"","");
	МассивЗначений = стрРазделить(DOC_ID,"|",ложь);
	Если МассивЗначений.Количество()<>2 тогда возврат(СтруктураВозврата);конецЕсли;
	
	DA_DATE_строкой = МассивЗначений[0];
	СтруктураВозврата.DA_DATE_строкой = DA_DATE_строкой;
	СтруктураОтветаНаПроверкуДаты = инт_JSONОбмен.ЭтоДата(DA_DATE_строкой);
	Если СтруктураОтветаНаПроверкуДаты.ЭтоДата = истина тогда
		СтруктураВозврата.DA_DATE = СтруктураОтветаНаПроверкуДаты.ЗначениеДаты;
	КонецЕсли;
	
	СтруктураВозврата.DA_NO = МассивЗначений[1];
	Возврат(СтруктураВозврата);
КонецФункции 

// Ищет документ по номеру и даты без учета префикса
//
// Параметры:
//  ИмяДокумента    - Строка - Описание имени документа из метаданных,
//                    например, "РеализацияТоваровУслуг"
//  НомерДокумента  - Строка - номер по которму искать
//                    например, "53319"
//  Префикс         - Строка - пользовательский префикс
//                    например, "К"
//  ДатаДокумента   - Дата - дата документа
//
// Возвращаемое значение:
//   ДокументСсылка или Неопределено   - найденный документ или неопределено
//
Функция ДокументПоНомеруИДате(ИмяДокумента, НомерДокумента, Префикс = "", ДатаДокумента = Неопределено) Экспорт
	
	Результат = Неопределено;
	Если Метаданные.Документы.Найти(ИмяДокумента) = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Номер = ПрефиксацияОбъектовКлиентСервер.УдалитьПрефиксыИзНомераОбъекта(НомерДокумента, Истина, Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ДокументЕРП.Ссылка КАК Ссылка
	|ИЗ
	|	Документ.%ИмяДокумента% КАК ДокументЕРП
	|ГДЕ
	|	ДокументЕРП.Номер ПОДОБНО &Номер 
	|	И (ДокументЕРП.Дата = &Дата ИЛИ &ДатаНеопределена)";
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "%ИмяДокумента%", ИмяДокумента);
	
	Запрос.УстановитьПараметр("Номер", СтрШаблон("%%-%1%2", Префикс, Номер));
	Запрос.УстановитьПараметр("Дата", ДатаДокумента);
	Запрос.УстановитьПараметр("ДатаНеопределена", ДатаДокумента = Неопределено) ;
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если Не РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Если Выборка.Следующий() Тогда
			Результат = Выборка.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ДокументПоНомеруИДате()

Процедура ОбработкаРегистраСведений(СтруктураРегистра ,ПравилоСоответствия, ОбрабатываемыйОбъект)
   	 
	Если ЗначениеЗаполнено(ПравилоСоответствия)
		И ТипЗнч(ПравилоСоответствия) = Тип("СправочникСсылка.инт_СоответствиеОбъектовЗначениямИнтеграции") Тогда
		Если НЕ ПравилоСоответствия.ИмяОбъекта = "" Тогда
			
			ТаблицаРеквизитов 				= ПравилоСоответствия.Реквизиты;                
			МетаданныеРегистраСведений 		= Метаданные.РегистрыСведений[ПравилоСоответствия.ИмяОбъекта]; 	
			
			СсылкаНаОбъект 					= ОбрабатываемыйОбъект.Ссылка;
			
			Если Не ЗначениеЗаполнено(СсылкаНаОбъект) Тогда
				СсылкаНаОбъект = Справочники[ОбрабатываемыйОбъект.Метаданные().Имя].ПолучитьСсылку();
				ОбрабатываемыйОбъект.УстановитьСсылкуНового(СсылкаНаОбъект);
			КонецЕсли;
					
			СтруктураРеквизитов 	= Новый Структура;
			
			Для Каждого Стр Из ТаблицаРеквизитов Цикл 
				Если СтруктураРегистра.Свойство(Стр.ИмяСвойстваИнтеграции) Тогда
					ЗначениеСвойства = СтруктураРегистра[Стр.ИмяСвойстваИнтеграции];
				Иначе 
					Если Стр.ТипМетаданных = Перечисления.инт_ТипыМетаданных.Булево Тогда
						ЗначениеСвойства = Ложь;				                             
					ИначеЕсли Стр.ТипМетаданных = Перечисления.инт_ТипыМетаданных.Дата Тогда
						ЗначениеСвойства = Дата(1,1,1);
					ИначеЕсли Стр.ТипМетаданных = Перечисления.инт_ТипыМетаданных.Число Тогда
						ЗначениеСвойства = 0;
					Иначе	                                                                
						ЗначениеСвойства = "";					
					КонецЕсли;	
				КонецЕсли;	 
				Если ТипЗнч(ЗначениеСвойства) = Тип("Число") Тогда
					ЗначениеСвойства = Формат(ЗначениеСвойства,"ЧГ=");
				КонецЕсли;	
				СтруктураРеквизитов.Вставить(Стр.ИмяМетаданных,ЗначениеСвойства);
			КонецЦикла;		
			
			НаборЗаписей = РегистрыСведений.ДокументыФизическихЛиц.СоздатьМенеджерЗаписи();	
				
			Для Каждого Измерение Из МетаданныеРегистраСведений.Измерения Цикл
				Если ТипЗнч(НаборЗаписей[Измерение.Имя]) = ТипЗнч(СсылкаНаОбъект) Тогда
					СтруктураРеквизитов.Вставить(Измерение.Имя,СсылкаНаОбъект);
				Иначе                                               
					Если ОбщегоНазначения.ЭтоСправочник(НаборЗаписей[Измерение.Имя].Метаданные()) Тогда
						СтруктураРеквизитов[Измерение.Имя] = Справочники[НаборЗаписей[Измерение.Имя].Метаданные().Имя].НайтиПоНаименованию(СтруктураРеквизитов[Измерение.Имя]);						
						Если Не ЗначениеЗаполнено(СтруктураРеквизитов[Измерение.Имя]) Тогда 
							СтруктураРеквизитов[Измерение.Имя] = Справочники[НаборЗаписей[Измерение.Имя].Метаданные().Имя].НайтиПоКоду(СтруктураРеквизитов[Измерение.Имя]);
						КонецЕсли;	
					КонецЕсли;	
				КонецЕсли;	
			КонецЦикла;			
			
			Для Каждого Ресурс Из МетаданныеРегистраСведений.Ресурсы Цикл 
				Если ТипЗнч(НаборЗаписей[Ресурс.Имя])<> ТИП("Строка") 
					И ТипЗнч(НаборЗаписей[Ресурс.Имя])<> ТИП("Число") 
					И ТипЗнч(НаборЗаписей[Ресурс.Имя])<> ТИП("Дата")
					И ТипЗнч(НаборЗаписей[Ресурс.Имя])<> ТИП("Булево")Тогда
					Если СтруктураРеквизитов.Свойство(Ресурс.Имя) Тогда  
						Если ОбщегоНазначения.ЭтоСправочник(НаборЗаписей[Ресурс.Имя].Метаданные()) Тогда
							СтруктураРеквизитов[Ресурс.Имя] = Справочники[НаборЗаписей[Ресурс.Имя].Метаданные().Имя].НайтиПоНаименованию(СтруктураРеквизитов[Ресурс.Имя]);						
							Если Не ЗначениеЗаполнено(СтруктураРеквизитов[Ресурс.Имя]) Тогда 
								СтруктураРеквизитов[Ресурс.Имя] = Справочники[НаборЗаписей[Ресурс.Имя].Метаданные().Имя].НайтиПоКоду(СтруктураРеквизитов[Ресурс.Имя]);
							КонецЕсли;	
						КонецЕсли;	
					КонецЕсли;	
				КонецЕсли;	
			КонецЦикла;	
			
			ЗаполнитьЗначенияСвойств(НаборЗаписей,СтруктураРеквизитов);
			НаборЗаписей.Записать(Истина);
		
		КонецЕсли;	
	КонецЕсли;	
	     
	
КонецПроцедуры

// Процедура ВыполнитьКодИзСправочникаНастроек
// Выполняет код поиска соостветствия, заполнения, проверки условий из настроек распознавания JSON в безопасном режиме, 
// допускает вывод отладочных сообщений, в случае ошибки записывает описание ошибки в соответствующую переменную  
// Входящие параметры:
	// Код: выполняемый код
	// Описание ошибки: сюда записывается ОписаниеОшибки() в случае ошибки выполнения кода 
	// ВыводитьОтладочныеСообщения: флаг включения отладочных сообщений
	// Источник кода : 
		// Реквизиты. Процедура поиска соответствия, 
		// Реквизиты. Процедура заполнения,
		// Реквизиты. Условие отказа перезаполнения,
		// Постобработка. Процедура заполнения, 
		// Постобработка. Условие применения процедуры заполнения,
		// Условия отказа перезаполнения
		// Условия отказа перепроведения
	// Идентификатор строчки правил: Имя реквизита из строчки правил, там где оно есть, или номер строки там, где его нет
	// Далее идут опеределенные ранее "волшебные переменные", доступные в выполняемом коде

Процедура ВыполнитьКодИзСправочникаНастроек(
	знач Код,   
	ОписаниеОшибки,
	ВыводитьОтладочныеСообщения,
	ИсточникКода,
	ИдентификаторСтрочкиПравил,
	ОбрабатываемыйОбъект=неопределено,
	ВозвращаемаяСсылка=неопределено,
	ГоловнойОбъект=неопределено,
	СтруктураШапки = неопределено,
	СтруктураРаспознанныхЗначений=неопределено,
	СтруктураСтрокиТабЧасти = неопределено,
	ПОДСТАНОВКАПАРАМЕТРАЗНАЧЕНИЯ=неопределено,
	УсловиеВыполнено=неопределено)
	
	Код=стрЗаменить(Код,"ПОДСТАНОВКАИМЕНИСВОЙСТВА",ИдентификаторСтрочкиПравил);

	ДоработатьКодИзСправочникаНастроекДляРаботыСОтладочнымиСообщениями(Код,ВыводитьОтладочныеСообщения,ИсточникКода,ИдентификаторСтрочкиПравил); 
	
	попытка 
		Выполнить(Код);
	Исключение
		ОписаниеОшибки=ОписаниеОшибки+ОписаниеОшибки();
		Если ВыводитьОтладочныеСообщения тогда
			Сообщить(ИсточникКода+", "+ИдентификаторСтрочкиПравил+", ошибка:" +ОписаниеОшибки);		
		КонецЕсли;
	КонецПопытки
	
КонецПроцедуры 




Процедура ДоработатьКодИзСправочникаНастроекДляРаботыСОтладочнымиСообщениями(Код,ВыводитьОтладочныеСообщения, ИсточникКода,знач ИдентификаторСтрочкиПравил)
	Если типЗнч(ИдентификаторСтрочкиПравил)=тип("Число") тогда
		ИдентификаторСтрочкиПравил=строка(ИдентификаторСтрочкиПравил);	
	КонецЕсли; 
	
	Код=стрЗаменить(Код,"сообщить","Сообщить");
		
	ПозицияДирективыСообщитьВТекстеКода=стрНайти(Код,"Сообщить(",,,1);
	
	пока ПозицияДирективыСообщитьВТекстеКода<>0 цикл
		НакопленныйТекстКИзъятию="Сообщить(";
		ДлинаТекстаКода=стрДлина(Код);
		ПозицияНачалаПоиска=ПозицияДирективыСообщитьВТекстеКода+9; //начало текста, который идет после директивы Сообщить и открывающей скобочки
		КоличествоОткрытыхСкобочек=1;
		для Счетчик=ПозицияНачалаПоиска по ДлинаТекстаКода цикл
			текСимвол=сред(Код,Счетчик,1);
			НакопленныйТекстКИзъятию=НакопленныйТекстКИзъятию+текСимвол;
			Если текСимвол="(" тогда
				КоличествоОткрытыхСкобочек=КоличествоОткрытыхСкобочек+1;	
			КонецЕсли;	
			Если текСимвол=")" тогда
				КоличествоОткрытыхСкобочек=КоличествоОткрытыхСкобочек-1;	
			КонецЕсли;	                                              
			
			Если КоличествоОткрытыхСкобочек=0 тогда
				Если ВыводитьОтладочныеСообщения тогда 
					НакопленныйТекстКИзъятиюЗаменитьНа=НакопленныйТекстКИзъятию;
					НакопленныйТекстКИзъятиюЗаменитьНа=стрЗаменить(НакопленныйТекстКИзъятиюЗаменитьНа,"Сообщить(","СКАЗАТЬГРОМКО(");
					ДобавкаКСообщению="СКАЗАТЬГРОМКО("""+ИсточникКода+", "+ИдентификаторСтрочкиПравил+", отладочное сообщение:"");";
					Код=стрЗаменить(Код,НакопленныйТекстКИзъятию,ДобавкаКСообщению+Символы.ВК+НакопленныйТекстКИзъятиюЗаменитьНа);
				иначе
					Код=стрЗаменить(Код,НакопленныйТекстКИзъятию,";");
				КонецЕсли;
				прервать;
			КонецЕсли;
		КонецЦикла;
		ПозицияДирективыСообщитьВТекстеКода=стрНайти(Код,"Сообщить(",,,1);	
	КонецЦикла;
	
	Код=стрЗаменить(Код,"СКАЗАТЬГРОМКО","Сообщить");
	
КонецПроцедуры   


