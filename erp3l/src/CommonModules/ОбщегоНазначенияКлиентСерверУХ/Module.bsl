


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С КОДАМИ ЭЛЕМЕНТОВ СПРАВОЧНИКОВ.

// Функция заменяет все не алфавитноцифровые символы на знак подчеркивания.
// Параметры
//  Код            - Строка, Значение кода, которое необходимо преобразовать.
// Возвращаемое значение
//  Строка, преобразованное значение кода.
//
Функция ВернутьАлфавитноЦифровоеПредставление(Код, РазрешитьЦифрыВНачале = Ложь, РазрешитьСлужебныеСимволы = Ложь, ЗаменятьНеправильные=Истина) Экспорт
	
	Если ТипЗнч(Код) <> Тип("Строка") Тогда
		Возврат Код;
	КонецЕсли;
	
	РусАлфавит       = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
	ЛатАлфавит       = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	Цифры            = "1234567890";
	СлужебныеСимволы = "\+.";
	
	ТекСтрока  = "";
	
	
	Инд = 1;
	ОбработкаНачала = Истина;
	Пока  Инд <= СтрДлина(Код) Цикл
		
		ТекСимвол = (Сред(Код, Инд, 1));
		
		Если  ОбработкаНачала Тогда
			Если СтрЧислоВхождений(РусАлфавит + ЛатАлфавит + ?(РазрешитьЦифрыВНачале, Цифры, "") + ?(РазрешитьСлужебныеСимволы, СлужебныеСимволы, ""), ВРЕГ(ТекСимвол)) <> 0 Тогда
				ОбработкаНачала = Ложь;
				ТекСтрока = ТекСтрока + ТекСимвол;
			КонецЕсли;
			
		Иначе
			
			Если СтрЧислоВхождений(РусАлфавит + ЛатАлфавит + Цифры + ?(РазрешитьСлужебныеСимволы, СлужебныеСимволы, "") + "_", ВРЕГ(ТекСимвол)) = 0 Тогда
				ТекСтрока = ТекСтрока + ?(ЗаменятьНеправильные,"_","");
			ИначеЕсли ТекСимвол = "/" И РазрешитьСлужебныеСимволы Тогда
				ТекСтрока = ТекСтрока + "\";
			Иначе
				ТекСтрока = ТекСтрока + ТекСимвол;
			КонецЕсли;
			
		КонецЕсли;
		
		Инд = Инд + 1;
		
	КонецЦикла;
	
	Возврат ТекСтрока;
КонецФункции

// Проверяет что символ принадлежит множеству [A-Z|А-Я|_|0-9]
//
Функция РусАнгАлфавитВспомогательныеСимволы(Символ) Экспорт
	
	Возврат СтрНайти("АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789",Символ)>0;
	
КонецФункции // РусАнгАлфавитВспомогательныеСимволы(Символ)


/////////////////////////////////////////////////////////////////

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение, ЕстьИзменения = Ложь) Экспорт
	
	Если Параметр <> Значение Тогда
		Параметр = Значение;
		ЕстьИзменения = Истина;
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьЗначенияОтличающихсяСвойств(Приемник, Источник, 
	знач СписокСвойств = Неопределено, знач ИсключаяСвойства = Неопределено, ЕстьИзменения = Ложь, 
	знач ПроверятьНаличиеСвойств = Неопределено) Экспорт
	
	Если СписокСвойств <> Неопределено Тогда
		Если ТипЗнч(СписокСвойств) = Тип("Строка") Тогда
			СписокСвойств = СтрРазделить(СписокСвойств, ",");
			Для Сч = 0 По СписокСвойств.Количество() - 1 Цикл
				СписокСвойств[Сч] = СокрЛП(СписокСвойств[Сч]);
			КонецЦикла;
		КонецЕсли;
		Если ПроверятьНаличиеСвойств = Неопределено Тогда
			ПроверятьНаличиеСвойств = Истина;
		КонецЕсли;
	Иначе
		СписокСвойств = ИменаСвойствОбъекта(Приемник);
		Если ПроверятьНаличиеСвойств = Неопределено Тогда
			ПроверятьНаличиеСвойств = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если ИсключаяСвойства <> Неопределено И ТипЗнч(ИсключаяСвойства) = Тип("Строка") Тогда
		ИсключаяСвойства = СтрРазделить(ИсключаяСвойства, ",");
	КонецЕсли;

	Для каждого ИмяСвойства Из СписокСвойств Цикл
		Если ИсключаяСвойства <> Неопределено И ИсключаяСвойства.Найти(ИмяСвойства) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Источник, ИмяСвойства) Тогда
			УстановитьНовоеЗначение(Приемник[ИмяСвойства], Источник[ИмяСвойства], ЕстьИзменения);
		ИначеЕсли ПроверятьНаличиеСвойств Тогда
			ВызватьИсключение СтрШаблон(
								Нстр("ru = 'ЗаполнитьЗначенияОтличающихсяСвойств: отсутствует свойство {%1} у источника'"),
								ИмяСвойства);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ИменаСвойствОбъекта(Объект) Экспорт
	
	Если ТипЗнч(Объект) = Тип("Структура") Тогда
		Возврат ИменаСвойствСтруктуры(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("СтрокаТаблицыЗначений") Тогда
		Возврат ИменаСвойствСтрокиТаблицыЗначений(Объект);
	Иначе
		ВызватьИсключение СтрШаблон(
								Нстр("ru = 'ИменаСвойствОбъекта: неподдерживаемый тип объекта {%1}'"), 
								ТипЗнч(Объект));
	КонецЕсли;
		
КонецФункции	

Функция ИменаСвойствСтруктуры(Структура) Экспорт
	
	МассивСвойств = Новый Массив;
	Для каждого Элемент Из Структура Цикл
		МассивСвойств.Добавить(Элемент.Ключ);
	КонецЦикла;
	
	Возврат МассивСвойств;
	
КонецФункции

Функция ИменаСвойствСтрокиТаблицыЗначений(СтрокаТаблицыЗначений) Экспорт
	
	МассивСвойств = Новый Массив;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		МассивСвойств.Добавить(Колонка.Имя);
	КонецЦикла;
	
	Возврат МассивСвойств;
	
КонецФункции

// Дополняет таблицу значений-приемник данными из таблицы значений-источник
//
// Параметры:
//  ТаблицаИсточник - Таблица значений - таблица из которой будут браться строки для заполнения
//  ТаблицаПриемник - Таблица значений - таблица в которую будут добавлены строки из таблицы-источника
//  
Процедура ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для каждого СтрокаТаблицыИсточник Из ТаблицаИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицыИсточник);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьЗначениеВКоллекцию(Значение,КоллекцияЗначений) Экспорт
	
	Если (ТипЗнч(КоллекцияЗначений)=Тип("СписокЗначений") И КоллекцияЗначений.НайтиПоЗначению(Значение)=Неопределено)
		ИЛИ  (ТипЗнч(КоллекцияЗначений)=Тип("Массив") И КоллекцияЗначений.Найти(Значение)=Неопределено) Тогда
		
		КоллекцияЗначений.Добавить(Значение);
		
	КонецЕсли;
		
КонецПроцедуры // ДобавитьЗначениеВКоллекцию() 

#Область ФайловыеФункции

Функция ПолучитьИмяВременногоФайлаУниверсально(Расширение = ".tmp") Экспорт
	
	#Если ВебКлиент Тогда
		Возврат "1C_CPM_Temp_" + Новый УникальныйИдентификатор() + Расширение; 
	#Иначе	
		Возврат ПолучитьИмяВременногоФайла(Расширение);
	#КонецЕсли	

КонецФункции

#КонецОбласти

#Область РаботаСДатами

// Функция возвращает разность в днях между "ДатаУменьшаемое" и "ДатаВычитаемое"
//
Функция РазностьДатВДнях(Знач ДатаУменьшаемое, Знач ДатаВычитаемое) Экспорт
	
	ДатаУменьшаемое = ?(ЗначениеЗаполнено(ДатаУменьшаемое), ДатаУменьшаемое, ПустоеЗначениеТипа(Тип("Дата")));
	ДатаВычитаемое = ?(ЗначениеЗаполнено(ДатаВычитаемое), ДатаВычитаемое, ПустоеЗначениеТипа(Тип("Дата")));
	
	Возврат Окр((ДатаУменьшаемое - ДатаВычитаемое) / 86400, 2); // 86400 = 24*60*60 - число секунд в дне;
	
КонецФункции // () 

#КонецОбласти

#Область РаботаСИсключениями

// Возвращает самую первую ошибку из информации об ошибке.
//
// Параметры:
//  ИнформацияОбОшибке	 - ИнформацияОбОшибке.
// 
// Возвращаемое значение:
//   - ИнформацияОбОшибке
//
Функция ПолучитьКореньОшибки(Знач ИнформацияОбОшибке) Экспорт
	Если ИнформацияОбОшибке <> Неопределено
			И ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		Пока ИнформацияОбОшибке.Причина <> Неопределено Цикл
			ИнформацияОбОшибке = ИнформацияОбОшибке.Причина;
		КонецЦикла;
	КонецЕсли;
	Возврат ИнформацияОбОшибке;
КонецФункции

#КонецОбласти

#Область РаботаСДеревомЗначений

Процедура МножественныйПоискПоДеревуЗначений(МассивНайденныхСтрок, ДеревоЗначений, СтруктураПоиска, ТолькоТекущийУровень = Ложь) Экспорт
	
	Если ТипЗнч(МассивНайденныхСтрок) <> Тип("Массив") Тогда
		Возврат;
	КонецЕсли;
	
	Элементы = ДеревоЗначений.ПолучитьЭлементы();
		
	Для Каждого Элемент Из Элементы Цикл
		
		ЗначениеНайдено = Истина;
		
		Для Каждого Условие Из СтруктураПоиска Цикл
			Если НЕ СравнитьЗначения(Элемент[Условие.Ключ], Условие.Значение) Тогда
				ЗначениеНайдено = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если ЗначениеНайдено Тогда
			
			МассивНайденныхСтрок.Добавить(Элемент);
								
		КонецЕсли;
		
		Если НЕ ТолькоТекущийУровень Тогда
			МножественныйПоискПоДеревуЗначений(МассивНайденныхСтрок, Элемент, СтруктураПоиска, ТолькоТекущийУровень);
		КонецЕсли;
				
	КонецЦикла;
		
КонецПроцедуры

Функция СравнитьЗначения(СравниваемоеЗначение, ЗначениеСравнения)
	
	Если ТипЗнч(ЗначениеСравнения) = Тип("Массив") Тогда
		Для Каждого Элемент Из ЗначениеСравнения Цикл
			Если СравниваемоеЗначение = Элемент Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
		Возврат Ложь;
	Иначе
		Возврат СравниваемоеЗначение = ЗначениеСравнения;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
//	Параметры
//	ТекстСообщенияПользователю	- Строка - текст сообщения.
//	ОбъектИлиСсылка				- Ссылка на объект ИБ или объект
//	Поле						- Строка - наименование реквизита формы
//	ПутьКДанным					- Строка - путь к данным (путь к реквизиту формы)
//	Отказ						- Булево - Выходной параметр. 
//                                Устанавливается в этой процедуре в значение Истина.
//
//	Примеры использования:
//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ПолеВРеквизитеФормыОбъект",
//		"Объект");
//
//	Альтернативный вариант использования в форме объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"Объект.ПолеВРеквизитеФормыОбъект");
//
//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ИмяРеквизитаФормы");
//
//	3. Для вывода сообщения из кода на сервере:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"),СсылкаНаОбъект,,,Отказ);
//
Процедура СообщитьПользователю(	Знач ТекстСообщенияПользователю,
								Знач КлючДанных = Неопределено,
								Знач Поле = "",
								Знач ПутьКДанным = "",
								Отказ = Ложь,
								Знач ФормаИлиИдентификатор = Неопределено) Экспорт
								
	ИспользоватьСтандартныйВывод = Истина;
	Если ТипЗнч(ФормаИлиИдентификатор) = Тип("УникальныйИдентификатор") Тогда
		ИспользоватьСтандартныйВывод = Ложь;
		ИдентификаторНазначения = ФормаИлиИдентификатор;
	ИначеЕсли ТипЗнч(ФормаИлиИдентификатор) = Тип("УправляемаяФорма") Тогда
		ИспользоватьСтандартныйВывод = Ложь;
		ИдентификаторНазначения = ФормаИлиИдентификатор.УникальныйИдентификатор;
	КонецЕсли;
	
	Если ИспользоватьСтандартныйВывод Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщенияПользователю, КлючДанных, Поле, ПутьКДанным, Отказ);
	Иначе
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = ТекстСообщенияПользователю;
		Сообщение.Поле = Поле;
		Сообщение.ИдентификаторНазначения = ИдентификаторНазначения;
		
		ЭтоОбъект = Ложь;
		
#Если НЕ ТонкийКлиент И НЕ ВебКлиент Тогда
		Если КлючДанных <> Неопределено
		   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
			ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
			ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
		КонецЕсли;
#КонецЕсли
		
		Если ЭтоОбъект Тогда
			Сообщение.УстановитьДанные(КлючДанных);
		Иначе
			Сообщение.КлючДанных = КлючДанных;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
			Сообщение.ПутьКДанным = ПутьКДанным;
		КонецЕсли;
			
		Сообщение.Сообщить();
		
		Отказ = Истина;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ПоместитьТаблицуЗначенийВКоллекциюФормы(ТаблицаЗначений,КоллекцияФормы) Экспорт
	
	КоллекцияФормы.Очистить();
	
	Для Каждого Строка ИЗ ТаблицаЗначений Цикл
		
		НоваяСтрока=КоллекцияФормы.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка);
		
	КонецЦикла;
			
КонецПроцедуры // ПоместитьТаблицуЗначенийВКоллекциюФормы() 

Процедура ПоместитьДеревоЗначенийВКоллекциюФормы(ДеревоЗначений,КоллекцияФормы) Экспорт
	
	КоллекцияФормы.ПолучитьЭлементы().Очистить();
	
	Для Каждого Строка ИЗ ДеревоЗначений.Строки Цикл
		
		НоваяСтрока=КоллекцияФормы.ПолучитьЭлементы().Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка);
		
		Если Строка.Строки.Количество()>0 Тогда
			
			ДобавитьПодчиненныеЭлементыКоллекции(Строка,НоваяСтрока);
			
		КонецЕсли;
				
	КонецЦикла;
			
КонецПроцедуры // ПоместитьТаблицуЗначенийВКоллекциюФормы() 

// Возвращает наименование объекта по его коду.
// Пример: "ОсновныеСредства" => "Основные средства".
//
Функция НаименованиеПоКоду(Знач Код) Экспорт
	
	ЗАГЛАВНЫЕБУКВЫ = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯABCDEFGHIJKLMNOPQRSTUVWXYZ";
	Код = СокрЛП(Код);
	Наименование = "";
	Для Инд = 1 По СтрДлина(Код) Цикл
		ТекСимв = Сред(Код, Инд, 1);
		Если СтрНайти(ЗаглавныеБуквы, ТекСимв) <> 0 Тогда // текущий сивмол - заглавный
			Если Инд <> 1 Тогда // текущий символ - не первый
				ПредыдущийСимвол = Сред(Код, Инд - 1, 1);
				Если СтрНайти(ЗаглавныеБуквы, ПредыдущийСимвол) = 0 И ПредыдущийСимвол <> " " И ПредыдущийСимвол <> "_" Тогда // предыдущий символ - не заглавный, не пробел и не подчеркивание
					Если Инд <> СтрДлина(Код) Тогда // текущий символ - не последний
						СледСимв = Сред(Код, Инд + 1, 1);
						Если СтрНайти(ЗаглавныеБуквы, СледСимв) <> 0 Тогда // следующий символ - заглавный
							Наименование = Наименование + ТекСимв;
						Иначе // следующий символ - прописной
							Наименование = Наименование + " " + НРег(ТекСимв);
						КонецЕсли;
					Иначе // текущий символ - последний
						Наименование = Наименование + " " + ТекСимв;
					КонецЕсли;
				Иначе // предыдущий символ - не заглавная буква, не пробел и не подчеркивание
					Наименование = Наименование + " " + НРег(ТекСимв);
				КонецЕсли;
			Иначе // текущий символ - первый
				Наименование = Наименование + ТекСимв;
			КонецЕсли;
		Иначе // текущий символ - прописной
			Наименование = Наименование + ?(ТекСимв = "_", " ", ТекСимв);
		КонецЕсли;
	КонецЦикла;
	Возврат Наименование;
	
КонецФункции

Функция ПолучитьКлючПоНаименованию(Наименование) Экспорт
	
	СтрокаЭталон = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯABCDEFGHIJKLMNOPQRSTUVWXYZ_";
	
	ТекстКлюча="";
	
	Для Инд=1 По СтрДлина(Наименование) Цикл
		
		ТекСимвол=(Сред(Наименование, Инд, 1));
		
		Если СтрНайти(СтрокаЭталон, ВРег(ТекСимвол))>0 Тогда
			
			ТекстКлюча=ТекстКлюча+ТекСимвол;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекстКлюча;	
	
КонецФункции // ПолучитьКлючПоНаименованию() 

Функция НайтиСтрокуДерева(КоллекцияЭлементов,Значение,ИмяКолонки) Экспорт
	
	Для Каждого Элемент ИЗ КоллекцияЭлементов Цикл
		
		Если Элемент[ИмяКолонки]=Значение Тогда
			
			Возврат Элемент;
			
		ИначеЕсли Элемент.ПолучитьЭлементы().Количество()>0 Тогда
			
			НайденныйЭлемент=НайтиСтрокуДерева(Элемент.ПолучитьЭлементы(),Значение,ИмяКолонки);
			
			Если Не НайденныйЭлемент=Неопределено Тогда
				
				Возврат НайденныйЭлемент;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
				
КонецФункции // НайтиСтрокуДерева()

// Используется для создания элемента отбора или, если таковой не найден,
// установления существующим элементам свойств
// Параметры
// ОбластьПоискаДобавления - контейнер с элементами и группами отбора, например
//					Список.Отбор
//					или группа в отборе
// ИмяПоля - строка - имя для поля компоновки данных (заполняется всегда)
// Устанавливаемые поля:
// ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
// ПравоеЗначение - произвольный
// Представление - представление элемента компоновки данных
// Использование - булево - использование элемента
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления,
								знач ИмяПоля,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Представление = Неопределено,
								знач Использование = Неопределено) Экспорт
	
	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование);
	
	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование);
	КонецЕсли;
	
КонецПроцедуры

// Поиск элементов и групп отбора динамического списка
// Параметры:
// ОбластьПоиска - контейнер с элементами и группами отбора, например
//					Список.Отбор
//					или группа в отборе
// ИмяПоля - имя поля компоновки (не используется для групп)
// Представление - представление поля компоновки
// Примечание: поиск может осуществляться или по ЛевомуЗначению, или по Представлению
//
Функция НайтиЭлементыИГруппыОтбора(знач ОбластьПоиска,
									знач ИмяПоля = Неопределено,
									знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Возврат МассивЭлементов;
	
КонецФункции

// Добавление элемента компоновки в контейнер элементов компоновки
// Параметры:
// ОбластьДобавления - контейнер с элементами и группами отбора, например
//					Список.Отбор
//					или группа в отборе
// ИмяПоля - строка - имя для поля компоновки данных
// ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
// ПравоеЗначение - произвольный
// Представление - представление элемента компоновки данных
// Использование - булево - использование элемента
//
Функция ДобавитьЭлементКомпоновки(ОбластьДобавления,
									знач ИмяПоля,
									знач ВидСравнения,
									знач ПравоеЗначение = Неопределено,
									знач Представление  = Неопределено,
									знач Использование  = Неопределено) Экспорт
	
	Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;
	
	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;
	
	Возврат Элемент;
	
КонецФункции

Процедура ДобавитьПодчиненныеЭлементыКоллекции(СтрокаДерева,СтрокаКоллекции)
	
	Для Каждого Строка ИЗ СтрокаДерева.Строки Цикл
		
		НоваяСтрока=СтрокаКоллекции.ПолучитьЭлементы().Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка);
		
		Если Строка.Строки.Количество()>0 Тогда
			
			ДобавитьПодчиненныеЭлементыКоллекции(Строка,НоваяСтрока);
			
		КонецЕсли;
				
	КонецЦикла;	
	
КонецПроцедуры // ДобавитьПодчиненныеЭлементыКоллекции() 

// Изменение элементов отбора
// Параметры
// ИмяПоля - строка - имя поля компоновки
// ВидСравнения - ВидСравненияКомпоновкиДанных - вид сравнения
// ПравоеЗначение - произвольный
// Представление - строка - представление элемента компоновки данных
//
Функция ИзменитьЭлементыОтбора(ОбластьПоиска,
								знач ИмяПоля = Неопределено,
								знач Представление = Неопределено,
								знач ПравоеЗначение = Неопределено,
								знач ВидСравнения = Неопределено,
								знач Использование = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;		
		Элемент.ПравоеЗначение = ПравоеЗначение;		
	КонецЦикла;
	
	Возврат МассивЭлементов.Количество();
	
КонецФункции

Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			
			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе
			
			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			
			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ВыполнитьПоискИсключенийВхожденияСимволов(ОбследуемаяСтрока, ДопустимыеСимволы)
	
	Для Индекс = 1 По СтрДлина(ОбследуемаяСтрока) Цикл
		Символ = Сред(ОбследуемаяСтрока, Индекс, 1);
		
		Если СтрНайти(ДопустимыеСимволы, НРег(Символ)) = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ПолучитьНовыйКлючКоллекции(Коллекция, ИмяКолонки = "КлючСтроки", СтатусУстановки = Ложь) Экспорт

	//СтатусУстановки = Ложь;
	Кандидат = Коллекция.Количество();
	СтруктураОтбора = Новый Структура("КлючСтроки", Кандидат);
	
	Пока НЕ СтатусУстановки Цикл
		СтрокиКоллекции = Коллекция.НайтиСтроки(СтруктураОтбора);
		Если СтрокиКоллекции.Количество() = 0 Тогда
			
			// Уникальное значение ключа
			СтатусУстановки = Истина;
			Возврат Кандидат;
			
		Иначе
			// Такое значение ключа уже использовано
			Кандидат = Кандидат + 1;
		КонецЕсли;
	КонецЦикла;
	
КонецФункции

Процедура УстановитьИзЗаполненногоЗначение(Параметр, Значение) Экспорт
	
	Если (Параметр <> Значение) И ЗначениеЗаполнено(Значение) Тогда
		Параметр = Значение;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

Функция ПолучитьОписаниеПримитивногоТипаИзСтроки(МассивТиповВИБ) Экспорт
	
	МассивТипов=Новый Массив;
	
	ТК_Числа = Новый КвалификаторыЧисла(18, 5, ДопустимыйЗнак.Любой);	
	ТК_Строки = Новый КвалификаторыСтроки(150, ДопустимаяДлина.Переменная);
	ТК_Даты   = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
	
	Для Каждого СтрТип Из МассивТиповВИБ Цикл
		
		Если СтрТип="Строка" ИЛИ СтрТип = "Число" ИЛИ СтрТип = "Дата" ИЛИ СтрТип = "Булево" ИЛИ СтрТип = "ДатаВремя" Тогда
			
			МассивТипов.Добавить(Тип(СтрТип))
			
		КонецЕсли;	
		
	КонецЦикла;
	
	Если МассивТипов.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	Возврат Новый ОписаниеТипов(МассивТипов, ТК_Числа, ТК_Строки, ТК_Даты);
	
КонецФункции

// Служебная функция, определяющая примитивность переданного типа
//
Функция ПримитивныйТипСтрока(СтрокаТип) Экспорт
	
	Возврат (СтрокаТип = "Строка" ИЛИ СтрокаТип = "Дата" ИЛИ СтрокаТип = "Булево" ИЛИ СтрокаТип = "Число");	
	
КонецФункции

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		
		Попытка
			Возврат Новый (ЗаданныйТип);
		Исключение
			Возврат Неопределено;
		КонецПопытки;
		
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Получает значение реквизита формы.
// Параметры:
//		Форма
//		ПутьРеквизита - строка, путь к данным, например: "Объект.МесяцНачисления".
Функция ПолучитьРеквизитФормыПоПути(Форма, ПутьРеквизита) Экспорт
	
	МассивИмен = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьРеквизита, ".");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 По МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	
	Возврат Объект[ПоследнееПоле];
	
КонецФункции

// Возвращает новый УникальныйИдентификатор. Предназначена для вызова из СКД.
Функция НовыйУникальныйИдентификатор() Экспорт
	Возврат Новый УникальныйИдентификатор;
КонецФункции

// Возвращает пустой уникальный идентфикатор.
//
// Возвращаемое значение:
//  УникальныйИдентификатор - уникальный идентификатор.
//
Функция ПустойУникальныйИдентификатор() Экспорт
	
	Возврат Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
	
КонецФункции

// Возвращает значение свойства структуры.
//
// Параметры:
//   Структура - Структура, ФиксированнаяСтруктура - Объект, из которого необходимо прочитать значение ключа.
//   Ключ - Строка - Имя свойства структуры, для которого необходимо прочитать значение.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный. Возвращается когда в структуре нет значения по указанному
//                                        ключу.
//       Для скорости рекомендуется передавать только быстро вычисляемые значения (например примитивные типы),
//       а инициализацию более тяжелых значений выполнять после проверки полученного значения (только если это
//       требуется).
//
// Возвращаемое значение:
//   Произвольный - Значение свойства структуры. ЗначениеПоУмолчанию если в структуре нет указанного свойства.
//
Функция СвойствоСтруктуры(Структура, Ключ, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Структура, Ключ, ЗначениеПоУмолчанию);
	
КонецФункции

// Создает массив и помещает в него переданное значение.
Функция ЗначениеВМассиве(Значение) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Значение);
	
	Возврат Массив;
	
КонецФункции

// Создает соответствие и помещает в него в качестве ключей значения
// из массива. Значения элементров соотвествия устанавливаются
// из аргумента ЗначениеСоответствие.
//
Функция МассивВСоответствие(МассивИсточник, ЗначениеСоответствия=Истина) Экспорт
	Результат = Новый Соответствие;
	Для Каждого Значение Из МассивИсточник Цикл
		Результат.Вставить(Значение, ЗначениеСоответствия);
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Создает массив из ключей соответствия.
//
// Параметры:
//  Соответствие - Соответствие - источник данных.
// 
// Возвращаемое значение:
//   - Массив.
//
Функция КлючиСоответствияВМассив(Соответствие) Экспорт
	Результат = Новый Массив;
	Для Каждого КлючЗначение Из Соответствие Цикл
		Результат.Добавить(КлючЗначение.Ключ);
	КонецЦИкла;
	Возврат Результат;
КонецФункции

// Выгружает из коллекции указанную по имени колонку.
//  Необходима, т.к. на клиенте отсутствует стандартная функция.
//
// Параметры:
//  Коллекция	 - ДанныеФормыКоллекция - коллекция.
//  ИмяКолонки	 - Строка - имя колонки.
// 
// Возвращаемое значение:
//   - Массив - значения колонки указанной коллекции.
//
Функция ВыгрузитьКолонкуКоллекцииВМассив(Коллекция, ИмяКолонки) Экспорт
	Результат = Новый Массив;
	Для Каждого Строка Из Коллекция Цикл
		Результат.Добавить(Строка[ИмяКолонки]);
	КонецЦикла;
	Возврат Результат;
КонецФункции

Процедура ЗаменитьУдалитьПараметрВыбора(Элемент, Имя, НовыйПараметрВыбора = Неопределено) Экспорт

	МассивПараметров = Новый Массив;
	Для Каждого СвязьПараметровВыбора Из Элемент.ПараметрыВыбора Цикл
		Если ВРег(СвязьПараметровВыбора.Имя) <> ВРег(Имя) Тогда
			МассивПараметров.Добавить(СвязьПараметровВыбора);
		КонецЕсли;
	КонецЦикла;

	Если НовыйПараметрВыбора <> Неопределено Тогда
		МассивПараметров.Добавить(НовыйПараметрВыбора);
	КонецЕсли;
	
	Элемент.ПараметрыВыбора = Новый ФиксированныйМассив(МассивПараметров);

КонецПроцедуры

// Округляет число до заданной точности по указанному правилу (перенесено из ЗарплатаКадрыКлиентСервер).
//
// Параметры:
//  Число                   - число, число которое необходимо округлить.
//  Точность        		- число, "базис" до которого нужно округлить заданное число.
//  Правило 				- булево, Истина - в большую сторону, Ложь - в меньшую, Неопределено/В остальных случаях - по правилу арифметики
//
// Возвращаемое значение:
// Число - округленное до заданной точности значение.
//
Функция Округлить(Число, Точность = 0, Правило = Неопределено) Экспорт
	
	// Если надо округлить 0 или точность не задана, то возвращаем заданное число.
	Если Не ЗначениеЗаполнено(Число) 
		Или Точность <= 0 Тогда
		Возврат Число
	КонецЕсли;
	
	Множитель  		= Число / Точность;
	ЦелыйМножитель 	= Цел(Множитель);
	
	Если Множитель = ЦелыйМножитель Тогда
		Результат = Число;
	Иначе
		Результат = Точность * Окр(Множитель);
		
		Если Правило = Истина Тогда							//В большую сторону
			Результат = Точность * (ЦелыйМножитель + 1);
		ИначеЕсли Правило = Ложь Тогда						//В меньшую сторону
			Результат = Точность * ЦелыйМножитель;
		КонецЕсли; 
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает максимальный интервал (в секундах) проверки напоминаний.
Функция МаксимальныйИнтервалПроверкиНапоминаний() Экспорт
	РезультатФункции = 60*60*1;		// 1 час.
	Возврат РезультатФункции;
КонецФункции

// Возвращает копию списка значений СписокВход, где удалены все 
//неуникальные значения. ВАЖНО! Будут потеряны представления элементов.
Функция СвернутьСписокЗначений(СписокВход) Экспорт
	РезультатФункции = Новый СписокЗначений;
	ВремМассив = СписокВход.ВыгрузитьЗначения();
	ВремМассив = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ВремМассив);
	РезультатФункции.ЗагрузитьЗначения(ВремМассив);
	Возврат РезультатФункции;
КонецФункции

// Получить строку имен свойств структуры отфильтрованный по присутствии в свойствах структуры.
// Параметры:
//	ОбъектСтруктура - Структура.
//	ИменаСвойств - Строка. Имена свойств разделенные запятыми. Пробелы не учитываются.
// Возвращает:
//	Строка - имена свойств присутствующие в ИменаСвойств и принадлежащие структуре ОбъектСтруктура.
//
Функция ОтфильтроватьСвойстваСтруктуры(ОбъектСтруктура, Знач ИменаСвойств) Экспорт
	Если ПустаяСтрока(ИменаСвойств) Тогда
		Возврат "";
	КонецЕсли;
	
	мОтфильтрованныхСвойств = Новый Массив;
	МассивИменСвойств = СтрРазделить(ИменаСвойств, ",", Ложь);
	Для Каждого ИмяСвойства Из МассивИменСвойств Цикл
		ИмяСвойства = СокрЛП(ИмяСвойства);
		Если ОбъектСтруктура.Свойство(ИмяСвойства) Тогда
			мОтфильтрованныхСвойств.Добавить(ИмяСвойства);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(мОтфильтрованныхСвойств, ",");
КонецФункции

// Обертка для функции ЗаполнитьЗначенияСвойств.
// При исключении свойств, не выдает ошибку, если свойство отсутствует в СтруктураИсточник.
Процедура ЗаполнитьЗначенияСвойствИзСтруктуры(Приемник, СтруктураИсточник, Знач СписокСвойств, Знач ИсключаяСвойства)  Экспорт
	СписокСвойств = ОтфильтроватьСвойстваСтруктуры(СтруктураИсточник, СписокСвойств);
	ИсключаяСвойства = ОтфильтроватьСвойстваСтруктуры(СтруктураИсточник, ИсключаяСвойства);
	
	Если ПустаяСтрока(СписокСвойств) Тогда
		СписокСвойств = Неопределено;
	КонецЕсли;
	Если ПустаяСтрока(ИсключаяСвойства) Тогда
		ИсключаяСвойства = Неопределено;
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(Приемник, СтруктураИсточник, СписокСвойств, ИсключаяСвойства);
КонецПроцедуры

// Заполняет свойства переданного объекта из структуры, если они не заполнены
//
// Параметры:
//  Объект				 - Произвольный	 - любой объект, свойства которого требуется заполнить
//  ЗначенияРеквизитов	 - Структура 	 - структура: Ключ - имя реквизита объекта, Значение - значение реквизита объекта
//
Процедура ЗаполнитьНеЗаполненныеСвойства(Объект, ЗначенияРеквизитов) Экспорт
	Для каждого Реквизит Из ЗначенияРеквизитов Цикл
		Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Объект, Реквизит.Ключ) Тогда
			Если НЕ ЗначениеЗаполнено(Объект[Реквизит.Ключ]) Тогда
				Объект[Реквизит.Ключ] = Реквизит.Значение;	
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры


// Устанавливает свойства объекта значениями по умолчанию для их типа
//
// Параметры:
//  Объект		 - ДокументОбъект, Структура и т.п. - объект свойства которого очищаются
//  ИменаСвойств - Строка - имена свойств объекта через запятую 
//
Процедура ОчиститьСвойстваОбъекта(Объект, ИменаСвойств) Экспорт
	
	СтруктураИмен = Новый Структура(ИменаСвойств);
	Для каждого Свойство Из СтруктураИмен Цикл
		Объект[Свойство.Ключ] = ПустоеЗначение(ТипЗнч(Объект[Свойство.Ключ]));
	КонецЦикла;
	
КонецПроцедуры


// Возвращает пустое значение переданного типа
//
// Параметры:
//  ТипЗначения	 - Тип - тип значения
// 
// Возвращаемое значение:
//   - пустое значение
//
Функция ПустоеЗначение(ТипЗначения) Экспорт
	ОписаниеТипа = Новый ОписаниеТипов(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ТипЗначения));
	ПустоеЗначение = ОписаниеТипа.ПривестиЗначение(Неопределено);
	Возврат ПустоеЗначение;
КонецФункции

// Возвращает копию массива МассивВход, из которого удалены
// незаполненные элементы.
Функция УдалитьПустыеЭлементыМассива(МассивВход) Экспорт
	РезультатФункции = Новый Массив;
	Для Каждого ТекМассивВход Из МассивВход Цикл
		Если ЗначениеЗаполнено(ТекМассивВход) Тогда
			РезультатФункции.Добавить(ТекМассивВход);
		Иначе
			// Не добавляем.
		КонецЕсли;
	КонецЦикла;
	Возврат РезультатФункции;
КонецФункции

// Возвращает копию массива МассивВход, отсортированному по возрастанию/убыванию
// в зависимости от параметра ПоВозрастаниюВход.
Функция СортироватьМассив(МассивВход, ПоВозрастаниюВход = Истина) Экспорт
	РезультатФункции = Новый Массив;
	СписокВрем = Новый СписокЗначений;
	СписокВрем.ЗагрузитьЗначения(МассивВход);
	Если ПоВозрастаниюВход Тогда
		СписокВрем.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	Иначе
		СписокВрем.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
	КонецЕсли;
	РезультатФункции = СписокВрем.ВыгрузитьЗначения();
	Возврат РезультатФункции;
КонецФункции

// Возвращает новый массив заполненный элементами идущими
// в обратном направлении по отношению к исходному.
// Параметры:
//	М - Массив, ФиксированныйМассив - для получения обратного.
// Возвращает:
//	Массив - массив в котором все элементы идут в порядке, противоположному
//		порядку из исходного массива М.
//
Функция ПолучитьОбратныйМассив(М) Экспорт
	мОбратныеИндексы = Новый Массив;
	ТипМ = ТипЗнч(М);
	Если ЗначениеЗаполнено(М)
		 И (ТипМ = Тип("Массив") ИЛИ ТипМ = Тип("ФиксированныйМассив")) Тогда
		 
		МаксНомер = М.Количество()-1;
		Для НомерЭлемента = 0 По МаксНомер Цикл
			мОбратныеИндексы.Добавить(М[МаксНомер-НомерЭлемента]);
		КонецЦикла;
	КонецЕсли;
	
	Возврат мОбратныеИндексы;
КонецФункции

// Возвращает массив заполненный индексами в ДеревоЗначений всех родителей
// и самого элемента ДанныеФормыДерево.
//
// Параметры:
//	ДеревоФормы - ДанныеФормыДерево - дерево формы для получения индекса
//		верхнего элемента. Если передать Неопределено, то после
//		нахождения сАмого родительского элемента, не будет
//		искать его индекс в корневых элементах дерева.
//	ЭлементДереваФормы - ДанныеФормыЭлементДерева - элемент для которого
//		необходимо получить путь.
// Возвращает:
//	Массив(Число) - индексы элементов в ДеревоЗначений от родителей к детям.
//
Функция ПолучитьИндексыПутиКЭлементуВДеревеЗначений(ДеревоФормы, ЭлементДереваФормы) Экспорт
	мИндексы = Новый Массив; // от элемента к его родителям
	
	ТекЭлементДереваФормы = ЭлементДереваФормы;
	РодительЭлемента = ТекЭлементДереваФормы.ПолучитьРодителя();
	
	Пока РодительЭлемента <> Неопределено Цикл
		ИндексДереваЗначений = РодительЭлемента.ПолучитьЭлементы().Индекс(ТекЭлементДереваФормы);
		мИндексы.Добавить(ИндексДереваЗначений);
		
		ТекЭлементДереваФормы = РодительЭлемента;
		РодительЭлемента = ТекЭлементДереваФормы.ПолучитьРодителя();
	КонецЦикла;
	
	Если ДеревоФормы <> Неопределено И ТекЭлементДереваФормы <> Неопределено Тогда
		ИндексДереваЗначений = ДеревоФормы.ПолучитьЭлементы().Индекс(ТекЭлементДереваФормы);
		мИндексы.Добавить(ИндексДереваЗначений);
	КонецЕсли;
	
	// индексы от родителей к элементу
	Возврат ОбщегоНазначенияКлиентСерверУХ.ПолучитьОбратныйМассив(мИндексы);
КонецФункции

// Возвращает ДанныеФормыЭлементДерева в указанном ДанныеФормыДерево.
//  Поиск осуществляется по индексам из массива. От самого верхнего
//  родителя к самому элементу.
//
// Параметры:
//  ДеревоФормы - ДанныеФормыДерево - реквизит формы дерево для поиска в нем.
//  мИндексы - Массив(Число) - массив индексов.
// 
// Возвращаемое значение:
//	ДанныеФормыЭлементДерева - если найден элемент.
//	Неопределено - элемент дерева не найден.
//
Функция ПолучитьЭлементДереваФормыПоИндексам(ДеревоФормы, мИндексы) Экспорт
	ТипДерева = ТипЗнч(ДеревоФормы);
	Если ДеревоФормы <> Неопределено И (ТипДерева = Тип("ДанныеФормыДерево")
					ИЛИ ТипДерева = Тип("ДанныеФормыЭлементДерева")) Тогда
				
		ТекЭлементДерева = ДеревоФормы;
		ПоследнийНомер = мИндексы.Количество()-1;		
		Для Ном = 0 По ПоследнийНомер Цикл
			Если ТекЭлементДерева = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			
			Индекс = мИндексы[Ном];
			ТекЭлементДерева =  ТекЭлементДерева.ПолучитьЭлементы()[Индекс];
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТекЭлементДерева;
КонецФункции

// Установить значение в указанных строке и колонке ДанныеФормыКоллекция.
//
// Параметры:
//  ОбъектКоллекции - ДанныеФормыКоллекция - объект у которого нужно установить значение.
//  ИмяКолонки - Строка - имя колонки в коллекции.
//  ТекущаяСтрока - Число - идентификатор строки коллекции.
//  Значение - Произвольный - значение, которое будет записано в ячейку.
//
Процедура УстановитьЗначениеПоляКоллекции(ОбъектКоллекции, ИмяКолонки,
											ТекущаяСтрока, Значение) Экспорт
	Если ОбъектКоллекции = Неопределено
		    ИЛИ ПустаяСтрока(ИмяКолонки)
			ИЛИ ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;
		
	ТекДанные = ОбъектКоллекции.НайтиПоИдентификатору(ТекущаяСтрока);
	Если ТекДанные = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТекДанные[ИмяКолонки] = Значение; 
КонецПроцедуры

// Получить значение в указанной строке и колонке ДанныеФормыКоллекция.
//
// Параметры:
//  ОбъектКоллекции - ДанныеФормыКоллекция - коллекция из которой читаем значение.
//  ИмяКолонки - Строка - имя колонки в коллекции.
//  ТекущаяСтрока - Число - идентификатор строки коллекции.
//
Функция ПолучитьЗначениеПоляКоллекции(ОбъектКоллекции, ИмяКолонки,
											ТекущаяСтрока) Экспорт
	Если ОбъектКоллекции = Неопределено
		    ИЛИ ПустаяСтрока(ИмяКолонки)
			ИЛИ ТекущаяСтрока = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	ТекДанные = ОбъектКоллекции.НайтиПоИдентификатору(ТекущаяСтрока);
	Если ТекДанные = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ТекДанные[ИмяКолонки]; 
КонецФункции

// Получить структуру, описывающую строку аналитики источника данных.
//
// Параметры:
//  СтрокаДереваФормы - ДанныеФормыДерево, ДанныеФормыЭлементДерева - дерево
//		или строка в которую нужно добавить строки.
//  СтрокиКДобавлению - Массив(Структура) - массив структур описывающих
//		строки, которые нужно добавить. Реквизиты структуры должны
//		соответствовать колонкам дерева. Если необходимо добавлять
//		подчиненные строки, то у структуры должен быть реквизит
//		СтрокиКДобавлению.
//
Процедура ДополнитьСтрокиДереваФормы(СтрокаДереваФормы, СтрокиКДобавлению) Экспорт
	Если НЕ ЗначениеЗаполнено(СтрокиКДобавлению) Тогда
		Возврат;
	КонецЕсли;
	
	ЭлементыСтроки = СтрокаДереваФормы.ПолучитьЭлементы();
	Для Каждого СтрокаКДобавлению ИЗ СтрокиКДобавлению Цикл
		НоваяСтрока = ЭлементыСтроки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаКДобавлению);
		
		Если СтрокаКДобавлению.Свойство("СтрокиКДобавлению") Тогда
			ДополнитьСтрокиДереваФормы(НоваяСтрока, СтрокаКДобавлению.СтрокиКДобавлению);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Добавляет все значение из списка значений Источник
//  в список значений Приемник.
//
// Параметры:
//  Приемник - СписокЗначений - список в который обаляем значения.
//  Источник - СписокЗначений - список из которого берутся значения.
// 
// Возвращаемое значение:
//   - СписокЗначение - ссылка на Приемник.
//
Функция ДобавитьВСписокИзСписка(Приемник, Источник) Экспорт
	Для Каждого Элемент Из Источник Цикл
		Приемник.Добавить(
			Элемент.Значение,
			Элемент.Представление,
			Элемент.Пометка,
			Элемент.Картинка);
	КонецЦикла;
КонецФункции

// Возвращает минимальное значение в массиве. Когда массив пустой, либо возникла
// ошибка - будет возвращено ЗначениеПоУмолчаниюВход.
Функция МинимумВМассиве(МассивВход, ЗначениеПоУмолчаниюВход = Неопределено) Экспорт
	РезультатФункции = ЗначениеПоУмолчаниюВход;
	Попытка
		Если МассивВход.Количество() > 0 Тогда
			РезультатФункции = МассивВход[0];
			Для Каждого ТекМассивВход Из МассивВход Цикл
				Если РезультатФункции > ТекМассивВход Тогда
					РезультатФункции = ТекМассивВход;
				Иначе
					// Пропускаем.
				КонецЕсли;
			КонецЦикла;
		Иначе
			РезультатФункции = ЗначениеПоУмолчаниюВход;
		КонецЕсли;
	Исключение
		РезультатФункции = ЗначениеПоУмолчаниюВход;
	КонецПопытки;
	Возврат РезультатФункции;
КонецФункции

// Возвращает максимальное значение в массиве. Когда массив пустой, либо возникла
// ошибка - будет возвращено ЗначениеПоУмолчаниюВход.
Функция МаксимумВМассиве(МассивВход, ЗначениеПоУмолчаниюВход = Неопределено) Экспорт
	РезультатФункции = ЗначениеПоУмолчаниюВход;
	Попытка
		Если МассивВход.Количество() > 0 Тогда
			РезультатФункции = МассивВход[0];
			Для Каждого ТекМассивВход Из МассивВход Цикл
				Если РезультатФункции < ТекМассивВход Тогда
					РезультатФункции = ТекМассивВход;
				Иначе
					// Пропускаем.
				КонецЕсли;
			КонецЦикла;
		Иначе
			РезультатФункции = ЗначениеПоУмолчаниюВход;
		КонецЕсли;
	Исключение
		РезультатФункции = ЗначениеПоУмолчаниюВход;
	КонецПопытки;
	Возврат РезультатФункции;
КонецФункции

// Возвращает произведение значение в массиве. Когда массив пустой, либо возникла
// ошибка - будет возвращено ЗначениеПоУмолчаниюВход.
Функция ПроизведениеВМассиве(МассивВход, ЗначениеПоУмолчаниюВход = Неопределено) Экспорт
	РезультатФункции = ЗначениеПоУмолчаниюВход;
	Попытка
		Если МассивВход.Количество() > 0 Тогда
			РезультатФункции = 1;
			Для Каждого ТекМассивВход Из МассивВход Цикл
				РезультатФункции = РезультатФункции * ТекМассивВход;
			КонецЦикла;
		Иначе
			РезультатФункции = ЗначениеПоУмолчаниюВход;
		КонецЕсли;
	Исключение
		РезультатФункции = ЗначениеПоУмолчаниюВход;
	КонецПопытки;
	Возврат РезультатФункции;
КонецФункции		// ПроизведениеВМассиве()

Функция СуммаЭлементовКоллекции(Коллекция, ИмяРеквизита) Экспорт
	
	Сумма = 0;
	Для каждого Элемент Из Коллекция Цикл
		Сумма = Сумма + Элемент[ИмяРеквизита];
	КонецЦикла;
	
	Возврат Сумма;
	
КонецФункции

Функция НайтиЭлементКоллекцииПоЗначениюРеквизита(Коллекция, ИмяРеквизита, ЗначениеРеквизита) Экспорт
	
	Для каждого Элемент Из Коллекция Цикл
		Если Элемент[ИмяРеквизита] = ЗначениеРеквизита Тогда
			Возврат Элемент;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает произведение значение в массиве. Когда массив пустой, либо возникла
// ошибка - будет возвращено ЗначениеПоУмолчаниюВход.
Функция СреднееАрифметическоеВМассиве(МассивВход, ЗначениеПоУмолчаниюВход = Неопределено) Экспорт
	РезультатФункции = ЗначениеПоУмолчаниюВход;
	Попытка
		Если МассивВход.Количество() > 0 Тогда
			Сумма = 0;
			Для Каждого ТекМассивВход Из МассивВход Цикл
				Сумма = Сумма + ТекМассивВход;
			КонецЦикла;	
			РезультатФункции = Сумма / (МассивВход.Количество());
		Иначе
			РезультатФункции = ЗначениеПоУмолчаниюВход;
		КонецЕсли;	
	Исключение
		РезультатФункции = ЗначениеПоУмолчаниюВход;
	КонецПопытки;
	Возврат РезультатФункции;
КонецФункции		// СреднееАрифметическоеВМассиве()

// Процедура корректно снимает АвтоОтметкуНезаполненного для элемента формы
Процедура УстановитьАвтоОтметкуЗаполненияЭлемента(Элемент, ОбязательноеЗаполнение) Экспорт
	
	СтараяАвтоОтметкаНезаполненного = Элемент.АвтоОтметкаНезаполненного;
	
	Элемент.АвтоОтметкаНезаполненного = ОбязательноеЗаполнение;
	
	// Выключение свойства АвтоОтметкаНезаполненного, т.е. перевод его значения из Истина в Ложь, 
	// не приводит к изменению текущего значения свойства ОтметкаНезаполненного.
	Если СтараяАвтоОтметкаНезаполненного = Истина И Элемент.АвтоОтметкаНезаполненного <> Истина Тогда
		Элемент.ОтметкаНезаполненного = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Проверяет равенство реквизитов двух структур.
//  Проверка идентичности наборов реквизитов не производится.
//
// Параметры:
//  СтруктураИсходная - Структура - первая структура для сравнения.
//									Из нее берутся имена полей.
//  СтруктураИзмененная - Структура - вторая структура для сравнения.
// 
// Возвращаемое значение:
//   - Булево - Истина - если все реквизиты СтруктураИсходная равны
//						 реквизитам СтруктураИзмененная.
//				Ложь - если реквизиты различны.
//
Функция СтруктурыРавны(СтруктураИсходная, СтруктураИзмененная) Экспорт
	Для Каждого КЗ Из СтруктураИсходная Цикл
		Если СтруктураИзмененная[КЗ.Ключ] <> КЗ.Значение Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Для переданного элемента формы возвращает саму форму.
// В случае ошибки, возвращает Неопределено.
//
Функция ПолучитьФормуПоЭлементу(ЭлементФормы) Экспорт
	Если ЭлементФормы = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТекущийРодитель = ЭлементФормы;
	ТипФорма = Тип("УправляемаяФорма");
	Пока ТипЗнч(ТекущийРодитель) <> ТипФорма Цикл 
		ТекущийРодитель = ТекущийРодитель.Родитель;
	КонецЦикла;
	Возврат ТекущийРодитель;
КонецФункции

// Преобразует код КодВход в уникальный среди кодов МассивКодовВход
// с максимлаьной длиной ДлинаКодаСтрокиВход.
Функция ПреобразоватьКодВУникальный(КодВход, МассивКодовВход, ДлинаКодаСтрокиВход, БезУчетаРегистра = Ложь) Экспорт
	РезультатФункции = "";
	Индекс = 1;
	ЕстьДубли = Истина;
	
	МассивПроверка = Новый Массив;
	Для Каждого ТекМассивКодовВход Из МассивКодовВход Цикл
		Если БезУчетаРегистра Тогда
			МассивПроверка.Добавить(ВРег(ТекМассивКодовВход));
		Иначе
			МассивПроверка.Добавить(ТекМассивКодовВход);
		КонецЕсли;		
	КонецЦикла;	
	
	Пока ЕстьДубли Цикл
		
		Если СтрДлина(КодВход) >= (ДлинаКодаСтрокиВход - 2) Тогда
			РезультатФункции = Лев(КодВход, СтрДлина(КодВход) - 2) + Формат(Индекс,"ЧЦ=2; ЧВН=");
		Иначе
			РезультатФункции = КодВход + Формат(Индекс, "ЧЦ=2; ЧВН=");
		КонецЕсли;
		
		Если БезУчетаРегистра Тогда
			НайденноеЗначение = МассивПроверка.Найти(ВРег(РезультатФункции));
		Иначе
			НайденноеЗначение = МассивПроверка.Найти(РезультатФункции);
		КонецЕсли;
		Если НайденноеЗначение = Неопределено Тогда
			
			ЕстьДубли = Ложь;
			Возврат РезультатФункции;
			
		Иначе
			
			Индекс = Индекс + 1;
			
		КонецЕсли;
		
	КонецЦикла;
	Возврат РезультатФункции;	
КонецФункции		// ПреобразоватьКодВУникальный()

// Возвращает копию списка значений СписокВход, в которой удален элемент со значением
// ЗначениеЭлементаВход.
Функция УдалитьЭлементСписокаЗначений(СписокВход, ЗначениеЭлементаВход) Экспорт
	РезультатФункции = СписокВход.Скопировать();
	НайденныйЭлемент = РезультатФункции.НайтиПоЗначению(ЗначениеЭлементаВход);
	Если НайденныйЭлемент <> Неопределено Тогда
		РезультатФункции.Удалить(НайденныйЭлемент);
	Иначе
		// Элемента уже нет. Не удаляем.
	КонецЕсли;
	Возврат РезультатФункции;
КонецФункции		// УдалитьЭлементСписокаЗначений()

// Обертка над служебным интерфейсом БСП.
// Рассчитывает показатели числовых ячеек в табличном документе.
//
// Параметры:
//   ПараметрыРасчета - структура - см. также ОбщегоНазначенияСлужебныйКлиент.ПараметрыРасчетаПоказателейЯчеек.
//
// Возвращаемое значение:
//   Структура - результаты расчета выделенных ячеек.
//       * Количество         - Число - Количество выделенных ячеек.
//       * КоличествоЧисловых - Число - Количество числовых ячеек.
//       * Сумма      - Число - Сумма выделенных ячеек с числами.
//       * Среднее    - Число - Сумма выделенных ячеек с числами.
//       * Минимум    - Число - Сумма выделенных ячеек с числами.
//       * Максимум   - Число - Максимум выделенных ячеек с числами.
//
Функция РасчетныеПоказателиЯчеек(ТабличныйДокумент, ВыделенныеОбласти) Экспорт
	Возврат ОбщегоНазначенияСлужебныйКлиентСервер.РасчетныеПоказателиЯчеек(ТабличныйДокумент, ВыделенныеОбласти);	
КонецФункции

Процедура ЗаполнитьМассивИзТаблицы(Массив, Таблица, ИмяПоля) Экспорт
	Для каждого Строка Из Таблица Цикл
		Массив.Добавить(Строка[ИмяПоля]);
	КонецЦикла;
КонецПроцедуры

Процедура ЗаполнитьТаблицуИзМассива(Таблица, Массив, ИмяПоля) Экспорт
	Для каждого Значение Из Массив Цикл
		Строка = Таблица.Добавить();
		Строка[ИмяПоля] = Значение;
	КонецЦикла;
КонецПроцедуры

Функция ЭтоЧисло(Знач ПроверяемоеЗначение) Экспорт
	
	Если ПроверяемоеЗначение = "0" ИЛИ ПроверяемоеЗначение = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	ОписаниеЧисла = Новый ОписаниеТипов("Число");
	
	Возврат ОписаниеЧисла.ПривестиЗначение(ПроверяемоеЗначение) <> 0;
	
КонецФункции
