#Область ОписаниеПеременных

// Соединение Кафка.
Перем Соединение;

// Соответствие заголовков.
Перем HTTPЗапрос;

// Соответствие заголовков.
Перем ИмяПотребителя;
Перем ИмяГруппыПотребителей;

// Вариант выполнения отправки.
Перем ВариантВыполнения;

// Признак заполнения настроек соединения.
Перем ПараметрыНастроены;

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Создает отправителя сообщений Kafka.
//
Процедура СоздатьОтправителя() Экспорт
	
	ПроверитьОбязательныеПараметрыЗаполнены();
	
	СоответствиеПараметровСервера = ПолучитьПараметрыИзТаблицы(Брокеры);
	СоответствиеПараметровСоединения = ПолучитьПараметрыИзТаблицы(ПараметрыКонфигурации, Перечисления.СП_каф_ТипыПараметров.Заголовок);
	
	ПараметрыНастроены = УстановитьСоединение(СоответствиеПараметровСервера, СоответствиеПараметровСоединения);
    	
КонецПроцедуры

// Создает получателя сообщений Kafka.
//
Функция СоздатьПолучателя() Экспорт
    
    Результат = Неопределено;
    
	ПроверитьОбязательныеПараметрыЗаполнены();
	
	СоответствиеПараметровСервера = ПолучитьПараметрыИзТаблицы(Брокеры);
	СоответствиеПараметровСоединения = ПолучитьПараметрыИзТаблицы(ПараметрыКонфигурации, Перечисления.СП_каф_ТипыПараметров.Заголовок);
	
	Если УстановитьСоединение(СоответствиеПараметровСервера, СоответствиеПараметровСоединения) Тогда
		СоответствиеПараметровТела = ПолучитьПараметрыИзТаблицы(ПараметрыКонфигурации, Перечисления.СП_каф_ТипыПараметров.Тело);
        Результат = ОткрытьКаналПодписки(СоответствиеПараметровТела);
	КонецЕсли;

    Возврат Результат;
КонецФункции

// Удаляет коннект подписчика.
// Если не удалить - будет обрушение REST PROXY на перебалансировке
//
Процедура УдалитьПолучателя(ДанныеПолучателя = Неопределено) Экспорт   
    
    ПроверитьСоединениеУстановлено();       
    УстановитьДанныеПолучателя(ДанныеПолучателя);
    
    УстановитьПараметрыЗапроса(Перечисления.СП_каф_ТипыПараметров.Заголовок);

	ОтправитьЗапрос("/consumers/%ИмяГруппыПотребителей%/instances/%ИмяПотребителя%", "DELETE");

КонецПроцедуры // УдалитьПолучателя()


// Устанавливает переданные параметры подключения.
// 
// Параметры:
//  СтруктураПараметров - Структура - структура параметров для установки.
//
Процедура УстановитьПараметры(СтруктураПараметров) Экспорт
	
	Для каждого Параметр Из СтруктураПараметров Цикл
		УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает переданный параметр соединения соединения Kafka.
// 
// Параметры:
//  ИмяПараметра 		- Строка - имя параметра.
//  ЗначениеПараметра 	- Строка - значение параметра.
//
Процедура УстановитьПараметр(ИмяПараметра, ЗначениеПараметра) Экспорт
	
	ПроверитьСоединениеУстановлено();
	
	Попытка
		Соединение.УстановитьПараметр(ИмяПараметра, ЗначениеПараметра);
		
	Исключение
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке());
		
	КонецПопытки;
	
КонецПроцедуры

// Получает параметр соединения Kafka по имени.
// 
// Параметры:
//  ИмяПараметра - Строка - имя параметра Kafka.
// 
// Возвращаемое значение:
// 	Строка, Число - значение установленного параметра Kafka, Неопределено - если значение не установлено.
//  
Функция ПолучитьПараметр(ИмяПараметра) Экспорт
	
	ПроверитьСоединениеУстановлено();
	
	ЗначениеПараметра = "";
	
	Попытка
		Успех = Соединение.ПолучитьПараметр(ИмяПараметра, ЗначениеПараметра);
		
	Исключение
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Если Не Успех Тогда
		ТекстИсключения = СтрШаблон("Не удалось получить параметр по имени %1!", ИмяПараметра);
		ВызватьИсключение НСтр(СтрШаблон("ru = '%1'", ТекстИсключения));
	КонецЕсли;
	
	Возврат ЗначениеПараметра;
	
КонецФункции

// Возвращает версию библиотеки по ее имени.
// 
// Параметры:
//  ИмяБиблиотеки - Строка - имя библиотеки: V8Kafka, RDKafka.
// 
// Возвращаемое значение:
//  Строка - версия библиотеки.
//
Функция ВерсияБиблиотеки(ИмяБиблиотеки = "V8Kafka") Экспорт
	
	ПроверитьСоединениеУстановлено();
	
	Если ИмяБиблиотеки = "V8Kafka" Тогда
		Версия = Соединение.ВерсияБиблиотекиV8Kafka();
		
	ИначеЕсли ИмяБиблиотеки = "RDKafka" Тогда
		Версия = Соединение.ВерсияБиблиотекиRDKafka();
		
	Иначе
		Версия = "<неизвестное имя библиотеки>";
		
	КонецЕсли;
	
	Возврат Версия;
	
КонецФункции


Процедура УстановитьПараметрыЗапроса(ТипПараметра)

	СоответствиеПараметровЗапроса = ПолучитьПараметрыИзТаблицы(ПараметрыКонфигурации, ТипПараметра);
	
    Если ТипЗнч(HTTPЗапрос) = Тип("HTTPЗапрос") Тогда
        HTTPЗапрос.Заголовки.Очистить();
        HTTPЗапрос.Заголовки = ОбщегоНазначения.СкопироватьРекурсивно(СоответствиеПараметровЗапроса);
    КонецЕсли;

КонецПроцедуры


// Устанавливает заголовки текущего соединения.
// 
// Параметры:
//  Заголовки - Соответствие - соответствие для установки заголовков.
//
Процедура УстановитьЗаголовки(Заголовки) Экспорт
		
	Для каждого Заголовок Из Заголовки Цикл
		ДобавитьЗаголовок(Заголовок.Ключ, Заголовок.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Добавляет заголовок к текущему соединению.
// 
// Параметры:
//  Ключ 		- Произвольный - ключ устанавливаемого заголовка.
//  Значение 	- Произвольный - значение устанавливаемого заголовка.
//
Процедура ДобавитьЗаголовок(Ключ, Значение) Экспорт
	
	ПроверитьСоединениеУстановлено();
	
	Попытка
		Успех = Соединение.ДобавитьЗаголовок(Ключ, Значение);
				
	Исключение
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Если Не Успех Тогда
		ТекстИсключения = СтрШаблон("Не удалось установить заголовок сообщения: %1:%2!", Ключ, Значение);
		ТекстИсключения = НСтр(СтрШаблон("ru = '%1'", ТекстИсключения));
		
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
		
КонецПроцедуры

// Получает заголовки сообщения в виде соответствия.
//
// Возвращаемое значение:
//   Соответствие - заголовки сообщения в формате ключ-значение.
//
Функция ПолучитьЗаголовки() Экспорт
	
	ПроверитьСоединениеУстановлено();
	
	ЗаголовкиКафка = Новый Соответствие;
	
	Попытка
		Ключи = Соединение.ПолучитьКлючиЗаголовков();
	Исключение
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке());
	КонецПопытки;
	
	Пока Не ПустаяСтрока(Ключи) Цикл
		
		Поз = СтрНайти(Ключи, "|");
		Если Поз = 0 Тогда
			Ключ = Ключи;
			Ключи = "";
		Иначе
			Ключ = Лев(Ключи, Поз - 1);
			Ключи = Сред(Ключи, Поз + 1);
		КонецЕсли;
		
		Попытка
			Значение = "";
			Успех = Соединение.ПолучитьЗначенияЗаголовка(Ключ, Значение);
			Если Успех Тогда
				ЗаголовкиКафка.Вставить(Ключ, Значение);
			КонецЕсли;
			
		Исключение
			ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке());
			
		КонецПопытки;
		
	КонецЦикла;
	
	Возврат ЗаголовкиКафка;
	
КонецФункции

// Очищает заголовки текущего соединения.
//
Процедура ОчиститьЗаголовки() Экспорт
	
	ПроверитьСоединениеУстановлено();
	
	Попытка
		Успех = Соединение.ОчиститьЗаголовки();
		
	Исключение
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Если Не Успех Тогда
		ВызватьИсключение НСтр("ru = 'Не удалось выполнить очистку заголовков!'");
	КонецЕсли;
		
КонецПроцедуры

// Удаляет заголовок по переданному ключу.
// 
// Параметры:
//  Ключ - Произвольный - ключ удаляемого заголовка.
//
Процедура УдалитьЗаголовок(Ключ) Экспорт
	
	ПроверитьСоединениеУстановлено();
	
	Попытка
		Успех = Соединение.УдалитьЗаголовок(Ключ);
				
	Исключение
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Если Не Успех Тогда
		ВызватьИсключение НСтр("ru = 'Не удалось удалить заголовок сообщения!'");
	КонецЕсли;
	
КонецПроцедуры

// Выполняет подписку соединения Кафка на указанную тему.
// 
// Параметры:
//  Тема - Строка - имя темы для подписки. 
//
Процедура Подписаться(Тема) Экспорт
	
	ПроверитьСоединениеУстановлено();  
    
	Если ТипЗнч(Тема) <> Тип("Массив") Тогда
		МассивТемы = Новый Массив;
		МассивТемы.Добавить(Тема);
	Иначе
		МассивТемы = Тема;
	КонецЕсли;
	
	Попытка
		СтруктураЗапроса = Новый Структура("topics", МассивТемы);
        
        УстановитьПараметрыЗапроса(Перечисления.СП_каф_ТипыПараметров.Заголовок);
        
		ОтветСервера = ОтправитьЗапрос("/consumers/%ИмяГруппыПотребителей%/instances/%ИмяПотребителя%/subscription", "POST", СтруктураЗапроса);
        
        Если Не СП_ОбменДанными.ЛюбойСоответствует(СтрРазделить("200,204", ",", Ложь),
            "Число(Элемент) = Параметр1",  ОтветСервера.КодСостояния) Тогда
            ВызватьИсключение ОтветСервера.ПолучитьТелоКакСтроку();
        КонецЕсли;
        
	Исключение
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке());
		
	КонецПопытки;
	
КонецПроцедуры

// <Описание функции>
//
// Параметры:
//  <Параметр1>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//  <Параметр2>  - <Тип.Вид> - <описание параметра>
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   <Тип.Вид>   - <описание возвращаемого значения>
//
Функция ОткрытьКаналПодписки(СоответствиеПараметровТела)
    
    ПроверитьСоединениеУстановлено();       

    БазовыйURI = "";
    // параметры по умолчанию  
    // Если имя consumer-а не задано - генерируем уникальное
    ПараметрыПодписки = Новый Соответствие;
    ПараметрыПодписки.Вставить("name", СтрШаблон("consumer_instance-id-%1", Новый УникальныйИдентификатор()));  
    ПараметрыПодписки.Вставить("format", "binary");
    ПараметрыПодписки.Вставить("auto.offset.reset", "earliest");
    ПараметрыПодписки.Вставить("auto.commit.enable", "true");

    // Переустанавливаем значения по умолчанию
    Для каждого Параметр Из СоответствиеПараметровТела Цикл
        Если ПараметрыПодписки.Получить(Параметр.Ключ) <> Неопределено Тогда
            ПараметрыПодписки[Параметр.Ключ] = Параметр.Значение;
        КонецЕсли;
    КонецЦикла;
    
    УстановитьПараметрыЗапроса(Перечисления.СП_каф_ТипыПараметров.Заголовок);
    
    ОтветСервера = ОтправитьЗапрос("/consumers/%ИмяГруппыПотребителей%", "POST", ПараметрыПодписки);
    Если ОтветСервера.КодСостояния = 200 Тогда
        
        ДанныеОтвета = СП_ОбменДанными.ДанныеИзСтрокиJSON(ОтветСервера.ПолучитьТелоКакСтроку());
        
        Если ДанныеОтвета.Свойство("base_uri") Тогда        
            БазовыйURI = ДанныеОтвета.base_uri;                     
        КонецЕсли;
        Если  ДанныеОтвета.Свойство("instance_id") Тогда
            ИмяПотребителя = ДанныеОтвета.instance_id;
        КонецЕсли;
    КонецЕсли; 

    Результат = Новый Структура("ConsumerGroup, ConsumerInstance, BaseURI", ИмяГруппыПотребителей, ИмяПотребителя, БазовыйURI);
    
    Возврат Результат;
КонецФункции // ОткрытьКаналПодписки()


Процедура УстановитьДанныеПолучателя(ДанныеПолучателя = Неопределено)
    
    Если ТипЗнч(ДанныеПолучателя) = Тип("Структура") Тогда
        УстановитьЗначениеСвойства(ДанныеПолучателя, "ConsumerGroup", ИмяГруппыПотребителей);    
        УстановитьЗначениеСвойства(ДанныеПолучателя, "ConsumerInstance", ИмяПотребителя);            
    КонецЕсли;
    
КонецПроцедуры


Процедура УстановитьЗначениеСвойства(Данные, ИмяСвойства, ЗначениеСвойстваОбработки)
    
    ЗначениеСвойстваСтруктуры = Неопределено;
    Если Данные.Свойство(ИмяСвойства, ЗначениеСвойстваСтруктуры) Тогда
        Если ЗначениеЗаполнено(ЗначениеСвойстваСтруктуры) Тогда
            ЗначениеСвойстваОбработки = ЗначениеСвойстваСтруктуры;           
        КонецЕсли;
    КонецЕсли;     

КонецПроцедуры



// Выполняет отправку сообщения в текущем соединении.
// 
// Параметры:
//  Сообщение 		- Строка, ДвоичныеДанные - отправляемое сообщение.
//  Тема 			- Строка 		- имя темы для отправки сообщения.
//  Раздел 			- Число 		- номер раздела для отправки сообщения.
//  Ключ 			- Число, Строка - ключ сообщения.
//  МеткаВремени 	- Число 		- метка времени.
//
// Возвращаемое значение:
//  Булево - итог выполнения отправки.
//
Функция ОтправитьСообщение(Сообщение, Тема, Раздел = 0, Ключ = 0, МеткаВремени = 0) Экспорт
	
	ПроверитьСоединениеУстановлено();
		
	Попытка
		Успех = ОтправитьСообщениеВыполнениеПоВарианту(Сообщение, Тема, Раздел, Ключ, МеткаВремени);
		
	Исключение
		Успех = Ложь;
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Если Не Успех Тогда
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Соединение, НСтр("ru = 'Не удалось отправить сообщение!'"));
	КонецЕсли;
	
	Возврат Успех;
	
КонецФункции

// Выполняет получение сообщений в текущем соединении.
// 
// Параметры:
//  Сообщение    - Строка, ДвоичныеДанные - полученное сообщение.
//  Ключ         - Строка - ключ сообщения.
//  МеткаВремени - Число - метка времени сообщения.
// 
// Возвращаемое значение:
// 	Булево - Истина, если сообщение получено, Ложь если достигнут таймаут.
//  
Функция ПолучитьСообщение(Сообщение, Ключ = "", МеткаВремени = 0) Экспорт
	
	ПроверитьСоединениеУстановлено();
	
	Попытка

        УстановитьПараметрыЗапроса(Перечисления.СП_каф_ТипыПараметров.ЗаголовокЧтения);    
        
        ТекстЗапроса = СтрШаблон("/consumers/%1/instances/%2/records?timeout=%3&max_bytes=%4",
                "%ИмяГруппыПотребителей%", "%ИмяПотребителя%", 
                Формат(Таймаут, "ЧРГ=' '; ЧГ=0"), "30000000");
        
		Сообщение = ОтправитьЗапрос(ТекстЗапроса, "GET");
		Если Сообщение.КодСостояния = 200 Тогда
			Сообщение = Сообщение.ПолучитьТелоКакСтроку();
			Результат = НЕ ПустаяСтрока(Сообщение);
		Иначе
			Результат = Ложь;            
		КонецЕсли;
	Исключение
		Результат = Ложь;
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Явно фиксирует смещение у прочитанного сообщения.
// Имеет смысл только при параметре auto.commit.enable=false.
//
Функция ЗафиксироватьСмещение(Тема, Раздел = 0, Смещение = 0) Экспорт
	
	
	ПроверитьСоединениеУстановлено();
	
	Попытка
		СтруктураЗапроса = Новый Структура("offsets", Новый Массив);
        СтруктураСмещенияТопика = Новый Структура("topic, partition, offset", Тема, Раздел, Смещение);
        СтруктураЗапроса.offsets.Добавить(СтруктураСмещенияТопика);
		Сообщение = ОтправитьЗапрос("/consumers/%ИмяГруппыПотребителей%/instances/%ИмяПотребителя%/positions", "POST", СтруктураЗапроса);
		Если Сообщение.КодСостояния = 200 Или Сообщение.КодСостояния = 204 Тогда
			Результат = Истина;
		Иначе
			Результат = Ложь;
		КонецЕсли;
	Исключение
		Результат = Ложь;
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Выполняет проверку соединения с сервером Kafka.
// 
// Параметры:
// 	ТемаДляПроверки - Строка - имя темы для проверки соединения.
//
Процедура ПроверитьСоединение(ТемаДляПроверки = "Test") Экспорт
	
	ПолучаемоеСообщение = "";
	ТекстСообщения = XMLСтрока(Новый УникальныйИдентификатор());
	ДатаСообщения = ТекущаяДатаСеанса(); 
	ОтправляемоеСообщение = СтрШаблон("Тестовое Сообщение - %1 от %2 ", ТекстСообщения, ДатаСообщения);
	
	Попытка
		//СоздатьОтправителя();
		//ОтправитьСообщение(ОтправляемоеСообщение, ТемаДляПроверки);
		
		СоздатьПолучателя();
		Подписаться(ТемаДляПроверки);
		ПолучитьСообщение(ПолучаемоеСообщение, ТемаДляПроверки);
		
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		СгенерироватьТочнуюОшибку(ТекстОшибки);
		
		ВызватьИсключение ТекстОшибки;
		
	КонецПопытки;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Выполняет инициализацию при создании нового объекта.
//
Процедура Инициализация()
	
	ПодготовитьВозможныеВарианты();
	
	ПараметрыНастроены = Ложь;
	
КонецПроцедуры

// Возвращает точный текст ошибки исполнения.
//
Функция ТекстТочнойОшибки(Знач ИнформацияОбОшибке)
	
	Возврат ТекстТочнойОшибкиОбъекта(Соединение, ИнформацияОбОшибке);
	
КонецФункции

// Возвращает точный текст ошибки объекта.
// 
// Параметры:
//  Объект 				- V8KafkaClient - объект внешней компоненты.
//  ИнформацияОбОшибке 	- ИнформацияОбОшибке - структурированная информация об ошибке.
// 
// Возвращаемое значение:
//  Строка - текст точной ошибки объекта
//
Функция ТекстТочнойОшибкиОбъекта(Знач Объект, Знач ИнформацияОбОшибке)
	
	ТекстОшибки = ИнформацияОбОшибке;
	Если Тип("ИнформацияОбОшибке") = ТипЗнч(ИнформацияОбОшибке) Тогда
		ТекстОшибки = ИнформацияОбОшибке.Описание;
		Сообщить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
	КонецЕсли;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Генерирует точную ошибку исполнения.
//  
// Из-за несовершенства NativeAPI неудобно получать текст ошибок компоненты
// Метод позволяет выбросить исключение с новым текстом ошибки.
//  Недостатки: теряется стек вызовов
//
// Параметры:
//  ИнформацияОбОшибке - ИнформацияОбОшибке - исходное исключение 1С.
//
Процедура СгенерироватьТочнуюОшибку(Знач ИнформацияОбОшибке)
	
	ВызватьИсключение ТекстТочнойОшибки(ИнформацияОбОшибке);
	
КонецПроцедуры

// Получает параметры соединения из табличной части обработки.
// 
// Параметры:
//  Таблица - ТабличнаяЧасть - таблица параметров.
// 
// Возвращаемое значение:
// 	Структура - параметры для установки.
//  
Функция ПолучитьПараметрыИзТаблицы(Таблица, ТипПараметра = Неопределено)
	
	Коллекция = Новый Соответствие;
	
	Если Таблица = Брокеры Тогда
		ТекстАдресКластера = "";
		Для каждого Строка Из Таблица Цикл
			ТекстАдресКластера = СтрШаблон("%1%2:%3,", ТекстАдресКластера, Строка.Сервер, Строка.Порт);
		КонецЦикла;
		ТекстАдресКластера = Лев(ТекстАдресКластера, СтрДлина(ТекстАдресКластера) - 1);
		
		Коллекция.Вставить(КлючАдресКластера(), ТекстАдресКластера);
	Иначе
		Для каждого Строка Из Таблица Цикл
			Если Строка.ТипПараметра = ТипПараметра Тогда
				Коллекция[Строка.Ключ] = Строка.Значение;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Коллекция;
	
КонецФункции

// Возвращает значение ключа адреса кластера.
// 
// Возвращаемое значение:
//  Строка - ключ адреса кластера.
//
Функция КлючАдресКластера()
	
	Возврат "metadata.broker.list";
	
КонецФункции

// Отправляет сообщение по выбранному варианту.
// 
// Параметры:
//  Тема 			- Строка - название темы для отправки.
//  Сообщение 		- ДвоичныеДанные, Строка - сообщение для отправки.
//  Раздел 			- Число - номер раздела.
//  Ключ 			- Число, Строка - ключ сообщения.
//  МеткаВремени 	- Число - метка времени.
// 
// Возвращаемое значение:
// 	Булево - результат выполнения отправки.
//  
Функция ОтправитьСообщениеВыполнениеПоВарианту(Сообщение, Тема, Раздел, Ключ, МеткаВремени)
	
	Вариант = ОпределитьВариантОтправки(Раздел, Ключ, МеткаВремени);
	
    Если Вариант = ВариантВыполнения.ВТему Тогда
   		Результат = Опубликовать(Сообщение, Тема);
	ИначеЕсли Вариант = ВариантВыполнения.ВТемуСМеткой Тогда
		Результат = Опубликовать(Сообщение, Тема, , , МеткаВремени);
	ИначеЕсли Вариант = ВариантВыполнения.ВТемуСКлючем Тогда
		Результат = Опубликовать(Сообщение, Тема, , Ключ);
	ИначеЕсли Вариант = ВариантВыполнения.ВТемуСКлючемМеткой Тогда
		Результат = Опубликовать(Сообщение, Тема, , Ключ, МеткаВремени);
	ИначеЕсли Вариант = ВариантВыполнения.ВРаздел Тогда
		Результат = Опубликовать(Сообщение, Тема, Раздел);
	ИначеЕсли Вариант = ВариантВыполнения.ВРазделСМеткой Тогда
		Результат = Опубликовать(Сообщение, Тема, Раздел, , МеткаВремени);
	ИначеЕсли Вариант = ВариантВыполнения.ВРазделСКлючем Тогда
		Результат = Опубликовать(Сообщение, Тема, Раздел, Ключ);
	Иначе
		Результат = Опубликовать(Сообщение, Тема, Раздел, Ключ, МеткаВремени);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Публикация сообщения в Кафка
//
// Параметры:
//  Тема 			- Строка - название темы для отправки.
//  Сообщение 		- ДвоичныеДанные, Строка - сообщение для отправки.
//  Раздел 			- Число - номер раздела.
//  Ключ 			- Число, Строка - ключ сообщения.
//  МеткаВремени 	- Число - метка времени.
// 
// Возвращаемое значение:
// 	Булево - результат выполнения отправки.
//
Функция Опубликовать(Сообщение, Тема, Раздел = Неопределено, Ключ = Неопределено, МеткаВремени = Неопределено)
    
    УстановитьПараметрыЗапроса(Перечисления.СП_каф_ТипыПараметров.Заголовок);
    
    ШаблонАдреса = СтрШаблон("/topics/%1", Тема);
    
    ЗаписьКафка = Новый Структура("records", Новый Массив);
    ЗаписьСообщения = Новый Структура("value", "%Сообщение%");
    
    Если Раздел <> Неопределено Тогда
        ЗаписьСообщения.Вставить("partition", Раздел);
    КонецЕсли;
    
    Если Ключ <> Неопределено Тогда
        ЗаписьСообщения.Вставить("key", Ключ);
    КонецЕсли;
    
    Если МеткаВремени <> Неопределено Тогда
        ЗаписьСообщения.Вставить("timestamp", МеткаВремени);
    КонецЕсли;
    
    ЗаписьКафка.records.Добавить(ЗаписьСообщения);        
    
    // чтобы 1С своими преобразованиями не портило сообщение
    ТелоЗапроса = СП_ОбменДанными.ДанныеВСтрокуJSON(ЗаписьКафка);
    ТелоЗапроса = СтрЗаменить(ТелоЗапроса, """%Сообщение%""", Сообщение);
    
    
    Ответ = ОтправитьЗапрос(ШаблонАдреса, "POST", ТелоЗапроса);
    Если Ответ.КодСостояния = 200 Тогда
        ТелоОтвета = Ответ.ПолучитьТелоКакСтроку(); 
        ДанныеОтвета = СП_ОбменДанными.ДанныеИзСтрокиJSON(ТелоОтвета);
        Если ДанныеОтвета.Свойство("offsets") Тогда
            Для каждого Смещение Из ДанныеОтвета.offsets Цикл
                Если ЗначениеЗаполнено(Смещение.error_code) Тогда
                    ВызватьИсключение СтрШаблон("Ошибка сервера %1: %2", Смещение.error_code, Смещение.error);        	        
                КонецЕсли;
            КонецЦикла; 
        Иначе
            ВызватьИсключение СтрШаблон("Не удалось разобрать ответ сервера %1", ТелоОтвета);        	        
        КонецЕсли;        
    Иначе
        ВызватьИсключение Ответ.ПолучитьТелоКакСтроку();
    КонецЕсли;
    
    Возврат Истина;
КонецФункции // Отправить()


Функция ОпределитьВариантОтправки(Раздел, Ключ, МеткаВремени)
	
	Вариант = 0;
	ВариантРаздел = 4;
	ВариантКлюч = 2;
	ВариантМетка = 1;
	
	Если ЗначениеЗаполнено(Раздел) Тогда
		Вариант = Вариант + ВариантРаздел;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Ключ) Тогда
		Вариант = Вариант + ВариантКлюч;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(МеткаВремени) Тогда
		Вариант = Вариант + ВариантМетка;
	КонецЕсли;
	
	Возврат Вариант;
	
КонецФункции

// Устанавливает возможные варианты выполнения отправки.
// 
Процедура ПодготовитьВозможныеВарианты()
	
	ВозможныеВарианты = Новый Структура;
	ВозможныеВарианты.Вставить("ВТему", 0);
	ВозможныеВарианты.Вставить("ВТемуСМеткой", 1);
	ВозможныеВарианты.Вставить("ВТемуСКлючем", 2);
	ВозможныеВарианты.Вставить("ВТемуСКлючемМеткой", 3);
	ВозможныеВарианты.Вставить("ВРаздел", 4);
	ВозможныеВарианты.Вставить("ВРазделСМеткой", 5);
	ВозможныеВарианты.Вставить("ВРазделСКлючем", 6);
	
	ВариантВыполнения = Новый ФиксированнаяСтруктура(ВозможныеВарианты);
	
КонецПроцедуры

// Выполняет проверку заполнения обязательных параметров клиента Kafka.
// Если заполнены не все параметры - вызывает исключение.
//
Процедура ПроверитьОбязательныеПараметрыЗаполнены()
	
	ЕстьОшибки = Ложь;
	ТекстОшибки = "";
	
	Если Не ЗначениеЗаполнено(Брокеры) Тогда
		ТекстОшибки = "Для клиента Кафка не заполнены серверы кластера!"; 
		ТекстОшибки = СтрШаблон("%1%2", Символы.ПС, ТекстОшибки);
		
		ЕстьОшибки = Истина;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПараметрыКонфигурации) Тогда
		ТекстОшибки = "Для клиента Кафка не заполнены параметры соединения!"; 
		ТекстОшибки = СтрШаблон("%1%2", Символы.ПС, ТекстОшибки);
		
		ЕстьОшибки = Истина;
	КонецЕсли;
	
	Если ЕстьОшибки Тогда
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет проверку установки соединения через ВК.
// Если соединение не установлено - вызывает исключение.
//
Процедура ПроверитьСоединениеУстановлено()
	
	Если Соединение = Неопределено Тогда
		ТекстОшибки = "ru = 'Не установлено соединение с компонентой V8KafkaClient.
					  |Для продожения работы необходимо создать Отправителя или Получателя.'";
		
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область каф_ЛокализацияПодRestAPI

Функция ПолучитьСтрокуJSON(ДанныеЗапроса)
	
	ЗаписьJSON = Новый ЗаписьJSON(); 
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, ДанныеЗапроса);

	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

Функция ОтправитьЗапрос(ШаблонАдреса, Метод, ДанныеЗапроса = Неопределено)

    Адрес = СтрЗаменить(ШаблонАдреса, "%ИмяПотребителя%", ИмяПотребителя);
    Адрес = СтрЗаменить(Адрес, "%ИмяГруппыПотребителей%", ИмяГруппыПотребителей);
	
	HTTPЗапрос.АдресРесурса = Адрес;
	
	Если ДанныеЗапроса <> Неопределено Тогда
		Если ТипЗнч(ДанныеЗапроса) = Тип("Строка") Тогда
            HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеЗапроса);
        ИначеЕсли ТипЗнч(ДанныеЗапроса) = Тип("ДвоичныеДанные") Тогда
            HTTPЗапрос.УстановитьТелоИзДвоичныхДанных(ДанныеЗапроса); 
        Иначе            
			ЗапросСтрока = СП_ОбменДанными.ДанныеВСтрокуJSON(ДанныеЗапроса);
            HTTPЗапрос.УстановитьТелоИзСтроки(ЗапросСтрока);
		КонецЕсли;		
	КонецЕсли;
	
	HTTPОтвет = Соединение.ВызватьHTTPМетод(Метод, HTTPЗапрос);

    // Обработка редиректа
	Если HTTPОтвет.КодСостояния = 301 или HTTPОтвет.КодСостояния = 302 Тогда
		НовыйАдрес = HTTPОтвет.Заголовки.Получить("Location");
		Если Не ПустаяСтрока(НовыйАдрес) Тогда
			HTTPОтвет = ОтправитьЗапрос(ШаблонАдреса, Метод, ДанныеЗапроса);
		КонецЕсли;	
    КонецЕсли;	
    
    ЛогЗапрос = СтрШаблон("%1%2%3 %4%5Host %6:%7%8%9%10",
            ТекущаяДатаСеанса(), // 1
            Символы.ПС, // 2
            Метод, // 3
            Адрес, // 4    
            Символы.ПС, // 5
            Соединение.Сервер, // 6  
            Формат(Соединение.Порт, "ЧРГ=' '; ЧГ=0"), // 7
            Символы.ПС, // 8
            ЗаголовкиЗапросаКакСтрока(HTTPЗапрос.Заголовки), // 9
            Символы.ПС); // 10
         
    ЛогОтвет = СтрШаблон("%1%2%3%4%5%6", 
            HTTPОтвет.КодСостояния, // 1
            Символы.ПС, // 2
            ЗаголовкиЗапросаКакСтрока(HTTPОтвет.Заголовки), // 3
            Символы.ПС, // 4
            HTTPОтвет.ПолучитьТелоКакСтроку(), // 5
            Символы.ПС); // 6                      
            
    ТекстовыйЛог = СтрШаблон("%1%2%3", ЛогЗапрос, Символы.ПС, ЛогОтвет);        
            
    Если Не СП_ОбменДанными.ЛюбойСоответствует(СтрРазделить("200,204", ",", Ложь),
        "Число(Элемент) = Параметр1",  HTTPОтвет.КодСостояния) Тогда
        ЗаписьЖурналаРегистрации(ИмяСобытия(),УровеньЖурналаРегистрации.Ошибка,,,ТекстовыйЛог);
    КонецЕсли;
	
	Возврат HTTPОтвет;
	
КонецФункции

Функция УстановитьСоединение(ПараметрыСервера, Заголовки)
	
	ЗащищенноеСоединение = Неопределено; //Заголовки.Получить("security.protocol");
	URLRestApi = ПараметрыСервера[КлючАдресКластера()];
	Если ЗащищенноеСоединение <> Неопределено Тогда
		Соединение = Новый HTTPСоединение(URLRestApi,,,,,,Новый ЗащищенноеСоединениеOpenSSL());
	Иначе
		Соединение = Новый HTTPСоединение(URLRestApi);
	КонецЕсли;
	СтрокаИмяПотребителя = ПараметрыКонфигурации.Найти(Перечисления.СП_каф_ТипыПараметров.Авторизация, "ТипПараметра");
	ИмяПотребителя = Неопределено;
    Если СтрокаИмяПотребителя <> Неопределено Тогда
        ИмяПотребителя = СокрЛП(СтрокаИмяПотребителя.Значение);
    КонецЕсли;
    
    Если Не ЗначениеЗаполнено(ИмяПотребителя) Тогда
        ИмяПотребителя = ОбщегоНазначенияУХ.ПолучитьПредставлениеИнформационнойБазы();
        ИмяПотребителя = СтрЗаменить(ИмяПотребителя, " ", "_");
        ИмяПотребителя = СтрЗаменить(ИмяПотребителя, ".", "_");
        ИмяПотребителя = ОбщегоНазначенияКлиентСервер.ЗаменитьНедопустимыеСимволыВИмениФайла(ИмяПотребителя, "_");
    КонецЕсли;
    
    ИмяГруппыПотребителей = ИмяПотребителя;
	
	
	HTTPЗапрос = Новый HTTPЗапрос;
	HTTPЗапрос.Заголовки = Новый Соответствие(Новый ФиксированноеСоответствие(Заголовки));
	
	Возврат ТипЗнч(Соединение) = Тип("HTTPСоединение");
	
КонецФункции

Функция ЗаголовкиЗапросаКакСтрока(Заголовки)      
    
    МассивСтрок = Новый Массив;
    Для каждого Заголовок Из Заголовки Цикл
        МассивСтрок.Добавить(СтрШаблон("%1:%2", Заголовок.Ключ, Заголовок.Значение));   
    КонецЦикла;     
    
    Возврат СтрСоединить(МассивСтрок, Символы.ПС);
    
КонецФункции    

Функция ИмяСобытия()

	Возврат Метаданные().ПолноеИмя();

КонецФункции // ИмяСобытия()


#КонецОбласти

#Область Инициализация

Инициализация();

#КонецОбласти