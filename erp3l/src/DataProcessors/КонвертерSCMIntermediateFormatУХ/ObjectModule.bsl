///////////////////////////////////////////////////////////////////////////////
//
// Центральная обработка для выполнения конвертации объектов УХ в/из формат
// SCMIntermediateFormat для обмена с ЭТП.
//
// Общие положения:
// 1. Сериализация/десериализация выполняется вне транзакций.
//		Для преобразования объектов УХ в XDTO это выполняется автоматически.
//		Для обратного преобразования XDTO в объекты УХ необходимо, чтобы
//		функции преобразования возвращали объекты, а не ссылки.
//		Запись объектов БД внутри функций данного набора обработок
//		запрещена.
// 2. В данной обработке определена работа с базовыми функциями CRUD
//		типовых объектов централизованных закупок. Кроме этого определены
//		вспомогательные функции поддержки создания собственных обработок
//		конвертации.
// 3. Для вызова функций конвертации используйте единую точку входа
//		функцию ВыполнитьФункциюКонвертации(Имя функции конвертации,
//											Имя типа,
//											Данные).
// 		Функции конвертации различаются именами и именами типов данных.
//		Последние могут быть, либо сокращенным наименованием типа 1С
//		(например, Документ.ПрограммаЗакупок), либо именем типа xsd
//		пространства имен пакета SCMIntermediateFormat.
//		Определены следующие имена функций:
//			- ПреобразоватьСсылкуВXDTO - для ссылки на объект 1С:УХ
//				возвращает объект XDTO;
//			- ПреобразоватьСписокВXDTO - для однородного списка ссылок
//				 возвращает объект XDTO;
//			- НайтиСсылкуНаОбъектИзXDTO - по объекту XDTO возвращает ссылку
//				на объект 1С:УХ;
//			- СоздатьОбъектИзXDTO - по объекту XDTO возвращает заполненный
//				в памяти объект 1С:УХ;
//			- ОбновитьОбъектИзXDTO - по объекту XDTO обновить переданный
//				в памяти объект 1С:УХ;
// 4. Обработка "КонвертерSCMIntermediateFormatУХ" является точкой входа
//		для функций сериализации/десериализации. Содержание соответствующих
//		функций опеределено в обработке КонвертерSCMIntermediateFormatУХБаза.
// 5. Можно переопределять функции конвертации заменяя существующие,
//		добавляя поддержку новых типов объектов или определяя новые функции.
//		Для этого необходимо создать обработку с именем начинающимся на
//		"SCMIntermediateFormat" и заканчивающимся на уникальный префикс.
//		Определить в ней экспортные функции ПолучитьОписаниеКонвертера()
//		и ВыполнитьФункциюКонвертации(). Условия их создания см. в
//		описании.
// 6. Если вы создали собственную обработку конвертации, то не вызывайте
//		ее функции напрямую, используйте ВыполнитьФункциюКонвертации()
//		данной обработки.
// 7. Для сериализации в XDTO произвольных объектов можно использовать тип
//		AnyObject. Для добавления произвольных реквизитов в существующий
//		объект XDTO используйте реквизит any c типом AnyProperties.
//
///////////////////////////////////////////////////////////////////////////////


#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	
	
// Контекст обработок конвертации.
// Запрещено обращаться к переменной прямо.
// Используйте экспортные функции обработки, либо ПолучитьКонтекст().
//
// Структура:
//	- ОписаниеФункций - ТаблицаЗначений - см. СоздатьТЗОписанияФункций().
//	- ФабрикаXDTO - ФабрикаXDTO - кэш фабрики для SCMIntermediateFormat.
//	- КорневыеОбъекты - КоллекцияСвойствXDTO - корневые объекты XDTO.
//
Перем КонтекстОбработокГлобальнаяПеременная;


#Область ИдентификацияОбработки


// Данная функция должна быть определена в каждой обработке конвертации.
// Вынесена в модуль менеджера, чтобы не создавать лишний раз обработку
// для чтения ее свойств.
//
// Возвращает описание конвертера:
//	- РасширяетКонвертер - Строка - имя обработки конвертера, которую
//			заменяет данная. Обязательна к заполнению. Перекрытые функции
//			"старого" конвертера не будут вызваны. При необходимости их можно
//			вызвать через функцию ВызватьПредыдущую(). Если два конвертера будут
//			переопределять одну и ту же функцию для одного типа данных и иметь
//			один и тот же конвертер-предок, то будет выдана ошибка.
//			В случае такой ситуации необходимо, либо изменить поле
//			РасширяетКонвертер в вашей обработке на ту, с которой она конфликтует,
//			либо удалить определение конфликтной функции из описания типа данных,
//			для которого происходит перекрытие (см. СоответвиеФункцийКонвертации
//			ниже).
//	- СоответвиеФункцийКонвертации - ФиксированноеСоответствие - ключ - тип
//			данных конфигурации УХ. Значение - массив с именами функций,
//			которые предоставляет обработка для данного типа данных.
//			
Функция ПолучитьОписаниеКонвертера() Экспорт
	Описание = Новый Структура;
	// Данная обработка - это корень всех конвертеров.
	Описание.Вставить("РасширяетКонвертер", "");
	// Данная обработка не выполняет конвертацию непосредственно.
	// См. обработку КонвертерSCMIntermediateFormatУХБаза
	Описание.Вставить("СоответвиеФункцийКонвертации",
		Новый ФиксированноеСоответствие(Новый Соответствие)); 
	Возврат Описание;
КонецФункции


#КонецОбласти


#Область ПрограммныйИнтерфейс


// Ищет подходящую обработку конвертации и вызывает у нее указанную функцию.
// Правила поиска:
//	1. Отбирает все обработки с именем начинающимся на
//	   "КонвертерSCMIntermediateFormatУХ".
//	2. Среди них отбирает все, которые в описании содержат нужную функцию
//		и тип.
//	3. Ранжирует обработки по их подчиненности друг другу и выбирает
//		самую неперекрытую обработку.
//	
// Параметры:
//  ИмяФункции - Строка - имя функции.
//	ИмяТипа1С  - Строка - имя типа значения конфигурации УХ или пространства
//			имен xsd пакета SCMIntermediateFormat.
//			Необходим для определения конечной функции, которая будет использована
//			при сериализации/десерилазиации.
//	Контекст   - Произвольный - любое значение. Определяется конечной функцией
//			обработки.
//
// Возвращаемое значение:
//	- Структура - см. описание Обработка.КонвертерОбъектовXDTOУХ.РезультатУспех(),
//					Обработка.КонвертерОбъектовXDTOУХРезультатОшибка():
//		- Результат - ОбъектXDTO|Объект 1С|Ссылка 1С - представление объекта.
//
Функция ВыполнитьФункциюКонвертации(ИмяФункции, ИмяТипа1С, Контекст) Экспорт
	ИмяОбработки = НайтиОбработкуФункцииДляТипа(ИмяФункции, ИмяТипа1С);
	Возврат ВыполнитьФункциюОбработки(
		ИмяОбработки, ИмяФункции, ИмяТипа1С, Контекст);
КонецФункции

// Ищет ближайшую подходящую обработку конвертации, перекрытую обработкой
// ИмяОбработкиПотомка, и вызывает у нее указанную функцию. Правила поиска:
//	1. Отбирает все обработки с именем начинающимся на
//	   "КонвертерSCMIntermediateFormatУХ".
//	2. Среди них отбирает все, которые в описании содержат нужную функцию
//		и тип.
//	3. Ранжирует обработки по их подчиненности друг другу и выбирает
//		самую неперекрытую обработку.
//	
// Параметры:
//  ИмяФункции - Строка - имя функции.
//	ИмяТипа1С  - Строка - имя типа значения конфигурации УХ или пространства
//			имен xsd пакета SCMIntermediateFormat.
//			Необходим для определения конечной функции, которая будет использована
//			при сериализации/десерилазиации.
//	Контекст   - Произвольный - любое значение. Определяется конечной функцией
//			обработки.
//
// Возвращаемое значение:
//	- Структура - см. описание Обработка.КонвертерОбъектовXDTOУХ.РезультатУспех(),
//						Обработка.КонвертерОбъектовXDTOУХ.РезультатОшибка():
//		- Результат - ОбъектXDTO|Объект 1С|Ссылка 1С - представление объекта.
//
Функция ВыполнитьФункциюКонвертацииПредка(ИмяОбработкиПотомка, 
										  ИмяФункции, 
										  ИмяТипа1С, 
										  Контекст) Экспорт
	ТаблицаФункций = ПолучитьКонтекст().ОписаниеФункций;
	ИмяПредка = ПолучитьИмяПредка(ИмяОбработкиПотомка);
	Если ИмяПредка = Неопределено Тогда
		Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
			СтрШаблон(НСтр(
				"ru='Отсутствует предшествующий %1 обработчик для функции %2 и типа %3.'"),
				ИмяОбработкиПотомка,
				ИмяФункции,
				ИмяТипа1С))
	КонецЕсли;
	Если ОбработкаПоддерживаетФункцию(ИмяПредка, ИмяФункции, ИмяТипа1С) Тогда
		Возврат ВыполнитьФункциюОбработки(
			ИмяПредка, ИмяФункции, ИмяТипа1С, Контекст);
	КонецЕсли;
	// Не ожидается высокого дерева подчиненности обработок.
	Возврат ВыполнитьФункциюКонвертацииПредка(
		ИмяПредка, ИмяФункции, ИмяТипа1С, Контекст);
КонецФункции

// Возвращает строковое представление целевого пространства имен.
//
Функция ПолучитьПространствоИмен() Экспорт
	Возврат "http://www.1c.ru/CPM/SCM/IntermediateFormat";
КонецФункции

// Возвращает фабрику для создания объектов простанства имен IntermediateFormat.
//
Функция ПолучитьФабрикуXDTO() Экспорт
	Контекст = ПолучитьКонтекст();
	Если НЕ Контекст.Свойство("ФабрикаXDTO") Тогда
		// Используем глобальную фабрику конфигурации.
		Контекст.Вставить("ФабрикаXDTO", 
			СоздатьФабрикуSCMIntermediateFormat());
	КонецЕсли;
	Возврат Контекст.ФабрикаXDTO;
КонецФункции

// Возвращает текст .xsd файла с описанием формата.
//
Функция ПолучитьТекстSCMIntermediateFormat() Экспорт
	ОписаниеПравил = РегистрыСведений.ПравилаКонвертацииXSD.ПолучитьПоследнююРедакцию(
		Справочники.ПравилаКонвертацииXSD.Из1СВОбъектыSCM);
	Если ОписаниеПравил <> Неопределено Тогда
		Возврат ОписаниеПравил.ТекстПравил;
	КонецЕсли;
	Возврат 
		Обработки.КонвертерSCMIntermediateFormatУХ.ПолучитьТекстSCMIntermediateFormatИзМакета();
КонецФункции

// Возвращает фабрику XDTO для схемы SCMIntermediateFormat
//
Функция СоздатьФабрикуSCMIntermediateFormat() Экспорт
	НовыйНаборСхемXML = Новый НаборСхемXML;
	НовыйНаборСхемXML.Добавить(ПолучитьСхемуXML(
		ПолучитьТекстSCMIntermediateFormat()));
	НоваяФабрикаXDTO = Новый ФабрикаXDTO(НовыйНаборСхемXML);
	Возврат НоваяФабрикаXDTO;
КонецФункции

// Возвращает коллекцию корневых свойств пакета SCMIntermediateFormat.
// 
// Возвращаемое значение:
//   -  КоллекцияСвойствXDTO.
//
Функция ПолучитьКорневыеОбъекты() Экспорт
	Контекст = ПолучитьКонтекст();
	Если НЕ Контекст.Свойство("КорневыеОбъекты") Тогда
		Контекст.Вставить(
			"КорневыеОбъекты",
			ИнтеграцияЦУЗсЭТПКлиентСерверУХ.ПолучитьКорневыеОбъектыПространстваИмен(
				ПолучитьФабрикуXDTO(),
				ПолучитьПространствоИмен()));
	КонецЕсли;
	Возврат Контекст.КорневыеОбъекты;
КонецФункции

// Возвращает тип XDTO по его имени в целевом пространстве имен.
//
// Параметры:
//  ИмяТипаXDTO - Строка - 
// 
// Возвращаемое значение:
//   - ТипОбъектаXDTO | ТипЗначенияXDTO - если тип найден.
//	 - Неопределено - если тип не найден.
//
Функция ПолучитьТипXDTO(ИмяТипаXDTO) Экспорт
	Возврат ПолучитьФабрикуXDTO().Тип(ПолучитьПространствоИмен(), ИмяТипаXDTO);
КонецФункции

// Читает схему XML из строки.
Функция ПолучитьСхемуXML(СтрокаXML) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	НовыйПостроительDOM = Новый ПостроительDOM;
	НовыйДокументDOM = НовыйПостроительDOM.Прочитать(ЧтениеXML);
	НовыйПостроительСхемыXML = Новый ПостроительСхемXML;
	Возврат НовыйПостроительСхемыXML.СоздатьСхемуXML(НовыйДокументDOM);
КонецФункции

// Удаляем лишние пробельные символы.
//
Функция ПодготовитьWhiteSpaceCollapse(Текст) Экспорт
	Если ПустаяСтрока(Текст) Тогда
		Возврат "";
	КонецЕсли;
	
	ВремТекст = СокрЛП(Текст);
	
	ВремТекст = СтрЗаменить(ВремТекст, Символы.ПС, " ");
	ВремТекст = СтрЗаменить(ВремТекст, Символы.ВК, " ");
	ВремТекст = СтрЗаменить(ВремТекст, Символы.Таб, " ");
	ВремТекст = СтрЗаменить(ВремТекст, Символы.ВТаб, " ");
	ВремТекст = СтрЗаменить(ВремТекст, Символы.ПФ, " ");
	ВремТекст = СтрЗаменить(ВремТекст, Символы.НПП, " ");
	
	ВремТекст = УбратьПовторяющиесяСимволы(ВремТекст, " ");
	
	Возврат ВремТекст;
КонецФункции


#КонецОбласти


#Область НеЭкспортныеФункции


// Возвращает массив с именами обработок начинающихся
// на "КонвертерSCMIntermediateFormatУХ".
//
Функция ПолучитьМассивИменОбработокКонвертации()
	мОбработок = Новый Массив;
	Префикс = "КонвертерSCMIntermediateFormatУХ";
	ДлинаПрефикса = СтрДлина(Префикс);
	Для Каждого МетаданныеОбработки Из Метаданные.Обработки Цикл
		Имя = МетаданныеОбработки.Имя;
		Если СтрДлина(Имя) > ДлинаПрефикса
				И Лев(Имя, ДлинаПрефикса) = Префикс Тогда
			мОбработок.Добавить(Имя);
		КонецЕсли;
	КонецЦикла;
	Возврат мОбработок;
КонецФункции

Функция ДобавитьОписаниеОбработокВКонтекст(Контекст)
	Результат = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(Контекст);
	Результат.Вставить(
		"ОписаниеФункций",
		ПолучитьОписаниеФункцийКонвертации(
			ПолучитьМассивИменОбработокКонвертации()));
	Возврат Результат;
КонецФункции

// Если получилось создать обработку по имени и вызвать ее экспортную функцию
// ПолучитьОписаниеКонвертера(), то возвращает структуру с полями:
//	- ИмяОбработки - имя обработки, аргумент данной функции;
//	- ОписаниеКонвертера - результат вызова функции ПолучитьОписаниеКонвертера.
// Иначе возвращает Неопределено.
//
Функция ПолучитьОписаниеОбработки(ИмяОбработки)
	Попытка
		ОбработкаМенеджер = ПолучитьМенеджерОбработки(ИмяОбработки);
		ОбработкаОбъект = ОбработкаМенеджер.Создать();
		ОписаниеКонвертера = ОбработкаОбъект.ПолучитьОписаниеКонвертера();
		Результат = Новый Структура;
		Результат.Вставить("ИмяОбработки", ИмяОбработки);
		Результат.Вставить("ОписаниеКонвертера", ОписаниеКонвертера);
		Возврат Результат;
	Исключение
	КонецПопытки;
	Возврат Неопределено;
КонецФункции

Функция ПолучитьКонтекст()
	Если КонтекстОбработокГлобальнаяПеременная = Неопределено Тогда
		КонтекстОбработокГлобальнаяПеременная = 
			ДобавитьОписаниеОбработокВКонтекст(Новый Структура);
	КонецЕсли;
	Возврат КонтекстОбработокГлобальнаяПеременная;
КонецФункции

// Ищет объект в массиве с максимальным значением поля ИмяПоля.
//
// Параметры:
//  МассивОбъектов - Массив - содержит объекты к которым применимя
//							  операция взятия значения: 
//							  Объект[ИмяПоля].
//  ИмяПоля - Строка - имя реквизита, которе есть у всех объектов
//					   в массиве, и имеет тип Число.
// 
// Возвращаемое значение:
//   - Число - индекс максимального элемента. Если не найден, то
//			   возвращает -1.
//
Функция НайтиИндексМаксимумаВОднородномМассиве(МассивОбъектов, ИмяПоля)
	ИндексМаксЗнач = -1;
	МаксИндексМассива = МассивОбъектов.Количество() - 1;
	Если МаксИндексМассива >= 0 Тогда
		ИндексМаксЗнач = 0;
		МаксЗнач = МассивОбъектов[ИндексМаксЗнач][ИмяПоля];
		Для Индекс = 1 По МаксИндексМассива Цикл
			ТекЗнач = МассивОбъектов[Индекс][ИмяПоля];
			Если МаксЗнач < ТекЗнач Тогда
				МаксЗнач = ТекЗнач;
				ИндексМаксЗнач = Индекс;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат ИндексМаксЗнач;
КонецФункции

// Если не находит, то возвращает Неопределено.
Функция ПолучитьМенеджерОбработки(ИмяОбработки)
	Обработка = Неопределено;
	Попытка
		Обработка = Обработки[ИмяОбработки];
	Исключение
		// Игнорируем
	КонецПопытки;
	Возврат Обработка;
КонецФункции

Функция ВыполнитьФункциюОбработки(ИмяОбработки, ИмяФункции, ИмяТипа1С, Контекст)
	ОбработкаМенеджер = ПолучитьМенеджерОбработки(ИмяОбработки);
	Если ОбработкаМенеджер = Неопределено Тогда
		Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
			СтрШаблон(
				НСтр("ru='Отсутствует обработчик для функции %1 и типа %2.'"),
				ИмяФункции,
				ИмяТипа1С));
	КонецЕсли;
	ОбработкаОбъект = ОбработкаМенеджер.Создать();
	ОбработкаОбъект.УстановитьБазовуюОбработку(ЭтотОбъект);
	Возврат ОбработкаОбъект.ВыполнитьФункциюКонвертации(
		ИмяФункции, ИмяТипа1С, Контекст);
КонецФункции

Функция УбратьПовторяющиесяСимволы(Текст, СимволДляПроверки)
	ДваСимволаДляПоиска = СимволДляПроверки + СимволДляПроверки;
	
	ВремТекст = СокрЛП(Текст);
	ДлиннаИсходная = СтрДлина(ВремТекст);
	ВремТекст = СтрЗаменить(ВремТекст, ДваСимволаДляПоиска, СимволДляПроверки);
	
	Пока Истина Цикл
		Длинна = СтрДлина(ВремТекст);
		Если ДлиннаИсходная = Длинна Тогда
			Возврат ВремТекст;
		КонецЕсли;
		ДлиннаИсходная = Длинна;
		ВремТекст = СтрЗаменить(ВремТекст, ДваСимволаДляПоиска, СимволДляПроверки);
	КонецЦикла;
	
	Возврат ВремТекст;
КонецФункции


#КонецОбласти


#Область НеЭкспортныеРаботаСОписаниемФункцийКонвертации


// Ищет среди описаний функций конвертации подходящую по имени
// и типу. Если не находит, то возвращает Неопределено.
// Если находит, то возвращает имя обработки.
//
Функция ПолучитьКонечнуюФункциюКонвертации(ОписаниеФункций,
										   ИмяФункции,
										   ИмяТипа1С)
	мСтрок = ОписаниеФункций.НайтиСтроки(Новый Структура(
		"ИмяФункции, ИмяТипа1С",
		 ИмяФункции, ИмяТипа1С));
	Если мСтрок.Количество() = 0 Тогда
		Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
				СтрШаблон(НСтр("ru='Не найдена функция ""%1"" конвертации типа %2.'"),
					ИмяФункции, ИмяТипа1С));
	КонецЕсли;
	Если мСтрок.Количество() > 1 Тогда
		Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
				СтрШаблон(НСтр(
					"ru='Конфликт обработчиков функции ""%1"" конвертации типа %2. Обработки: %3'"),
					ИмяФункции,
					ИмяТипа1С,
					Символы.ПС + СтрСоединить(ПолучитьМассивИменОбработок(мСтрок), ",")));
	КонецЕсли;
	Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(
			мСтрок[0]);
КонецФункции

// Возвращает пустую таблицу значений с колонками:
//	- ИмяФункции		- Строка - имя функции конвертации.
//	- ИмяТипа1С			- Строка - имя типа основного аргумента функции.
//	- ИмяОбработки		- Строка - имя обработки конфигурации,
//							которая обрабатывает данную функцию.
//	- ИмяПредка			- Строка - имя обработки, функциональность
//							которой перекрывается данной.
//	- ОбъектОбработки	- ОбработкаОбъект - обработка для вызова функций.
//
Функция СоздатьПустуюТЗОписанияФункций()
	ТЗ = Новый ТаблицаЗначений;
	ТЗ.Колонки.Добавить("ИмяТипа1С", Новый ОписаниеТипов("Строка"));
	ТЗ.Колонки.Добавить("ИмяФункции", Новый ОписаниеТипов("Строка"));
	ТЗ.Колонки.Добавить("ИмяОбработки", Новый ОписаниеТипов("Строка"));
	ТЗ.Колонки.Добавить("ИмяПредка", Новый ОписаниеТипов("Строка"));
	// Чем меньше, тем раньше объявлен, и может быть перекрыт последователями.
	// Данная обработка не будет входить в таблицу, т.к. не определяет
	// функции конвертации. Это важно для корректной работы функции
	// ВыполнитьФункциюКонвертации().
	ТЗ.Колонки.Добавить("Приоритет", Новый ОписаниеТипов("Число"));
	ТЗ.Индексы.Добавить("ИмяТипа1С, ИмяФункции");
	ТЗ.Индексы.Добавить("ИмяПредка");
	Возврат ТЗ;
КонецФункции

Функция ЗаполнитьОписаниеФункцийКонвертации(мОбработок)
	ТЗ = СоздатьПустуюТЗОписанияФункций();
	Для Каждого ИмяОбработки Из мОбработок Цикл
		ОписаниеОбработки = ПолучитьОписаниеОбработки(ИмяОбработки);
		Если ОписаниеОбработки <> Неопределено Тогда
			ДобавитьОписаниеФункцийОбработкиКонвертации(ТЗ, ОписаниеОбработки);
		КонецЕсли;
	КонецЦикла;
	Возврат ТЗ;
КонецФункции

Процедура ДобавитьОписаниеФункцийОбработкиКонвертации(ТЗОписанияФункций,
													   ОписаниеОбработки)
	ОписаниеКонвертера = ОписаниеОбработки.ОписаниеКонвертера;
	ИмяОбработки = ОписаниеОбработки.ИмяОбработки;
	ИмяПредка = ОписаниеКонвертера.РасширяетКонвертер;
	СоответвиеФункций = ОписаниеКонвертера.СоответвиеФункцийКонвертации;
	Для Каждого КлючЗначение Из СоответвиеФункций Цикл
		ИмяТипа1С = КлючЗначение.Ключ;
		мИменФункций = КлючЗначение.Значение;
		Для Каждого ИмяФункции Из мИменФункций Цикл
			СтрокаОписанияФункций = ТЗОписанияФункций.Добавить();
			СтрокаОписанияФункций.ИмяТипа1С = ИмяТипа1С;
			СтрокаОписанияФункций.ИмяФункции = ИмяФункции;
			СтрокаОписанияФункций.ИмяОбработки = ИмяОбработки;
			СтрокаОписанияФункций.ИмяПредка = ИмяПредка;
			// В дальнейшем расставим приоритеты
			СтрокаОписанияФункций.Приоритет = 0;
		КонецЦикла
	КонецЦикла;
КонецПроцедуры

Функция РасставитьПриоритетыФункцийКонвертации(ТЗ)
	РасставитьПриоритетыФункцийКонвертацииДляУровня(
		ТЗ,
		0,
		"КонвертерSCMIntermediateFormatУХ");
	Возврат ТЗ;
КонецФункции

// Устновить указанный приоритет для строк функций конвертации
// с указанным родителем.
// Делаем рекурсивно т.к. не ожидается, что обработок будет
// больше 1000, и глубина не превысит log2(1000) < 10.
//
// Параметры:
//  ТЗ - ТаблицаЗначений - см. СоздатьТЗОписанияФункций().
//  ТекПриоритет - Число - для установки в колонке "Приоритет".
//  ИмяРодителя - Строка - имя обработки для поиска в колонке "ИмяПредка".
// 
Процедура РасставитьПриоритетыФункцийКонвертацииДляУровня(
												ТЗ, 
												Приоритет, 
												ИмяРодителя)
	 ИменаОбработанных = Новый Соответствие;
	 мСтрокиПотомки = ТЗ.НайтиСтроки(Новый Структура(
	 	"ИмяПредка",
	 	ИмяРодителя));
	Для Каждого СтрокаТЗ Из мСтрокиПотомки Цикл
		ИмяПотомка = СтрокаТЗ.ИмяОбработки;
		Если ИменаОбработанных[ИмяПотомка] = Неопределено Тогда
			ИменаОбработанных[ИмяПотомка] = Истина;
			СтрокаТЗ.Приоритет = Приоритет;
		КонецЕсли;
	КонецЦикла;
	// Устанавливаем приоритет+1 для потомков потомков.
	Для Каждого КлючЗначение Из ИменаОбработанных Цикл
		РасставитьПриоритетыФункцийКонвертацииДляУровня(
			ТЗ,
			Приоритет+1,
			КлючЗначение.Ключ);
	КонецЦикла;
 КонецПроцедуры

// Возвращает описание функций конвертации.
// Это описание используется в функции
// ПолучитьКонечнуюФункциюКонвертации(ОписаниеФункций...).
// Возвращает таблицу значений (колонки см. СоздатьТЗОписанияФункций).
//
Функция ПолучитьОписаниеФункцийКонвертации(мОбработок)
	ТЗ = ЗаполнитьОписаниеФункцийКонвертации(мОбработок);
	Возврат РасставитьПриоритетыФункцийКонвертации(ТЗ);
КонецФункции

Функция ПолучитьМассивИменОбработок(мСтрокТаблицы)
	мИмен = Новый Массив;
	Для Каждого СтрокаТЗ Из мСтрокТаблицы Цикл
		мИмен.Добавить(СтрокаТЗ.ИмяОбработки);
	КонецЦикла;
	Возврат мИмен;
КонецФункции

// Ищет наиболее подходящую функцию конвертации.
//
// Параметры:
//  ТЗ - ТаблицаЗначений - см. СоздатьТЗОписанияФункций().
//  ИмяФункции - Строка - имя функции конвертации.
//  ИмяТипа1С - Строка - имя типа объекта для конвертации.
// 
// Возвращаемое значение:
//   - Строка - имя обработки у которой можно вызвать
//		функцию ВыполнитьФункциюКонвертации для указанных
//		имени функции и имени типа.
//	 - Неопределено - если такой функции нет.
//
Функция НайтиОбработкуФункцииДляТипа(ИмяФункции, ИмяТипа1С)
	ТЗ = ПолучитьКонтекст().ОписаниеФункций;
	мСтрок = ТЗ.НайтиСтроки(Новый Структура(
		"ИмяТипа1С, ИмяФункции", 
		ИмяТипа1С, ИмяФункции));
	Индекс = НайтиИндексМаксимумаВОднородномМассиве(
		мСтрок, "Приоритет");
	Если Индекс >= 0 Тогда
		Возврат мСтрок[Индекс].ИмяОбработки;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ПолучитьИмяПредка(ИмяОбработкиПотомка)
	ТЗ = ПолучитьКонтекст().ОписаниеФункций;
	СтрокаОписанияПотомка = ТЗ.Найти(ИмяОбработкиПотомка, "ИмяОбработки");
	Если СтрокаОписанияПотомка <> Неопределено Тогда
		Возврат СтрокаОписанияПотомка.ИмяПредка;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ОбработкаПоддерживаетФункцию(ИмяОбработки, ИмяФункции, ИмяТипа1С)
	ТЗ = ПолучитьКонтекст().ОписаниеФункций;
	мСтрок = ТЗ.НайтиСтроки(Новый Структура(
		"ИмяОбработки, ИмяТипа1С, ИмяФункции", 
		ИмяОбработки, ИмяТипа1С, ИмяФункции));
	Возврат мСтрок.Количество() > 0;
КонецФункции


#КонецОбласти


#КонецЕсли