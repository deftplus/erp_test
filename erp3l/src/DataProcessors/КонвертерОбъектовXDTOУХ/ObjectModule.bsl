#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда


// Структура с произвольными ключами.
// Не предназначена для непосредственного чтения или записи.
Перем КонтекстОбработкиГлобальнаяПеременная;


#Область ВнешниеФункцииПодготовкиКРаботе


// Очищает все реквизиты и контекст обработки.
//
Процедура ИнициализироватьОбработку() Экспорт
	ВерсияПравил = "";
	ИмяКонфигурации1С = "";
	ВерсияКонфигурации1С = "0.0.0";
	ПоследнийВыделенныйКлючПравилРеквизитов = 0;
	Устарели.Очистить();
	ЭтотОбъект.ПространстваИменXSD.Очистить();
	ЭтотОбъект.Объекты1СВXDTO.Очистить();
	ЭтотОбъект.Значения1СВXDTO.Очистить();
	ЭтотОбъект.ПравилаПреобразованияРеквизитов1СВXDTO.Очистить();
	ЭтотОбъект.Макросы.Очистить();
	ОчиститьМетаИнформациюОбXSD();
	ОчиститьКонтекстОбработки();
КонецПроцедуры

// Получить текстовое представление правил, записанных в обработке.
//
Функция ВТекст() Экспорт
	СтруктураДанных = ПреобразоватьВСтруктуруДанных();
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, СтруктураДанных);
	Результат = ЗаписьXML.Закрыть();
	Возврат Результат;
КонецФункции

// Заполнить из текстового описания правила преобразования.
//
Процедура ПрочитатьИзТекста(Текст) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(Текст);
	СтруктураДанных = СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
	ПрочитатьИзСтруктурыДанных(СтруктураДанных);
	ЗаполнитьМетаданныеXSD();
КонецПроцедуры


#КонецОбласти


#Область ВнешниеФункцииКонвертации


// Возвращает фабрику XDTO для зарегистрированных пространств имен.
// Значение кэшируется, и повторно не пересоздается до следующей
// инициализации обработки.
//
Функция ПолучитьФабрикуXDTO() Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции("ПолучитьФабрикуXDTO");
	Фабрика = ПолучитьЗначениеВКонтексте("ФабрикаXDTO");
	Если Фабрика = Неопределено Тогда
		Фабрика = СоответствиеПространствИменXSDВФабрикуXDTO();
		УстановитьЗначениеВКонтексте("ФабрикаXDTO", Фабрика);
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Фабрика;
КонецФункции

// Преобразовывает объект 1С в объект XDTO и затем на основании
// последнего создает текст XML.
//
// Параметры:
//  Объект1С - Произвольный - значение или ссылка 1С, которую нужно
//		сконвертировать в объект XDTO.
//	Тип1С - Тип | Неопределено - тип 1С для поиска правил конвертации.
//		Если передано Неопределено (по умолчанию), то тип 1С
//			определяется из аргумента Объект1С.
//		Если передан типа 1С, тогда тип аргумента Объект1С
//			игнорируется, и вместо действительного объекта в Объект1С
//			можно передать структуру с полями эмулирующими объект
//			нужного типа.
//  ПсевдонимИлиТипXSD - Строка | ТипXDTO - имя типа XSD, либо псевдоним
//		имени типа в который нужно преобразовать.
//		Если не указано, то ищет первое попавшееся правило
//		преобразования указанного типа. Если правил найдено больше
//		одного, то возвращает Неопределено.
//	ДопПараметры - Структура | Неопределено - структура описывающая
//		дополнительные параметры конвертации объекта. Будет использована
//		если в правиле объекта установлен флаг "ДопПараметры".
//
// Возвращаемое значение:
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка()
//			- возникла ошибка.
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех()
//			- преобразование выполнено, Результат - Строка
//				с описанием объекта XDTO в формате XML.
//
Функция ПреобразоватьПоУмолчаниюОбъект1СВТекстXML(Объект1С,
												Тип1С=Неопределено,
												ПсевдонимИлиТипXSD="",
												ДопПараметры=Неопределено) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПреобразоватьПоУмолчаниюОбъект1СВТекстXML",
		АргументыВМассив4(Объект1С, Тип1С, ПсевдонимИлиТипXSD, ДопПараметры));
	Если ТипЗнч(ПсевдонимИлиТипXSD) = Тип("Строка") Тогда
		ПсевдонимТипаXSD = ПсевдонимИлиТипXSD;
	Иначе
		ПсевдонимТипаXSD = ПолучитьПсевдонимТипаXSD(ПсевдонимИлиТипXSD);
	КонецЕсли;
	УпакованныйОбъектXDTO = ПреобразоватьПоУмолчаниюОбъект1СВОбъектXDTO(
		Объект1С, Тип1С, ПсевдонимИлиТипXSD, ДопПараметры);
	Если УпакованныйОбъектXDTO.ЕстьОшибка Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат УпакованныйОбъектXDTO;
	КонецЕсли;
	ОбъектXDTO = УпакованныйОбъектXDTO.Результат;
	Если ТипЗнч(ОбъектXDTO) = Тип("ОбъектXDTO") Тогда
		ЛокальноеИмяXDTO = ПолучитьЛокальноеИмяТипаОбъектаXDTO(ОбъектXDTO);
		Если ПустаяСтрока(ЛокальноеИмяXDTO) Тогда
			ЛокальноеИмяXDTO = 
				УдалитьПрефиксПакетаИзПсевдонимаТипаXSD(ПсевдонимТипаXSD);
		КонецЕсли;
		СтрокаXML = ОбъектXDTOВСтрокуXML(ОбъектXDTO, ЛокальноеИмяXDTO);
		ОтладкаПриОкончанииФункции(КонтекстОтладки);	
		Возврат СтрокаXML;
	КонецЕсли;
	// примитивное значение
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Строка(ОбъектXDTO));
КонецФункции

// Возвращает XML-представление XDTO-объекта.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - объект, для которого требуется сформировать
//			XML-представление.
//  ЛокальноеИмя - Строка - имя корневого свойства основного пакета XSD.
//			Если у типа объекта XDTO есть имя, то можно не передавать.
//
// Возвращаемое значение:
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка()
//			- возникла ошибка.
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех()
//			- преобразование выполнено, Результат - Строка
//				XML-представление XDTO-объекта.
//
Функция ОбъектXDTOВСтрокуXML(ОбъектXDTO, ЛокальноеИмя) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ОбъектXDTOВСтрокуXML", АргументыВМассив2(ОбъектXDTO, ЛокальноеИмя));
	Попытка
		ОбъектXDTO.Проверить();
		Фабрика = ПолучитьФабрикуXDTO();
		Запись = Новый ЗаписьXML();
		Запись.УстановитьСтроку();
		Фабрика.ЗаписатьXML(
			Запись, ОбъектXDTO, ЛокальноеИмя, , , НазначениеТипаXML.Явное);
		Текст = Запись.Закрыть();
	Исключение
		Инфо = ИнформацияОбОшибке();
		КонтекстОшибки = Новый Структура;
		КонтекстОшибки.Вставить("ОбъектXDTO", Строка(ОбъектXDTO));
		КонтекстОшибки.Вставить("ЛокальноеИмяТипа", ЛокальноеИмя);
		КонтекстОшибки.Вставить("Пояснение",
			НСтр("ru='Преобразование в XML объекта XDTO закончилось ошибкой!"));
		ТекстОшибки = ПолучитьСтрокуОписанияОшибкиИзИсключения(
			Инфо, КонтекстОшибки);
		ОтладкаЗафиксироватьИсключение(КонтекстОтладки, Инфо);
		Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(ТекстОшибки);
	КонецПопытки;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Текст);
КонецФункции

// Проверяет возможность преобразовать объект 1С в объект XDTO.
// Проверяется:
//	- наличие правил преобразования самого объекта 1С;
//	- наличие правил преобразования обязательных реквизитов объекта 1С.
//	- заполненность обязательных реквизитов объекта 1С.
//
// Параметры:
//  Объект1С - СправочникСсылка | ДокументСсылка - ссылка на объект 1С,
//		который нужно сконвертировать в объект XDTO.
//	Тип1С - Тип | Неопределено - тип 1С для поиска правил конвертации.
//		Если передано Неопределено (по умолчанию), то тип 1С
//			определяется из аргумента Объект1С.
//		Если передан типа 1С, тогда тип аргумента Объект1С
//			игнорируется, и вместо действительного объекта в Объект1С
//			можно передать структуру с полями эмулирующими объект
//			нужного типа.
//  ПсевдонимИлиТипXSD - Строка | ТипXDTO - имя типа XSD, либо сам тип
//		в который нужно преобразовать.
//		Если не указано, то ищет первое попавшееся правило
//		преобразования указанного значения. Если найдено
//		правил больше одного, возвращает Неопределено.
//  ИмяГруппы - Строка - имя группы правил, среди которых нужно
//		искать подходящее. Если пустая, то ищем среди всех правил.
//	ЕстьДопПараметры - Булево - если для правила требуются доп. параметры.
// 
// Возвращаемое значение:
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка()
//			- есть ошибки. В реквизите Ошибка текст ошибки. 
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех()
//			- ошибок нет. В реквизите Результат Истина.
//
Функция ПроверитьПравилаДляОбъекта1С(Объект1С,
									Тип1С=Неопределено, 
									ПсевдонимИлиТипXSD="",
									ИмяГруппы="",
									ДопПараметры=Ложь) Экспорт
	Если Тип1С = Неопределено Тогда
		ИмяТипа1С = Обработки.КонвертерОбъектовXDTOУХ.ПолучитьИмяТипа1С(
			Объект1С);
	Иначе
		ИмяТипа1С = Обработки.КонвертерОбъектовXDTOУХ.ПолучитьТипСтрокой(Тип1С);
	КонецЕсли;
	Если ТипЗнч(ПсевдонимИлиТипXSD) = Тип("Строка") Тогда
		ПсевдонимТипаXSD = ПсевдонимИлиТипXSD;
	Иначе
		ПсевдонимТипаXSD = ПолучитьПсевдонимТипаXSD(ПсевдонимИлиТипXSD);
	КонецЕсли;
	ПравилоПреобразованияОбъекта = НайтиПравилоПреобразованияОбъекта1СПоТипу1С(
		ИмяТипа1С, ПсевдонимТипаXSD, ИмяГруппы, (ДопПараметры <> Неопределено));
	ТекстКонтекстаОшибки = СтрШаблон(НСтр(
		"ru='Тип 1С с именем %1 в XDTO тип %2%3!'"),
		ИмяТипа1С,
		ПсевдонимТипаXSD,
		?(ПустаяСтрока(ИмяГруппы),
			"", 
			НСтр("ru=' для группы правил '") + ИмяГруппы));
	Если ПравилоПреобразованияОбъекта = Неопределено Тогда
		Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
			СтрШаблон(НСтр("ru='# Не найдено правило преобразования! %1'"),
			ТекстКонтекстаОшибки));
	КонецЕсли;
	Возврат ПроверитьПравилоПреобразованияОбъекта1С(
		ПравилоПреобразованияОбъекта, Объект1С, ДопПараметры);
КонецФункции

// Пытается преобразовать по правилу преобразования объекта 1С
// в объект XDTO. Вначале ищет среди правил преобразования значений,
// затем среди правил преобразования объектов.
//
// Параметры:
//  Объект1С - Произвольный - значение или ссылка 1С, которую нужно
//		сконвертировать в объект XDTO.
//	Тип1С - Тип | Неопределено - тип 1С для поиска правил конвертации.
//		Если передано Неопределено (по умолчанию), то тип 1С
//			определяется из аргумента Объект1С.
//		Если передан типа 1С, тогда тип аргумента Объект1С
//			игнорируется, и вместо действительного объекта в Объект1С
//			можно передать структуру с полями эмулирующими объект
//			нужного типа.
//  ПсевдонимИлиТипXSD - Строка | ТипXDTO - имя типа XSD, либо сам тип
//		в который нужно преобразовать.
//		Если не указано, то ищет первое попавшееся правило
//		преобразования указанного типа. Если правил найдено больше
//		одного, то возвращает Неопределено.
//	ДопПараметры - Структура | Неопределено - структура описывающая
//		дополнительные параметры конвертации объекта. Будет использована
//		если для найденного правила объекта установлен флаг "ДопПараметры".
//
// Возвращаемое значение:
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка()
//			- возникла ошибка.
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех()
//			- преобразование выполнено.
//
Функция ПреобразоватьПоУмолчаниюОбъект1СВОбъектXDTO(
											Объект1С,
											Тип1С=Неопределено,
											ПсевдонимИлиТипXSD="",
											ДопПараметры=Неопределено) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПреобразоватьПоУмолчаниюОбъект1СВОбъектXDTO",
		АргументыВМассив4(Объект1С, Тип1С, ПсевдонимИлиТипXSD, ДопПараметры));
	Если Тип1С = Неопределено Тогда
		Тип1С = ТипЗнч(Объект1С);
	КонецЕсли;
	УпакованРезультат = Объект1СВОбъектXDTO(
		Объект1С, Тип1С, ПсевдонимИлиТипXSD, Неопределено, ДопПараметры);
	Если НЕ УпакованРезультат.ЕстьОшибка
			И УпакованРезультат.Результат = Неопределено
			И (Обработки.КонвертерОбъектовXDTOУХ.ЭтоПримитивныйТип(Тип1С)
				ИЛИ Обработки.КонвертерОбъектовXDTOУХ.ЭтоПредопределенноеЗначение(
																Объект1С)) Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат ПредопределенноеЗначение1СВXDTO(
			Объект1С, ПсевдонимИлиТипXSD, Неопределено, ДопПараметры);
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);	
	Возврат УпакованРезультат;
КонецФункции

// Преобразует объект конфигурации 1С:УХ в объект XDTO.
//
// Параметры:
//  Объект1С - СправочникСсылка | ДокументСсылка - ссылка на объект 1С,
//		который нужно сконвертировать в объект XDTO.
//	Тип1С - Тип | Неопределено - тип 1С для поиска правил конвертации.
//		Если передано Неопределено (по умолчанию), то тип 1С
//			определяется из аргумента Объект1С.
//		Если передан типа 1С, тогда тип аргумента Объект1С
//			игнорируется, и вместо действительного объекта в Объект1С
//			можно передать структуру с полями эмулирующими объект
//			нужного типа.
//  ПсевдонимИлиТипXSD - Строка | ТипXDTO - имя типа XSD, либо сам тип в который
//		нужно преобразовать.
//		Если не указано, то ищет первое попавшееся правило
//		преобразования указанного значения. Если найдено
//		правил больше одного, возвращает Неопределено.
//  ИмяГруппы - Строка - имя группы правил, среди которых нужно
//		искать подходящее. Если пустая, то ищем среди всех правил.
//	ДопПараметры - Структура | Неопределено - структура описывающая
//		дополнительные параметры конвертации объекта. Будет использована
//		если для найденного правила объекта установлен флаг "ДопПараметры".
//
// Возвращаемое значение:
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка()
//			- возникла ошибка.
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех()
//			- преобразование выполнено. Значение с указанным
//			  типом XDTO содержится в реквизите "Результат".
//
Функция Объект1СВОбъектXDTO(Объект1С,
							Тип1С=Неопределено, 
							ПсевдонимИлиТипXSD="",
							ИмяГруппы="",
							ДопПараметры=Неопределено) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"Объект1СВОбъектXDTO",
		АргументыВМассив5(
			Объект1С, Тип1С, ПсевдонимИлиТипXSD, ИмяГруппы, ДопПараметры));
	Попытка
		Если Тип1С = Неопределено Тогда
			ИмяТипа1С = Обработки.КонвертерОбъектовXDTOУХ.ПолучитьИмяТипа1С(
				Объект1С);
		Иначе
			ИмяТипа1С = Обработки.КонвертерОбъектовXDTOУХ.ПолучитьТипСтрокой(
				Тип1С);
		КонецЕсли;
		Если ТипЗнч(ПсевдонимИлиТипXSD) = Тип("Строка") Тогда
			ПсевдонимТипаXSD = ПсевдонимИлиТипXSD;
		Иначе
			ПсевдонимТипаXSD = ПолучитьПсевдонимТипаXSD(ПсевдонимИлиТипXSD);
		КонецЕсли;
		ПравилоПреобразованияОбъекта =
			НайтиПравилоПреобразованияОбъекта1СПоТипу1С(
				ИмяТипа1С, ПсевдонимТипаXSD, ИмяГруппы, ЕстьДопПараметры(ДопПараметры));
		Если ПравилоПреобразованияОбъекта = Неопределено Тогда
			ОтладкаПриОкончанииФункции(КонтекстОтладки);
			Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(СтрШаблон(
				НСтр("ru='Не найдено правило преобразования объекта 1С типа %1 в XDTO тип %2!'"),
				ИмяТипа1С,
				ПсевдонимТипаXSD));
		КонецЕсли;
		Результат = ВыполнитьПравилоПреобразованияОбъекта1С(
			ПравилоПреобразованияОбъекта,
			Объект1С, 
			ДопПараметры);
	Исключение
		Инфо = ИнформацияОбОшибке();
		КонтекстОшибки = Новый Структура;
		КонтекстОшибки.Вставить("Объект1С", Строка(Объект1С));
		КонтекстОшибки.Вставить("ИмяТипа1С", Строка(ИмяТипа1С));
		КонтекстОшибки.Вставить("ЛокальноеИмяТипа", Строка(ПсевдонимТипаXSD));
		КонтекстОшибки.Вставить("ИмяГруппы", Строка(ИмяГруппы));
		КонтекстОшибки.Вставить("Пояснение",
			НСтр("ru='Не удалось преобразовать объект 1С!"));
		ТекстОшибки = ПолучитьСтрокуОписанияОшибкиИзИсключения(
			Инфо, КонтекстОшибки);
		ОтладкаЗафиксироватьИсключение(КонтекстОтладки, Инфо);
		Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(ТекстОшибки);
	КонецПопытки;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Результат);
КонецФункции

// Преобразует примитивное или предопределенное значение
// 1С в значение XDTO.
//
// Параметры:
//  Значение1С - Строка 
//				| Число 
//				| Булево
//				| ПеречислениеСсылка
//				| СправочникСсылка - примитивное или предопределенное
//									значение 1С для конвертации.
//  ПсевдонимИлиТипXSD - Строка | ТипXDTO - имя типа XSD, либо сам тип в который
//		нужно преобразовать.
//		Если не указано, то ищет первое попавшееся правило
//		преобразования указанного значения. Если найдено
//		правил больше одного, возвращает Неопределено.
//  ИмяГруппы - Строка - имя группы правил, среди которых нужно
//		искать подходящее. Если пустая, то ищем среди всех правил.
//	ДопПараметры - Структура | Неопределено - структура описывающая
//		дополнительные параметры конвертации объекта. Будет использована
//		если для найденного правила объекта установлен флаг "ДопПараметры".
// 
// Возвращаемое значение:
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка()
//			- возникла ошибка. Описание в реквизите Ошибка.
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех()
//			- преобразование выполнено. Значение подходящее
//			  для записи в реквизит объекта XDTO с указанным
//			  типом содержится в реквизите Результат.
//
Функция ПредопределенноеЗначение1СВXDTO(Значение1С, 
										ПсевдонимИлиТипXSD="",
										ИмяГруппы="",
										ДопПараметры=Неопределено) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПредопределенноеЗначение1СВXDTO",
		АргументыВМассив4(Значение1С, ПсевдонимИлиТипXSD, ИмяГруппы, ДопПараметры));
	Попытка
		Если ТипЗнч(ПсевдонимИлиТипXSD) = Тип("Строка") Тогда
			ПсевдонимТипаXSD = ПсевдонимИлиТипXSD;
		Иначе
			ПсевдонимТипаXSD = ПолучитьПсевдонимТипаXSD(ПсевдонимИлиТипXSD);
		КонецЕсли;
		ПравилоПреобразованияЗначения = НайтиПравилоПреобразованияЗначения1С(
			Значение1С,
			ПсевдонимТипаXSD,
			ИмяГруппы,
			ЕстьДопПараметры(ДопПараметры));
		Если ПравилоПреобразованияЗначения = Неопределено Тогда
			ОтладкаПриОкончанииФункции(КонтекстОтладки);
			Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(СтрШаблон(
				НСтр("ru='Не найдено правило преобразования значения 1С %1 в XDTO тип %2!"),
				Значение1С,
				ПсевдонимТипаXSD));
		КонецЕсли;
		Результат = ВыполнитьПравилоПреобразованияЗначения1С(
			ПравилоПреобразованияЗначения, Значение1С, ДопПараметры);
	Исключение
		Инфо = ИнформацияОбОшибке();
		КонтекстОшибки = Новый Структура;
		КонтекстОшибки.Вставить("Значение1С", Строка(Значение1С));
		КонтекстОшибки.Вставить("ЛокальноеИмяТипа", Строка(ПсевдонимТипаXSD));
		КонтекстОшибки.Вставить("ИмяГруппы", Строка(ИмяГруппы));
		КонтекстОшибки.Вставить("Пояснение",
			НСтр("ru='Не удалось преобразовать значение 1С!"));
		ТекстОшибки = ПолучитьСтрокуОписанияОшибкиИзИсключения(
			Инфо, КонтекстОшибки);
		ОтладкаЗафиксироватьИсключение(КонтекстОтладки, Инфо);
		Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(ТекстОшибки);
	КонецПопытки;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);	
	Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Результат);
КонецФункции


#КонецОбласти


#Область ВнешниеФункцииРаботыСПравиламиПреобразованияОбъектов1СвXDTO


// Добавляет описание пространства имен.
//
// Параметры:
//  ИмяПространстваИмен - Строка - URI пространства имен.
//  Код - Строка - код, по которому можно ссылаться на пространство
//			имен в именах типов XDTO в описании правил. Может быть
//			пустым для одного пространства, тогда типы XDTO будут
//			приведены к этому пространству имен.
//  ТекстXSD - Строка - текст файла XSD, который описывает данное
//			пространство имен.
//
Процедура ДобавитьПространствоИменXSD(Код, ИмяПространстваИмен, ТекстXSD) Экспорт
	ИмяПространстваW3C =
		Обработки.КонвертерОбъектовXDTOУХ.ПолучитьИмяПространстваW3C();
	Если ПустаяСтрока(ИмяПространстваИмен)
			ИЛИ (ПустаяСтрока(ТекстXSD) 
				И (СокрЛП(ИмяПространстваИмен) <> ИмяПространстваW3C)) Тогда
		Возврат;
	КонецЕсли;
	СтрокаПространстваИмен = ЭтотОбъект.ПространстваИменXSD.Найти(Код, "Код");
	Если СтрокаПространстваИмен <> Неопределено
		И СтрокаПространстваИмен.ИмяПространстваИмен <> ИмяПространстваИмен Тогда
			ВызватьИсключение ПолучитьСтрокуОписанияОшибки(СтрШаблон(НСтр(
				"ru='Ошибка добавления пространства имен. Код %1 уже использован для %2.'"),
				Код,
				СтрокаПространстваИмен.ИмяПространстваИмен));
	Иначе
		СтрокаПространстваИмен = ЭтотОбъект.ПространстваИменXSD.Найти(
				ИмяПространстваИмен, "ИмяПространстваИмен");
		Если СтрокаПространстваИмен = Неопределено Тогда
			СтрокаПространстваИмен = ЭтотОбъект.ПространстваИменXSD.Добавить();
		КонецЕсли;
	КонецЕсли;
	СтрокаПространстваИмен.Код = Код;
	СтрокаПространстваИмен.ИмяПространстваИмен = ИмяПространстваИмен;
	СтрокаПространстваИмен.ТекстXSD = ТекстXSD;
	СтрокаПространстваИмен.ЭтоСтандартныйТип =
		(ИмяПространстваИмен = ИмяПространстваW3C);
КонецПроцедуры

// Добавляет правило преобразования объекта 1С в объект XDTO.
//
// Параметры:
//  ИмяГруппы		 - Строка - имя по которому можно однозначно
//			идентифицировать группу правил.
//  ИмяТипаИсточника - Строка - имя типа объекта 1С, например,
//			Документ.ПредложениеПоставщика.
//  ИмяТипаПриемника - Строка - имя типа XSD в который выполняется
//			преобразование. Имя типа может содержать префикс
//			пространства имен с ':' на конце. Если префикс не указан,
//			то подразумевается базовое простаноство имен. Соответствие
//			префиксов описано в свойстве "ОписаниеПреобразования"
//			правил преобразования реквизитов.
//  СпособПолучения	 - Строка - Определяет как трактовать параметр
//			 "НовоеЗначение". Возможные варианты:
//				- "Значение" - примитивное значение 1С, которое однозначно
//						преобразуется в тип XSD.
//				- "XML" - текст XML, который можно прочитать как объект XDTO.
//				- "Функция" - текст функции, которая будет выполнена, чтобы
//						сформировать объект XDTO. В переменной Параметры
//						будет структура с полями:
//							- Обработка - объект данной обработки;
//							- ФабрикаXDTO - фабрика для указанного в правилах
//								перечня пространств имен;
//							- ПравилоПреобразования - текущее правило
//								преобразования объекта.
//							- Объект1С - ссылка на объект 1С, для которого
//								выполняется преобразование в XDTO.
//						Результат работы нужно положить в переменную Результат.
//						Если возникла ошибка, то ее описание можно положить
//						в переменную Ошибка.
//						См. ВыполнитьАлгоритм().
//				- "МассивПравил" - для данного правила будет создан набор правил
//						преобразования реквизитов объекта источника в реквизиты
//						объекта приемника.
//						См. функцию СоздатьПравилоПреобразованияРеквизитаОбъекта1СВXDTO,
//						ДобавитьПравилоПреобразованияРеквизитВРеквизит.
//	ЕстьДопПараметры - Булево - необходимо передать дополнительные параметры
//			для выполнения правила конвертации.
//  НовоеЗначение - Произвольное значение - значение, которое в зависимости
//			"СпособПолучения" трактуется по разному.
//	ФункцияПередЗаполнением - Строка - текст функции, которая будет заполнять
//			дополнительный контекст заполнения объекта XDTO. Используется в случае
//			когда СпособПолучения == "МассивПравил". Данная функция может добавить
//			поля в общий контекст заполнения реквизитов объекта. Затем их можно
//			использовать в функциях заполнения или преобразования отдельных реквизитов
//			объекта. Например, подготовить запросом доп. данные. Либо можно подменить
//			значения реквизитов контекста, (см. функцию 
//												СоздатьКонтекстПреобразованияРеквизита).
//			Например, можно заменить реквизит (Объект1С), который представляет значение
//			объекта 1С, из которого производим заполнение, на значение произвольной
//			структуры, с реквизитами подходящими по именам и типам.
//			Для выполянемой функции будет доступна переменная Параметры
//			в которой, будет структура с полями, представляющая контекст
//			заполнения объекта:
//				- Обработка - объект данной обработки;
//				- ФабрикаXDTO - фабрика для указанного в правилах перечня
//							пространств имен;
//				- ПравилоПреобразования - текущее правило преобразования объекта.
//				- Объект1С - ссылка на объект 1С, для которого
//							выполняется преобразование в XDTO.
//			Если в процессе работы функции возникла ошибка, ее описание нужно
//			положить в переменную Ошибка.
//			См. ВыполнитьАлгоритм().
//			
// Возвращаемое значение:
//   - ПравилоПреобразованияОбъекта
//
Функция ДобавитьПравилоПреобразованияОбъекта1СВXDTO(ИмяГруппы,
													ИмяТипаИсточника,
													ИмяТипаПриемника,
													СпособПолучения,
													ЕстьДопПараметры,
													НовоеЗначение) Экспорт
	НоваяСтрока = ЭтотОбъект.Объекты1СВXDTO.Добавить();
	НоваяСтрока.ИмяГруппы = ИмяГруппы;
	НоваяСтрока.ИмяТипаИсточника = ИмяТипаИсточника;
	НоваяСтрока.ИмяТипаПриемника = ИмяТипаПриемника;
	НоваяСтрока.СпособПолучения = СпособПолучения;
	НоваяСтрока.ЕстьДопПараметры = ЕстьДопПараметры;
	Если СпособПолучения = "XML"
			ИЛИ СпособПолучения = "Функция" Тогда
		НоваяСтрока.БольшаяСтрока = НовоеЗначение;
	ИначеЕсли СпособПолучения = "МассивПравил" Тогда
		НоваяСтрока.КлючПравилРеквизитов = 
			ПолучитьНовыйКлючПравилРеквизитов();
	Иначе
		НоваяСтрока.ПростоеЗначение = НовоеЗначение;
	КонецЕсли;
	Возврат НоваяСтрока;
КонецФункции

// Добавляет правило преобразования значения 1С в значение XDTO.
//
// Параметры:
//  ИмяГруппы - Строка - имя по которому можно однозначно идентифицировать
//			группу правил.
//  Значение1С - ПеречислениеСсылка | СправочникСсылка | ПланСчетовСсылка
//				| ПланВидовХарактепристикСсылка - предопределенное значение,
//			которое можно получить по имени.
//  ИмяТипаПриемника - Строка - имя типа XSD в который выполняется
//			преобразование. Имя типа может содержать префикс
//			пространства имен с ':' на конце. Если префикс не указан,
//			то подразумевается базовое простаноство имен. Соответствие
//			префиксов описано в свойстве "описания правил преобразования".
//  СпособПолучения - Строка - Определяет как трактовать параметр "НовоеЗначение".
//			Возможные варианты:
//				- "Значение" - примитивное значение 1С, которое однозначно
//						преобразуется в тип XSD.
//				- "XML" - текст XML, который можно прочитать как объект XDTO.
//				- "Функция" - текст функции, которая будет выполнена, чтобы
//						сформировать объект XDTO. В переменной Параметры
//						будет структура с полями:
//							- Обработка - объект данной обработки;
//							- ФабрикаXDTO - фабрика для указанного в правилах
//								перечня пространств имен;
//							- ПравилоПреобразования - текущее правило
//								преобразования объекта.
//							- Объект1С - ссылка на объект 1С, для которого
//								выполняется преобразование в XDTO.
//						Результат работы нужно положить в переменную Результат.
//						Если возникла ошибка, то ее описание можно положить
//						в переменную Ошибка.
//						См. ВыполнитьАлгоритм().
//	ЕстьДопПараметры - Булево - необходимо передать дополнительные параметры
//			для выполнения правила конвертации.
//  НовоеЗначение - Произвольное значение - значение, которое в зависимости
//			от аргумента "СпособПолучения" трактуется по разному.
// 
// Возвращаемое значение:
//   - ПравилоПреобразованияЗначения
//
Функция ДобавитьПравилоПреобразованияЗначения1СВXDTO(
											ИмяГруппы,
											Значение1С,
											ИмяТипаПриемника,
											СпособПолучения,
											ЕстьДопПараметры,
											НовоеЗначение) Экспорт
	ИмяЗначения = Обработки.КонвертерОбъектовXDTOУХ.ПолучитьИмяЗначения1С(
		Значение1С);
	Если ИмяЗначения <> Неопределено Тогда
		Правило = ЭтотОбъект.Значения1СВXDTO.Добавить();
		Правило.ИмяГруппы = ИмяГруппы;
		Правило.Значение1С = Значение1С;
		Правило.ИмяТипаИсточника = 
			Обработки.КонвертерОбъектовXDTOУХ.ПолучитьИмяТипа1С(Значение1С);
		Правило.ИмяЗначения = ИмяЗначения;
		Правило.ИмяТипаПриемника = ИмяТипаПриемника;
		Правило.СпособПолучения = СпособПолучения;
		Правило.ЕстьДопПараметры = ЕстьДопПараметры;
		Если СпособПолучения = "XML"
				ИЛИ СпособПолучения = "Функция" Тогда
			Правило.БольшаяСтрока = НовоеЗначение;
		Иначе
			Правило.ПростоеЗначение = НовоеЗначение;
		КонецЕсли;
		Возврат Правило;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Добавляет к указанному правилу преобразования объекта простое правило
// заполнения реквизита: взять из объекта 1С по имени и положить
// в реквизит объекта XDTO по имени.
// Не добавляет правило, если входящее правило преобразования объекта,
// не имеет способ заполнения "МассивПравил".
//
// Параметры:
//  РодительскоеПравилоОбъекта - ПравилоПреобразованияОбъекта - правило,
//		к котому нужно добавить правило преобразования реквизита.
//  ИмяРеквизита1С - Строка - имя реквизита объекта 1С.
//  ИмяРеквизитаXDTO - Строка - имя реквизита объекта XDTO.
// 
// Возвращаемое значение:
//   - ПреобразованияРеквизита
//
Функция ДобавитьПравилоПреобразованияРеквизитВРеквизит(
											РодительскоеПравилоОбъекта,
											ИмяРеквизита1С,
											ИмяРеквизитаXDTO) Экспорт
	Если РодительскоеПравилоОбъекта.СпособПолучения <> "МассивПравил" Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПравилоРеквизита =
		СоздатьПравилоПреобразованияРеквизитаОбъекта1СВXDTO(
			РодительскоеПравилоОбъекта);
	УстановитьПравилоПолученияДанныхРеквизита1С(
		ПравилоРеквизита, "Реквизит", ИмяРеквизита1С, Ложь);
	//УстановитьПравилоПреобразованияДанных1С();
	УстановитьПравилоЗаписиВОбъектXDTO(
		ПравилоРеквизита, "Реквизит", ИмяРеквизитаXDTO);
	Возврат ПравилоРеквизита;
КонецФункции

// Добавляет к указанному правилу преобразования объекта простое правило
// получения реквизита из функции: выполнить функцию в контексте объекта
// 1С и положить в реквизит объекта XDTO по имени.
// Не добавляет правило, если входящее правило преобразования объекта,
// не имеет способ заполнения "МассивПравил".
//
// Параметры:
//  РодительскоеПравилоОбъекта - ПравилоПреобразованияОбъекта - правило,
//		к котому нужно добавить правило преобразования реквизита.
//  ФункцияЧтенияЗначения - Строка - текст функции для чтения значения 1С.
//		См. ВыполнитьАлгоритм(). В переменной Параметры будет структура
//		с полями:
//			- Обработка - объект данной обработки конвертации;
//			- ФабрикаXDTO - фабрика для указанного в правилах
//					перечня пространств имен;
//			- Объект1С - объект из которого читаем реквизит;
//			- ПравилоПреобразованияОбъекта - текущее правило
//					преобразования объекта.
//		Результат работы нужно положить в переменную Результат.
//  ИмяРеквизитаXDTO - Строка - имя реквизита объекта XDTO, куда будет
//		записано значение.
// 
// Возвращаемое значение:
//   - ПреобразованияРеквизита
//
Функция ДобавитьПравилоПреобразованияИзФункцииВРеквизит(
											РодительскоеПравилоОбъекта,
											ФункцияЧтенияЗначения,
											ИмяРеквизитаXDTO) Экспорт
	Если РодительскоеПравилоОбъекта.СпособПолучения <> "МассивПравил" Тогда
		Возврат Неопределено;
	КонецЕсли;
	ПравилоРеквизита =
		СоздатьПравилоПреобразованияРеквизитаОбъекта1СВXDTO(
			РодительскоеПравилоОбъекта);
	УстановитьПравилоПолученияДанныхРеквизита1С(
		ПравилоРеквизита, "Функция", ФункцияЧтенияЗначения, Ложь);
	//УстановитьПравилоПреобразованияДанных1С();
	УстановитьПравилоЗаписиВОбъектXDTO(
		ПравилоРеквизита, "Реквизит", ИмяРеквизитаXDTO);
	Возврат ПравилоРеквизита;
КонецФункции

// Создает правило преобразования реквизита объекта 1С в реквизит объекта XDTO.
// Не добавляет правило, если входящее правило преобразования объекта,
// не имеет тип "МассивПравил".
//
// Параметры:
//  РодительскоеПравилоОбъекта - ПравилоПреобразованияОбъекта - правило
//		заполнения объекта, для которого нужно добавить правило заполнения
//		реквизитов.
// Возвращаемое значение:
//   - ПреобразованияРеквизита
//
Функция СоздатьПравилоПреобразованияРеквизитаОбъекта1СВXDTO(
											РодительскоеПравилоОбъекта) Экспорт
	Если РодительскоеПравилоОбъекта.СпособПолучения <> "МассивПравил" Тогда
		Возврат Неопределено;
	КонецЕсли;
	НоваяСтрока = ЭтотОбъект.ПравилаПреобразованияРеквизитов1СВXDTO.Добавить();
	НоваяСтрока.Ключ = РодительскоеПравилоОбъекта.КлючПравилРеквизитов;
	Возврат НоваяСтрока;
КонецФункции

// Устанавливает для текущего правила преобразования реквизита объекта 1С
//  правило получения данных из объекта 1С.
//
// Параметры:
//  ПравилоРеквизита - ПравилоЗаполненияРеквизита - правило заполнения.
//		Можно создать функцией СоздатьПравилоПреобразованияРеквизитаОбъекта1СВXDTO,
//		либо найти функцией ПолучитьРабочиеПравилаПреобразованияРеквизитовОбъекта1СВXDTO.
//  СпособПолучения - Строка - способ получения значения реквизита.
//		Возможные значения:
//			- "" - берется значение исходного объекта 1С.
//			- "Реквизит" - по имени реквизита в источнике через [].
//			- "Функция" - поле "ИсточникПолучения" содержит текст для выполнения.
//					См. ВыполнитьАлгоритм().
//					В переменной Параметры будет структура с полями:
//						- Обработка - объект данной обработки конвертации;
//						- ФабрикаXDTO - фабрика для указанного в правилах
//								перечня пространств имен;
//						- Объект1С - объект из которого читаем реквизит;
//						- ПравилоПреобразованияОбъекта - текущее правило
//								преобразования объекта.
//						- ПравилоРеквизита - текущее правило преобразования реквизита.
//					Результат работы нужно положить в переменную Результат.
//					Если возникла ошибка, то ее описание можно положить
//					в переменную Ошибка.
//  ИсточникПолучения - Строка - либо имя реквизита, либо текст функции.
//  ПолучаемСписок - Булево - результатом чтения данных из реквизита источника,
//			будет набор значений. Их обход будет осуществлен циклом Для Каждого.
//			Например, это может быть табличная часть, или выборка подчиненных
//			объектов справочника.
//
Процедура УстановитьПравилоПолученияДанныхРеквизита1С(ПравилоРеквизита,
													СпособПолучения,
													ИсточникПолучения,
													ПолучаемСписок) Экспорт
	ПравилоРеквизита.СпособПолучения = СпособПолучения;
	ПравилоРеквизита.ИсточникПолучения = ИсточникПолучения;
	ПравилоРеквизита.ПолучаемСписок = ПолучаемСписок;
КонецПроцедуры

// Устанавливает для текущего правила преобразования реквизита
//  объекта 1С правило преобразования значения данных полученных
//  из реквизита объекта 1С в тип XDTO.
//
// Параметры:
//  ПравилоРеквизита - ПравилоЗаполненияРеквизита - правило заполнения.
//			Можно создать функцией
//			СоздатьПравилоПреобразованияРеквизитаОбъекта1СВXDTO, либо найти
//			функцией ПолучитьРабочиеПравилаПреобразованияРеквизитовОбъекта1СВXDTO.
//  СпособПреобразования - Строка - способ преобразования входящего значения.
//			Возможные значения:
//				- "" - если преобразование не требуется, например, для простых типов.
//				- "ПредопределенноеЗначениеПоТипуXSD" - будет найдено правило
//					преобразования предопределенного значения 1С в примитивное
//					значение XSD (имя типа из аргумента ИмяТипаXSD).
//					В поле ОписаниеПреобразования можно записать имя группы правил
//					для поиска среди ограниченного множества правил.
//					Например, значение 1С "Перечисление.ВидыМестПоставки.Склад"
//					преобразовать в тип XSD "deliveryPlaceType" со значением "Store".
//				- "ПримитивноеЗначениеПоПравилу" - указанное в поле
//					"ОписаниеПреобразования" имя группы правил будет использоваться для
//					поиска правила преобразования входящего примитивного значения
//					1С в примитивное значение XDTO. Например, для правила с именем
//					"БулевоВplanType", будут два варианта правил с одним именем:
//						- Истина - преобразуем в "COMMODITY";
//						- Ложь - преобразуем в "INNOVATION".
//				- "ПоТипу" - поиск правила осуществляется по имени типа 1С и типу
//					поля приемника (имя типа из аргумента ИмяТипаXSD) среди правил
//					преобразования объектов.
//					В поле ОписаниеПреобразования можно записать имя группы правил
//					для поиска среди ограниченного множества правил.
//				- "ВСтроку" - преобразовать значение к строке функцией Строка().
//				- "ВЧисло" - преобразовать значение к числу функцией Число().
//				- "ВДату" - преобразовать значение к дате функцией Дата().
//				- "ВБулево" - преобразовать значение к булевому типу.
//				- "Функция" - поле "ОписаниеПреобразования" содержит текст для выполнения.
//					См. ВыполнитьАлгоритм().
//					В переменной Параметры будет структура с полями:
//						- Обработка - текущая обработка преобразования;
//						- ФабрикаXDTO - фабрика для указанного в правилах
//								перечня пространств имен;
//						- Объект1С - это объект из которого читаем реквизит;
//						- ЗначениеРеквизита - это входящее значение реквизита
//								объекта 1С для преобразования.
//						- ПравилоПреобразованияОбъекта - текущее правило
//								преобразования объекта.
//						- ПравилоРеквизита - текущее правило преобразования реквизита.
//					Результат работы нужно положить в переменную Результат.
//					Если возникла ошибка, то ее описание можно положить
//					в переменную Ошибка.
//  ИмяТипаXSD - Строка - имя типа XSD в который нужно выполнить преобразование.
//			Позволяет отбирать только те правила, которые преобразуют в данный тип.
//  ОписаниеПреобразования - Строка - описание правила преобразования.
//			Имеет разный смысл в зависимости от значения аргумента СпособПреобразования.
//  ЭтоСписок - Булево - результатом преобразования входящих данных будет массив
//			значений. В случае если входящие данные, это тоже набор значений,
//			то результирующий массив массивов будет свернут в плоский массив.
//			Дублирующиеся значения будут удалены. Подразумевается, что
//			принимающий реквизит XDTO может содержать несколько значений.
//
Процедура УстановитьПравилоПреобразованияДанных1С(ПравилоРеквизита,
												СпособПреобразования,
												ИмяТипаXSD,
												ОписаниеПреобразования,
												ЭтоСписок) Экспорт
	ПравилоРеквизита.СпособПреобразования = СпособПреобразования;
	ПравилоРеквизита.ИмяТипаXSD = ИмяТипаXSD;
	ПравилоРеквизита.ОписаниеПреобразования = ОписаниеПреобразования;
	ПравилоРеквизита.ПреобразованиеВСписок = ЭтоСписок;
КонецПроцедуры

// Устанавливает для текущего правила преобразования реквизита объекта 1С
//  правило записи значения в объект XDTO.
//
// Параметры:
//  ПравилоРеквизита - ПравилоЗаполненияРеквизита - правило заполнения.
//		Можно создать функцией СоздатьПравилоПреобразованияРеквизитаОбъекта1СВXDTO,
//		либо найти функцией ПолучитьРабочиеПравилаПреобразованияРеквизитовОбъекта1СВXDTO.
//  СпособЗаполнения - Строка - способ заполнения поля(ей) приемника.
//			Возможные значения:
//				- "Реквизит" - по имени реквизита в приемнике через [].
//				- "Функция" - поле "Приемник" содержит текст для выполнения.
//					См. ВыполнитьАлгоритм().
//					В переменной Параметры будет структура с полями:
//						- Обработка - объект данной обработки конвертации;
//						- ФабрикаXDTO - фабрика для указанного в правилах
//								перечня пространств имен;
//						- ОбъектXDTO - это объект в котором нужно установить
//								значение реквизита.
//						- ЗначениеРеквизита - входящее значение для
//								преобразования.
//						- ЗначениеДляЗаписи - это преобразованное значение для
//								записи в реквизит объекта XDTO.
//						- ПравилоПреобразованияОбъекта - текущее правило
//								преобразования объекта.
//						- ПравилоРеквизита - текущее правило преобразования
//								реквизита.
//					Результат работы нужно положить в переменную Результат.
//					Если возникла ошибка, то ее описание можно положить
//					в переменную Ошибка.
//  Приемник - Строка - либо имя реквизита, либо текст функции. 
//
Процедура УстановитьПравилоЗаписиВОбъектXDTO(ПравилоРеквизита,
											СпособЗаполнения,
											Приемник) Экспорт
	ПравилоРеквизита.СпособЗаполнения = СпособЗаполнения;
	ПравилоРеквизита.Приемник = Приемник;
КонецПроцедуры

// Добавляет отсутствующие правила преобразования реквизитов объекта XSD.
// Вставка производится в порядке свойств объекта XSD.
//
Процедура ОбновитьПравилаПреобразованияРеквизитовОбъектаXSD(
										ПравилоОбъектаXSD) Экспорт
	мСвойствОбъектаXSD =
		ПолучитьМассивСвойствОбъектаXSDДляСозданияПравилРеквизитов(
			ПравилоОбъектаXSD.ИмяТипаПриемника);
	ОбновитьПравилаПреобразованияРеквизитовОбъектаXSDДляМассиваСвойств(
		ПравилоОбъектаXSD, мСвойствОбъектаXSD);
КонецПроцедуры

// Заполнить таблицы с описаниями правил конвертации правилами-заглушками
//  для указанного типа XSD и связанных с его свойствами типов.
//
// Параметры:
//  ИмяТипаXSD - Строка - имя типа XSD с которого нужно начинать создание
//		правил.
//
Процедура ОбновитьПравилаОтТипаОбъектаXSD(ИмяТипаXSD) Экспорт
	БылиТипыXSD = Новый Соответствие;
	СоответствиеИменПравилам = ПолучитьСоответствиеИменОбъектовИЗначенийXDTO();
	СоответствиеИменМетаданным = ПолучитьСоответствиеИменМетаданнымXSD();
	ДобавитьОбновитьПравилаДляИменТиповXSDРекурсивно(
		СоответствиеИменПравилам,
		СоответствиеИменМетаданным,
		БылиТипыXSD,
		ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ИмяТипаXSD));
КонецПроцедуры

// Заполняет колонку ПорядковыйНомер в таблице
// ПравилаПреобразованияРеквизитов1СВXDTO из таблицы МетаСвойстваОбъектовXSD
// для всех правил заполнения объекта с заполненными полями ИмяТипаПриемника,
// КлючПравилРеквизитов и способом получения "МассивПравил".
//
Процедура ЗаполнитьПорядокПравилРеквизитовОбъектовXSD() Экспорт
	мСтрок = ЭтотОбъект.Объекты1СВXDTO.НайтиСтроки(
		Новый Структура("СпособПолучения", "МассивПравил"));
	Для Каждого ПравилоОбъектаXSD Из мСтрок Цикл
		ЗаполнитьПорядокПравилРеквизитовОбъектаXSD(ПравилоОбъектаXSD);
	КонецЦикла;
КонецПроцедуры

// Заполняет колонку ПорядковыйНомер в таблице
// ПравилаПреобразованияРеквизитов1СВXDTO из таблицы МетаСвойстваОбъектовXSD
// для указанного правила заполнения объекта. В правиле должны быть:
//		- заполнено поле ИмяТипаПриемника;
//		- СпособПолучения == "МассивПравил";
//		- КлючПравилРеквизитов >= 0.
//
// Параметры:
//  ПравилоОбъектаXSD - Объекты1СВXDTO.СтрокаТабличнойЧасти - строка
//		с описанием правила заполнения объекта.
//
Процедура ЗаполнитьПорядокПравилРеквизитовОбъектаXSD(ПравилоОбъектаXSD) Экспорт
	Если ПустаяСтрока(ПравилоОбъектаXSD.ИмяТипаПриемника)
			ИЛИ ПравилоОбъектаXSD.СпособПолучения <> "МассивПравил"
			ИЛИ ПравилоОбъектаXSD.КлючПравилРеквизитов >= 0 Тогда
		Возврат;
	КонецЕсли;
	мСвойствОбъектаXSD =
		ПолучитьМассивСвойствОбъектаXSDДляСозданияПравилРеквизитов(
			ПравилоОбъектаXSD.ИмяТипаПриемника);
	мПравилРеквизитов =
		ЭтотОбъект.ПравилаПреобразованияРеквизитов1СВXDTO.Выгрузить(
			Новый Структура("Ключ", ПравилоОбъектаXSD.КлючПравилРеквизитов));
	НовыйПорядокПравил =
		ПолучитьНовыйПорядокПравилПреобразованияРеквизитовОбъектаXSD(
			мПравилРеквизитов, мСвойствОбъектаXSD);
    УстановитьПорядковыйНомерПравилРеквизитовОбъектаXSD(
		мПравилРеквизитов, НовыйПорядокПравил);
КонецПроцедуры

#КонецОбласти


#Область ВнешниеФункцииРаботыСXDTO


// Создает пустой объект XDTO используя инициализированную
// из правил конвертации фабрику.
//
// Параметры:
//  ТипXSD - ТипXDTO - тип, объект которого нужно создать.
// 
// Возвращаемое значение:
//   - ОбъектXDTO - созданный объект.
//
Функция СоздатьОбъектXDTOПоТипу(ТипXSD) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"СоздатьОбъектXDTOПоТипу", АргументыВМассив1(ТипXSD));
	ФабрикаXDTO_ = ПолучитьФабрикуXDTO();
	ОбъектXDTO = ФабрикаXDTO_.Создать(ТипXSD);
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат ОбъектXDTO;
КонецФункции

// Возвращает тип свойства XDTO по объекту и имени его свойства.
Функция ТипСвойстваИзТипаОбъекта(ТипОбъекта, ИмяСвойства) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ТипСвойстваИзТипаОбъекта",
		АргументыВМассив2(ТипОбъекта, ИмяСвойства));
	Результат = ТипОбъекта.Свойства.Получить(ИмяСвойства).Тип;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

// Устанавливает значение свойства объекта XDTO.
// Для списка добавляет элемент в список.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - объект в котором заполняется свойство.
//  ИмяРеквизита - Строка - имя реквизита объекта XDTO.
//  Значение - Произвольный - значение свойства.
//
Процедура УстановитьСвойствоОбъектаXDTO(ОбъектXDTO,
										ИмяРеквизита,
										Значение) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"УстановитьСвойствоОбъектаXDTO",
		АргументыВМассив3(ОбъектXDTO, ИмяРеквизита, Значение));
	Если Значение <> Неопределено И НЕ ПустаяСтрока(Значение) Тогда
		Если ТипЗнч(ОбъектXDTO[ИмяРеквизита]) = Тип("СписокXDTO") Тогда
			ОбъектXDTO[ИмяРеквизита].Добавить(Значение);
		Иначе
			ОбъектXDTO[ИмяРеквизита] = Значение;
		КонецЕсли;
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
КонецПроцедуры

// Возвращает соотвествие пространств имен текстам XSD, их описывающим.
//
Функция ФабрикуXDTOВСоответствиеПространствИменXSD(Фабрика) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ФабрикуXDTOВСоответствиеПространствИменXSD",
		АргументыВМассив1(Фабрика));
	Результат = Новый Соответствие;
	мПространстваИмен = ПолучитьПространстваИменФабрики(Фабрика);
	СхемыXML = Фабрика.ЭкспортСхемыXML(мПространстваИмен);
	Для Каждого Схема Из СхемыXML Цикл
		Имя = Схема.ПространствоИмен;
		Схема.ОбновитьЭлементDOM();
		Текст = ОбъектDOMВСтрокуXML(Схема.ЭлементDOM);
		Результат.Вставить(Имя, Текст);
	КонецЦикла;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

// Возвращает массив строк, представляющих URI пространств имен,
// описанных в фабрике XDTO.
//
Функция ПолучитьПространстваИменФабрики(Фабрика,
									ИсключитьСтандартныйПакет=Истина) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьПространстваИменФабрики",
		АргументыВМассив2(Фабрика, ИсключитьСтандартныйПакет));
	ИмяПространстваW3C =
		Обработки.КонвертерОбъектовXDTOУХ.ПолучитьИмяПространстваW3C();
	мПространстваИмен = Новый Массив;
	Для Каждого Пакет Из Фабрика.Пакеты Цикл
		URIПространстваИмен = Пакет.URIПространстваИмен;
		Если НЕ ИсключитьСтандартныйПакет
			ИЛИ URIПространстваИмен <> ИмяПространстваW3C Тогда
			мПространстваИмен.Добавить(URIПространстваИмен);
		КонецЕсли;
	КонецЦикла;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат мПространстваИмен;
КонецФункции

Функция ОбъектDOMВСтрокуXML(ОбъектDOM) Экспорт
	ЗаписьДом = Новый ЗаписьDOM;
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ЗаписьДом.Записать(ОбъектDOM, ЗаписьXML);
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Читает схему XML из строки.
Функция ПолучитьСхемуXML(СтрокаXML) Экспорт
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьСхемуXML", АргументыВМассив1("СтрокаXML"));
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	НовыйПостроительDOM = Новый ПостроительDOM;
	НовыйДокументDOM = НовыйПостроительDOM.Прочитать(ЧтениеXML);
	НовыйПостроительСхемыXML = Новый ПостроительСхемXML;
	Результат = НовыйПостроительСхемыXML.СоздатьСхемуXML(НовыйДокументDOM);
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции


#КонецОбласти


#Область ВнешниеРаботаСМетаданнымиXSD


// Очищает вспомогательные таблицы с метаинформацией
// о типах XSD.
//
Процедура ОчиститьМетаИнформациюОбXSD()
	ЭтотОбъект.МетаТипыЗначенийXSD.Очистить();
	ЭтотОбъект.МетаПеречисленияЗначенийXSD.Очистить();
	ЭтотОбъект.МетаТипыОбъектовXSD.Очистить();
	ЭтотОбъект.МетаСвойстваОбъектовXSD.Очистить();
КонецПроцедуры

// В правилах метаданные не храняться, а читаются из описаний XSD,
// сохраненных в ТЧ ПространстваИменXSD.
//
Процедура ЗаполнитьМетаданныеXSD() Экспорт
	ОчиститьМетаИнформациюОбXSD();
	Фабрика = ПолучитьФабрикуXDTO();
	СоответствиеПакетов =
		ПолучитьСоответствиеПакетовПространствамИмен(Фабрика);
	Пакеты = Фабрика.Пакеты;
	Для Каждого ОписаниеПространстваИмен Из ПространстваИменXSD Цикл
		Пакет = СоответствиеПакетов[
			ОписаниеПространстваИмен.ИмяПространстваИмен];
		ДобавитьВМетаданныеИзПакетаXSD(Пакет, ОписаниеПространстваИмен);
	КонецЦикла;
КонецПроцедуры

// Добавляет описание метаданных из пакета XDTO.
//
// Параметры:
//  Пакет - ПакетXDTO - пакет из которого будет производится чтение.
//  ОписаниеПространстваИмен - ПространстваИменXSD.СтрокаТабличнойЧасти
//		- описание пространства имен.
//
Процедура ДобавитьВМетаданныеИзПакетаXSD(Пакет,
										ОписаниеПространстваИмен) Экспорт
	Префикс = ПолучитьПрефиксПространстваИмен(ОписаниеПространстваИмен);
	Для Каждого ТипТипаXSD Из Пакет Цикл
		ДобавитьВМетаданныеОписаниеТипаXSD(
			ТипТипаXSD,
			ДобавитьПрефиксКИмениТипаXSD(Префикс, ТипТипаXSD.Имя),
			ОписаниеПространстваИмен);
	КонецЦикла;
	ДобавитьВМетаданныеОписаниеКорневыхСвойствПакетаXDTO(
		Пакет, ОписаниеПространстваИмен);		
КонецПроцедуры

// Возвращает имя типа xsd с префиксом. При необходимости возвращает
//  описание связанного пространства имен.
//
// Параметры:
//  ТипXSD - ТипЗначенияXDTO | ТипОбъектаXDTO - тип xsd.
//  ОписаниеПространстваИмен - СтрокаТабличнойЧасти ПространстваИменXSD
//		- сюда, будет записано описание пространства имен.
// 
// Возвращаемое значение:
//  - Строка - имя типа с префиксом. Если пространство имен не найдено,
//		то возвращает просто имя типа.
//
Функция ПолучитьИмяСПрефиксомИзТипаXSD(
							ТипXSD,
							ОписаниеПространстваИмен=Неопределено) Экспорт
	Если ТипXSD = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ОписаниеПространстваИмен = ПолучитьОписаниеПространстваИменПоURI(
		ТипXSD.URIПространстваИмен);
	Префикс = ПолучитьПрефиксПространстваИмен(ОписаниеПространстваИмен);
	Возврат ДобавитьПрефиксКИмениТипаXSD(Префикс, ТипXSD.Имя);
КонецФункции

// Возвращает URI пространства имен в имени типа XDTO с префиксом.
//
// Параметры:
//  ИмяТипаXSD - Строка - имя типа с префиксом пространства имен.
//	Префикс - Строка - необязательнй. В него будет записан префикс.
//
// Возвращаемое значение:
//   - Строка - URI пространства имен.
//
Функция ПолучитьURIПространстваИменИзПсевдонимаТипа(ПсевдонимТипаXSD,
												Префикс=Неопределено) Экспорт
	Префикс = ПолучитьПрефиксПространстваИменИзИмениТипа(ПсевдонимТипаXSD);
	Строка_ = ПолучитьОписаниеПространстваИменПоПрефиксу(Префикс);
	Если Строка_ = Неопределено Тогда
		Возврат Обработки.КонвертерОбъектовXDTOУХ.ПолучитьИмяПространстваW3C();
	КонецЕсли;
	Возврат Строка_.ИмяПространстваИмен;
КонецФункции

// Возвращает префикс (Код) пространства имен в таблице ПространстваИменXSD,
// полученный из имени типа XSD.
//
// Параметры:
//  ПсевдонимТипаXSD - Строка - имя типа с префиксом пространства имен.
//
// Возвращаемое значение:
//   - Строка - префикс в имени типа.
//
Функция ПолучитьПрефиксПространстваИменИзИмениТипа(ПсевдонимТипаXSD) Экспорт
	ПозПрефикса = СтрНайти(ПсевдонимТипаXSD, ":");
	Если ПозПрефикса < 1 Тогда
		Возврат "";
	КонецЕсли;
	Возврат Лев(ПсевдонимТипаXSD, ПозПрефикса-1);
КонецФункции

// Возвращает псевдоним типа XSD без префикса пространства имен.
//
// Параметры:
//  ИмяТипаXSD - Строка - имя типа с префиксом пространства имен.
//
// Возвращаемое значение:
//   - Строка - псевдоним типа с префиксом.
//
Функция ПолучитьПсевдонимТипаXSDБезПрефикса(ПсевдонимТипаXSD)
	ПозПрефикса = СтрНайти(ПсевдонимТипаXSD, ":");
	Если ПозПрефикса < 1 Тогда
		Возврат ПсевдонимТипаXSD;
	КонецЕсли;
	Возврат Сред(ПсевдонимТипаXSD, ПозПрефикса+1);
КонецФункции

// Возвращает строку с описанием пространства имен, найденную
// по коду префикса.
//
Функция ПолучитьОписаниеПространстваИменПоПрефиксу(Префикс) Экспорт
	Строка_ = ЭтотОбъект.ПространстваИменXSD.Найти(Префикс, "Код");
	Возврат Строка_;
КонецФункции

// Возвращает строку с описанием пространства имен, найденную
//  по URI пространства имен.
//
// Параметры:
//  URI - Строка - URI пространства имен.
// 
// Возвращаемое значение:
//   - СтрокаТабличнойЧасти - если описание найдено.
//	 - Неопределено - описание не найдено.
//
Функция ПолучитьОписаниеПространстваИменПоURI(URI) Экспорт
	Строка_ = ЭтотОбъект.ПространстваИменXSD.Найти(URI, "ИмяПространстваИмен");
	Возврат Строка_;
КонецФункции

// Возвращает строку с описанием пространства имен W3C.
//
Функция ПолучитьОписаниеПространстваИменW3C() Экспорт
	Строка_ = ЭтотОбъект.ПространстваИменXSD.Найти(Истина, "ЭтоСтандартныйТип");
	Возврат Строка_;
КонецФункции

// Возвращает массив строк возможных значений для типа XSD.
//
// Параметры:
//  ИмяТипаXSD - Строка - имя типа xsd с префиксом.
// 
// Возвращаемое значение:
//   - Массив[Строка] - множество возможных значений.
//		Если ограничений нет, то массив будет пуст.
//
Функция ПолучитьПеречислениеДляИмениТипаЗначенияXSD(ИмяТипаXSD) Экспорт
	Результат = Новый Массив;
	мСтроки = ЭтотОбъект.МетаПеречисленияЗначенийXSD.НайтиСтроки(
		Новый Структура("ИмяТипа", ИмяТипаXSD));
	Для Каждого СтрокаПеречисления Из мСтроки Цикл
		Результат.Добавить(СтрокаПеречисления.Значение);
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Преобразует полное имя типа XSD (например,
//  http://www.w3.org/2001/XMLSchema/string) во внутреннее представление
//  {код пространства имен}:{имя типа} (например, xs:string).
//  Код пространства имен ищем в таблице ПространстваИменXSD.
//  Если не находит нужного пространства в таблице, то возвращает
//  короткое имя типа.
//
// Параметры:
//  ПолноеИмяТипаXSD - Строка - имя типа с URI пространства имен вначале.
// 
// Возвращаемое значение:
//   - Строка - сокращенное имя типа. Если есть описание пространства
//			имен в таблице ПространстваИменXSD, тогда с кодом
//			пространства. Иначе, просто сокращенное имя типа.
//
Функция ПолноеИмяТипаXSDВСокращенное(ПолноеИмяТипаXSD) Экспорт
	Поз = СтрНайти(ПолноеИмяТипаXSD, "/", НаправлениеПоиска.СКонца);
	Если Поз = 0 Тогда
		Возврат ПолноеИмяТипаXSD;
	КонецЕсли;
	URIПространстваИмен = Лев(ПолноеИмяТипаXSD, Поз-1);
	КраткоеИмя = Сред(ПолноеИмяТипаXSD, Поз+1);
	ОписаниеПространстваИмен = ПолучитьОписаниеПространстваИменПоURI(
		URIПространстваИмен);
	Если ОписаниеПространстваИмен = Неопределено Тогда
		Возврат КраткоеИмя;
	КонецЕсли;
	Возврат ОписаниеПространстваИмен.Код + ":" + КраткоеИмя;
КонецФункции

// Возвращает истина, если переданное значение, либо тип объекта XDTO,
// либо тип значения XDTO.
//
Функция ЭтоТипXDTO(ТипXSD) Экспорт
	ТипАргумента = ТипЗнч(ТипXSD);
	Возврат ТипАргумента = Тип("ТипЗначенияXDTO")
		ИЛИ ТипАргумента = Тип("ТипОбъектаXDTO");
КонецФункции

// Возвращает псевдоним имени типа XSD с префиксом для указанного типа XSD.
// Важно: если передать строковое представление типа, то оно будет
// возвращено как результат.
//
// Параметры:
//  ТипXSD - ТипЗначенияXDTO | ТипОбъектаXDTO | Строка - тип XSD.
// 
// Возвращаемое значение:
//   - Строка - псевдоним имени типа XSD с префиксом пространства имен.
//
Функция ПолучитьПсевдонимТипаXSD(ТипXSD)
	Если ТипXSD = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТипЗнч(ТипXSD) = Тип("Строка") Тогда
		Возврат ТипXSD;
	КонецЕсли;
	Возврат ПолучитьИмяСПрефиксомИзТипаXSD(ТипXSD);
КонецФункции

// Проверяет, что метаданные XSD - это описание объекта XSD.
//
// Параметры:
//  Правило	 - СтрокаТабличнойЧасти - метаданные XSD.
// 
// Возвращаемое значение:
//   - Булево - Истина - это описание метаданных объекта XSD.
//				Ложь - это не описание объекта XSD.
//
Функция ЭтоМетаданныеОбъектаXSD(Правило) Экспорт 
	Возврат Правило <> Неопределено
		И ЭтотОбъект.МетаТипыОбъектовXSD.Индекс(Правило) >= 0;
КонецФункции

// Переименовать в псевдонимах типов XSD префикс пространства имен.
//
// Параметры:
//  СтарыйПрефикс - Строка - префикс пространства имен, который нужно
//		заменить на новый.
//  НовыйПрефикс - Строка - префикс пространства имен, на который нужно
//		заменить старый.
//
Процедура ПереименоватьПространствоИменВПсевдонимахТиповXSD(
											СтарыйПрефикс,
											НовыйПрефикс) Экспорт
	ПереименоватьПространствоИменВПолеТаблицы(
		ЭтотОбъект.Значения1СВXDTO,
		"ИмяТипаПриемника",
		СтарыйПрефикс,
		НовыйПрефикс);
	ПереименоватьПространствоИменВПолеТаблицы(
		ЭтотОбъект.Объекты1СВXDTO,
		"ИмяТипаПриемника",
		СтарыйПрефикс,
		НовыйПрефикс);
	ПереименоватьПространствоИменВПолеТаблицы(
		ЭтотОбъект.ПравилаПреобразованияРеквизитов1СВXDTO,
		"ИмяТипаXSD",
		СтарыйПрефикс,
		НовыйПрефикс);
КонецПроцедуры


#КонецОбласти


#Область ВнешниеФункцииОтладки


#Область ИзменяемыеОбработчикиСобытийОтладки

///////////////////////////////////////////////////////////////////////////////
// Функции объявленные здесь не экспортные, но в них можно добавить свой код
// для обработки событий отладки.
///////////////////////////////////////////////////////////////////////////////


// Вызывается для событий отладки функции (процедуры): входа и выхода из нее.
//  Можно добавить свою логику обработки.
//
// Параметры:
//  ИмяСобытия - Строка - "Старт" - функция начала работу. "Конец" - функция
//		закончила работу.
//  КонтекстОтладки - Структура - описывает функцию: ее имя, аргумены
//		и возможно доп. параметры. См. СоздатьКонтекстОтладки().
//	ДопПараметры - Произвольный - любые параметры переданные вместе
//		с событием.
//
Процедура ОтладкаВнешнийОбработчикСобытияФункции(ИмяСобытия,
												КонтекстОтладки, 
												ДопПараметры=Неопределено)
	// Код обработки события
	
КонецПроцедуры

// Вызывается если удалось перехватить исключение.
//
// Параметры:
//  КонтекстОтладки - Структура - описывает функцию: ее имя, аргумены
//		и возможно доп. параметры. См. СоздатьКонтекстОтладки().
//  ИнформацияОбОшибке - ИнформацияОбОшибке - информация об ошибке.
//	ДопПараметры - Произвольный - любые параметры переданные вместе
//		с событием.
//
Процедура ОтладкаВнешнийОбработчикИсключения(КонтекстОтладки,
											ИнформацияОбОшибке,
											ДопПараметры)
	// Код обработки события
	
КонецПроцедуры
			
// Вызывается если в процессе отладки возникло ошибочное состояние
// стека отладки. Чаще всего это может произойти из-за исключений.
// Можно добавить свою логику обработки.
//
// Параметры:
//  КонтекстОтладки - Структура - описывает функцию: ее имя, аргумены
//		и возможно доп. параметры. См. СоздатьКонтекстОтладки().
//  ЧастьСтекаСОшибкой - Массив(Структура) - массив с ошибочной частью
//		стека отладки. Элементы - это контексты функций в порядке
//		их вызова.
//  ТекстОшибки - Строка - произвольный текст ошибки, если ее удалось
//		зафиксировать.
//
Процедура ОтладкаВнешнийОбработчикОшибкиСтека(КонтекстОтладки,
												ЧастьСтекаСОшибкой,
												ТекстОшибки="")
	// Код обработки события
	
КонецПроцедуры


#КонецОбласти


// Устанавливает флаг для работы функций отладки.
// Данный флаг и все функции отладки не сериализуются,
// и не сохраняются при конвертации в реквизит формы и обратно.
// Если данный флаг не установлен, то все функции отладки
// не будут выполняться.
// Внимание: очищает все данные отладки.
//
Процедура ВключитьОтладку() Экспорт
	УстановитьЗначениеВКонтексте("Отладка", Истина);
	ИнициализироватьСтекОтладки();
	Если ПолучитьУровеньФормированияЛогаКонвертации() < УровеньЛогаОтладка() Тогда
		УстановитьУровеньФормированияЛогаКонвертации(УровеньЛогаОтладка());
	КонецЕсли;
КонецПроцедуры

// Возвращает флаг работы функций отладки.
// Данный флаг и все функции отладки не сериализуются,
// и не сохраняются при конвертации в реквизит формы и обратно.
// Если данный флаг не установлен, то все функции отладки
// не будут выполняться.
//
Функция ОтладкаВключена() Экспорт
	Возврат ПолучитьЗначениеВКонтексте("Отладка", Ложь);
КонецФункции

// Сбрасывает флаг для работы функций отладки.
// Данный флаг и все функции отладки не сериализуются,
// и не сохраняются при конвертации в реквизит формы и обратно.
// Если данный флаг не установлен, то все функции отладки
// не будут выполняться.
// Внимание: очищает все данные отладки.
//
Процедура ВыключитьОтладку() Экспорт
	ИнициализироватьСтекОтладки();
	УстановитьЗначениеВКонтексте("Отладка", Ложь);
КонецПроцедуры

// Установить уровень событий, которые будут регистрироваться в логе конвертации.
//
// Параметры:
//  УровеньФормированияЛога - Число - в лог будут записываться события меньше
//		или равные по уровню данному значению. Если передать значение меньше 
//		нуля, то лог не будет формироваться.
//		Имена уровней событий можно найти в массиве имен уровней, который
//		возвращает функция ПолучитьМассивУровнейЛогирования().
//
Процедура УстановитьУровеньФормированияЛогаКонвертации(
											УровеньФормированияЛога) Экспорт
	ТекущееЗначение = ПолучитьЗначениеВКонтексте("УровеньФормированияЛога", -1);
	Если УровеньФормированияЛога >= 0 И ТекущееЗначение = -1 Тогда
		ИнициализироватьПодсистемуЛогирования(УровеньФормированияЛога);
	КонецЕсли;
КонецПроцедуры

// Очищает лог.
//
Процедура ОчиститьЛог() Экспорт
	УстановитьЗначениеВКонтексте("Лог", Новый Массив);
КонецПроцедуры

// Возвращает уровень событий, которые будут регистрироваться
// в логе конвертации.
// 
// Возвращаемое значение:
//   - Число - если меньше нуля, то лог не будет формироваться.
//		Уровни события соотвествуют массиву имен уровней, который
//		можно получить функцией ПолучитьМассивУровнейЛогирования().
//
Функция ПолучитьУровеньФормированияЛогаКонвертации() Экспорт
	Возврат ПолучитьЗначениеВКонтексте("УровеньФормированияЛога", -1);
КонецФункции

// Получить лог конвертации.
// 
// Возвращаемое значение:
//   - Массив(Структура) - строки лога от более поздних к более ранним.
//		Каждая строка лога - это структура с полями:
//			- ДатаВремя - Дата+Время - момент, когда событие было зафиксировано.
//			- Уровень - Число - индекс уровня события лога.
//			- ИмяУровня - Строка - имя уровня события лога.
//			- Текст - Строка - описание события.
//			- ДопДанные - Произвольный - дополнительные данные лога.
//
Функция ПолучитьЛогКонвертации() Экспорт
	Возврат ПолучитьЗначениеВКонтексте("Лог", Новый Массив);
КонецФункции

Функция ПолучитьЛогКонвертацииКакТекст() Экспорт
	мЗаписейЛога = ПолучитьЛогКонвертации();
	мСтрок = Новый Массив;
	Для Каждого Запись Из мЗаписейЛога Цикл
		мСтрок.Добавить(ЗаписьЛогаВСтроку(Запись));
	КонецЦикла;
	Возврат СтрСоединить(мСтрок, Символы.ПС);
КонецФункции

#Область УровниЛогирования


// Получить массив имен уровней логирования.
// 
// Возвращаемое значение:
//   - Массив(Строка) - наименования уровней логирования.
//		Индекс - это уровень. Значение - это имя уровня.
//
Функция ПолучитьМассивУровнейЛогирования() Экспорт
	мУровней = ПолучитьЗначениеВКонтексте("УровниЛогирования", Новый Массив);
	Если мУровней.Количество() = 0 Тогда
		мУровней.Добавить(ИмяУровняЛогаОшибка());
		мУровней.Добавить(ИмяУровняЛогаПредупреждение());
		мУровней.Добавить(ИмяУровняЛогаОтладка());
		мУровней.Добавить(ИмяУровняЛогаИнформация());
	КонецЕсли;
	Возврат мУровней;
КонецФункции

Функция ПолучитьУровеньЛогаПоИмени(ИмяУровняЛогирования) Экспорт
	мУровней = ПолучитьМассивУровнейЛогирования();
	Индекс = мУровней.Найти(ИмяУровняЛогирования);
	Возврат ?(Индекс = Неопределено, -1, Индекс);
КонецФункции

Функция ИмяУровняЛогаОшибка() Экспорт
	Возврат НСтр("ru='Ошибка'");
КонецФункции

Функция ИмяУровняЛогаПредупреждение() Экспорт
	Возврат НСтр("ru='Предупреждение'");
КонецФункции

Функция ИмяУровняЛогаОтладка() Экспорт
	Возврат НСтр("ru='Отладка'");
КонецФункции

Функция ИмяУровняЛогаИнформация() Экспорт
	Возврат НСтр("ru='Информация'");
КонецФункции

Функция УровеньЛогаОшибка() Экспорт
	Возврат ПолучитьУровеньЛогаПоИмени(ИмяУровняЛогаОшибка());
КонецФункции

Функция УровеньЛогаПредупреждение() Экспорт
	Возврат ПолучитьУровеньЛогаПоИмени(ИмяУровняЛогаПредупреждение());
КонецФункции

Функция УровеньЛогаОтладка() Экспорт
	Возврат ПолучитьУровеньЛогаПоИмени(ИмяУровняЛогаОтладка());
КонецФункции

Функция УровеньЛогаИнформация() Экспорт
	Возврат ПолучитьУровеньЛогаПоИмени(ИмяУровняЛогаИнформация());
КонецФункции


#КонецОбласти


#КонецОбласти


#Область НеЭкспортныеФункцииОтладки


// Функция вызывается, чтобы зарегистрировать запуск функции конвертации.
// Описание функции (контекст) добавляется в стек отладки.
// В лог добавляется соответствующее сообщение.
//
Функция ОтладкаПриНачалеФункции(ИмяФункции, 
								мАргументы=Неопределено, 
								ДопПараметры=Неопределено)
	Если ОтладкаВключена() Тогда
		КонтекстОтладки = СоздатьКонтекстОтладки(
			ИмяФункции, 
			СформироватьПредставлениеФункции(ИмяФункции, мАргументы),
			мАргументы,
			ДопПараметры);
		ОтладкаСобытияФункции("Старт", КонтекстОтладки);
		ДобавитьКонтекстОтладки(КонтекстОтладки);
		Возврат КонтекстОтладки;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Функция вызывается, чтобы обработать завершение функции конвертации.
// Описание функции удаляется из стека.
// Делается запись в лог о завершении функции.
// Если на вершине стека есть более поздние функции, то обрабатывается
// ошибка стека (делается запись в лог описания ошибочной части стека).
//
Процедура ОтладкаПриОкончанииФункции(КонтекстОтладкиФункции,
									 ДопПараметры=Неопределено)
	Если ОтладкаВключена() Тогда
		ИдКонтекста = КонтекстОтладкиФункции.Идентификатор;
		мКонтексты = ПолучитьКонтекстыОтладкиДо(ИдКонтекста);
		УдалитьКонтекстыОтладкиДо(ИдКонтекста);
		ОтладкаПроверитьЗафиксироватьОшибкиСтека(
			КонтекстОтладкиФункции, мКонтексты);
		ОтладкаСобытияФункции("Конец", КонтекстОтладкиФункции, ДопПараметры);
	КонецЕсли;
КонецПроцедуры

// Регистрирует события входа в функцию и выхода из нее.
// Можно добавить свою логику обработки.
//
Процедура ОтладкаСобытияФункции(ИмяСобытия,
						КонтекстОтладки, 
						ДопПараметры=Неопределено)
	Если ОтладкаВключена() Тогда
		ОтладкаДобавитьВЛогСУчетомИерархииСтека(
			УровеньЛогаОтладка(),
			ИмяСобытия + ": "+ КонтекстОтладки.Представление,
			ДопПараметры);
		ОтладкаВнешнийОбработчикСобытияФункции(
			ИмяСобытия, КонтекстОтладки, ДопПараметры);
	КонецЕсли;
КонецПроцедуры

Процедура ОтладкаЗафиксироватьИсключение(КонтекстОтладки, 
							ИнформацияОбОшибке,
							ДопПараметры=Неопределено)
	Если ОтладкаВключена() Тогда
		ОтладкаДобавитьВЛогСУчетомИерархииСтека(
			УровеньЛогаОшибка(),
			"Исключение в функции "+ КонтекстОтладки.Представление,
			ДопПараметры);
		ОтладкаВнешнийОбработчикИсключения(
			КонтекстОтладки, ИнформацияОбОшибке, ДопПараметры);
	КонецЕсли;
КонецПроцедуры

// Делает стектрейс в логи.
// Можно добавить свою логику обработки.
//
Процедура ОтладкаЗафиксироватьОшибкуСтекаКонтекстов(КонтекстОтладки,
												КонтекстыОтладкиПослеФункции,
												ТекстОшибки="")
	ОтладкаДобавитьВЛогСУчетомИерархииСтека(
		УровеньЛогаОшибка(),
		СтрШаблон(НСтр("ru='Ошибка отладки функций конвертации%1. Ошибочная часть стека:'"),
			?(ПустаяСтрока(ТекстОшибки), "", ": " + ТекстОшибки)),
		,
		1);
	Для Каждого КонтекстОтладки Из КонтекстыОтладкиПослеФункции Цикл
		ОтладкаДобавитьВЛогСУчетомИерархииСтека(
			УровеньЛогаОшибка(), КонтекстОтладки.Представление,, 1);
	КонецЦикла;
	ОтладкаВнешнийОбработчикОшибкиСтека(
		КонтекстОтладки, КонтекстыОтладкиПослеФункции, ТекстОшибки);
КонецПроцедуры

// Проверяет, что в переданной части стека от вершины до указанного контекста
// отсутствуют ошибки.
// Если ошибки есть, то вызывает обработчик события некорректного стека:
// ОтладкаЗафиксироватьОшибкуСтекаКонтекстов(). В нем можно добавить 
//
// Параметры:
//  КонтекстОтладкиФункции - Структура - контекст отладки функции.
//  КонтекстыОтладкиПослеФункции - Массив(Структура) - массив контекстов
//		отладки функции, представляющий из себя часть стека от вызова
//		функции до его вершины. Если ошибок небыло, то должен содержать
//		только один элемент - контекст функции.
// 
// Возвращаемое значение:
//   - Булево - флаг отсутствия ошибок в стеке отладки.
//  		Истина - ошибок нет.
//  		Ложь - ошибки есть.
//
Функция ОтладкаПроверитьЗафиксироватьОшибкиСтека(КонтекстОтладкиФункции,
												КонтекстыОтладкиСФункции)
	Если ОтладкаВключена() Тогда
		Если КонтекстыОтладкиСФункции = Неопределено 
					ИЛИ КонтекстыОтладкиСФункции.Количество() = 0 Тогда
			ОтладкаЗафиксироватьОшибкуСтекаКонтекстов(
				КонтекстОтладкиФункции,
				КонтекстыОтладкиСФункции,
				НСтр("ru='Отсутствует контекст возврата из функции.'"));
			Возврат Ложь;
		КонецЕсли;
		ИдКонтекста = КонтекстОтладкиФункции.Идентификатор;
		ПервыйКонтекст = КонтекстыОтладкиСФункции[0];
		Если ПервыйКонтекст.Идентификатор <> ИдКонтекста Тогда
			ОтладкаЗафиксироватьОшибкуСтекаКонтекстов(
				КонтекстОтладкиФункции,
				КонтекстыОтладкиСФункции,
				НСтр("ru='Отсутствует контекст возврата из функции.'"));
			Возврат Ложь;
		КонецЕсли;
		Если КонтекстыОтладкиСФункции.Количество() > 1 Тогда
			ОтладкаЗафиксироватьОшибкуСтекаКонтекстов(
				КонтекстОтладкиФункции,
				КонтекстыОтладкиСФункции,
				НСтр("ru='Внутри функции возникло(и) исключение(я).'"));
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	Возврат Истина;
КонецФункции

// Добавляет текст с отступом в двух пробелов на каждый уровень стека отладки.
//
Процедура ОтладкаДобавитьВЛогСУчетомИерархииСтека(УровеньЛога,
												  Текст,
												  ДопПараметры=Неопределено,
												  Отступ=0)
	СтекОтладки = ПолучитьСтекОтладки();
	РазмерОтсутпа = Отступ + СтекОтладки.Количество();
	ДобавитьВЛог(УровеньЛога, Текст, ДопПараметры, РазмерОтсутпа);
КонецПроцедуры

Функция СформироватьПредставлениеФункции(ИмяФункции,
										мАргументы=Неопределено)
	ПредставлениеФункции = ИмяФункции + "(";
	Если мАргументы <> Неопределено Тогда
		ПредставлениеФункции = ПредставлениеФункции
			+ АргументыВСтроку(мАргументы);
	КонецЕсли;
	ПредставлениеФункции = ПредставлениеФункции + ")";
	Возврат ПредставлениеФункции;
КонецФункции

Функция АргументыВСтроку(мАргументы, Разделитель=",")
	мСтрок = Новый Массив;
	Для Каждого Аргумент Из мАргументы Цикл
		мСтрок.Добавить(Строка(Аргумент));
	КонецЦикла;
	Возврат СтрСоединить(мСтрок, Разделитель);
КонецФункции


#Область НеЭкспортныеФункцииПреобразованияАргументовВМассив


Функция АргументыВМассив1(Аргумент1)
	Если ОтладкаВключена() Тогда
		Результат = Новый Массив;
		Результат.Добавить(Аргумент1);
		Возврат Результат;
	КонецЕсли;
КонецФункции

Функция АргументыВМассив2(Аргумент1, Аргумент2)
	Если ОтладкаВключена() Тогда
		Результат = Новый Массив;
		Результат.Добавить(Аргумент1);
		Результат.Добавить(Аргумент2);
		Возврат Результат;
	КонецЕсли;
КонецФункции

Функция АргументыВМассив3(Аргумент1, Аргумент2, Аргумент3)
	Если ОтладкаВключена() Тогда
		Результат = Новый Массив;
		Результат.Добавить(Аргумент1);
		Результат.Добавить(Аргумент2);
		Результат.Добавить(Аргумент3);
		Возврат Результат;
	КонецЕсли;
КонецФункции

Функция АргументыВМассив4(Аргумент1, Аргумент2, Аргумент3, Аргумент4)
	Если ОтладкаВключена() Тогда
		Результат = Новый Массив;
		Результат.Добавить(Аргумент1);
		Результат.Добавить(Аргумент2);
		Результат.Добавить(Аргумент3);
		Результат.Добавить(Аргумент4);
		Возврат Результат;		
	КонецЕсли;
КонецФункции

Функция АргументыВМассив5(Аргумент1, Аргумент2, Аргумент3, Аргумент4, Аргумент5)
	Если ОтладкаВключена() Тогда
		Результат = Новый Массив;
		Результат.Добавить(Аргумент1);
		Результат.Добавить(Аргумент2);
		Результат.Добавить(Аргумент3);
		Результат.Добавить(Аргумент4);
		Результат.Добавить(Аргумент5);
		Возврат Результат;
	КонецЕсли;
КонецФункции

Функция АргументыВМассив6(Аргумент1,
							Аргумент2,
							Аргумент3,
							Аргумент4,
							Аргумент5,
							Аргумент6)
	Если ОтладкаВключена() Тогда
		Результат = Новый Массив;
		Результат.Добавить(Аргумент1);
		Результат.Добавить(Аргумент2);
		Результат.Добавить(Аргумент3);
		Результат.Добавить(Аргумент4);
		Результат.Добавить(Аргумент5);
		Результат.Добавить(Аргумент6);
		Возврат Результат;
	КонецЕсли;
КонецФункции


#КонецОбласти


#Область РаботаСКонтекстамиОтладки

///////////////////////////////////////////////////////////////////////////////
// Контексты отладки описывают вызов функции и порядок их выполнения.
// Каждый контекст - это имя функции, ее аргументы и возможно доп. параметры.
// Контексты храняться в стеке, так, что при входе в функцию, мы регистрируем
// контекст (вставляем на вершину стека), а при выходе из функции удаляем
// со стека ее контекст (и если есть, все контексты выше).
// Если при удалении контекста (при выходе из функции), мы видим, что на стеке
// есть контексты выше - это означает, что выполнение дочерних функций
// было аварийно прервано исключением и отдельно обрабатываем это как ошибку.
// Все функции работают только, если включена отладка (см. ОтладкаВключена()).
// Все это делается руками, т.к. рефлексии нет.
///////////////////////////////////////////////////////////////////////////////


// Очищает стек контекстов функций.
//
Процедура ИнициализироватьСтекОтладки()
	Если ОтладкаВключена() Тогда
		УстановитьЗначениеВКонтексте("СтекОтладки", Новый Массив);
		УстановитьЗначениеВКонтексте(
			"ТекущийИдентификаторКонтекстаОтладки", 0);
	КонецЕсли;
КонецПроцедуры

Функция ПолучитьСтекОтладки()
	Возврат ПолучитьЗначениеВКонтексте("КонтекстыОтладки", Новый Массив);
КонецФункции

// Добавить в стек контекстов.
//
Процедура ДобавитьКонтекстОтладки(КонтекстОтладки)
	Если ОтладкаВключена() Тогда
		КонтекстыОтладки = ПолучитьСтекОтладки();
		КонтекстыОтладки.Добавить(КонтекстОтладки);
	КонецЕсли;
КонецПроцедуры

// Возвращает массив контекстов начиная с верха стека
// и заканчивая (включительно) указанным контекстом.
//
Функция ПолучитьКонтекстыОтладкиДо(ИдКонтекста)
	Результат = Новый Массив;
	Если ОтладкаВключена() Тогда
		КонтекстыОтладки = ПолучитьСтекОтладки();
		МаксИндекс = КонтекстыОтладки.Количество() - 1;
		Пока МаксИндекс >= 0 Цикл
			ТекущийКонтекст = КонтекстыОтладки[МаксИндекс];
			Результат.Добавить(ТекущийКонтекст);
			Если ТекущийКонтекст.Идентификатор = ИдКонтекста Тогда
				Прервать;
			КонецЕсли;
			МаксИндекс = МаксИндекс - 1;
		КонецЦикла;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Удалить все контексты вплоть до указанного.
// Если контекста нет, будет очищен весь стек.
//
Процедура УдалитьКонтекстыОтладкиДо(ИдКонтекста)
	Если ОтладкаВключена() Тогда
		КонтекстыОтладки = ПолучитьСтекОтладки();
		МаксИндекс = КонтекстыОтладки.Количество() - 1;
		Пока МаксИндекс >= 0 Цикл
			ТекущийИдентификатор = КонтекстыОтладки[МаксИндекс].Идентификатор;
			КонтекстыОтладки.Удалить(МаксИндекс);
			Если ТекущийИдентификатор = ИдКонтекста Тогда
				Прервать;
			КонецЕсли;
			МаксИндекс = МаксИндекс - 1;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

// Создает описание функции для отладки.
//
Функция СоздатьКонтекстОтладки(ИмяФункции,
								ПредставлениеФункции,
								мАргументы=Неопределено, 
								ДопПараметры=Неопределено)
	Если ОтладкаВключена() Тогда
		КонтекстОтладки = Новый Структура;
		КонтекстОтладки.Вставить("Идентификатор",
			ПолучитьСледующийИдентификаторКонтекстаОтладки());
		КонтекстОтладки.Вставить("ИмяФункции", ИмяФункции);
		КонтекстОтладки.Вставить("мАргументы", мАргументы);
		КонтекстОтладки.Вставить("ДопПараметры", ДопПараметры);
		КонтекстОтладки.Вставить("Представление", ПредставлениеФункции);
		Возврат КонтекстОтладки;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Генерирует непрерывно возрастающую последовательность чисел.
//
Функция ПолучитьСледующийИдентификаторКонтекстаОтладки()
	Если ОтладкаВключена() Тогда
		СледующийИд = 1 +
			ПолучитьЗначениеВКонтексте("ТекущийИдентификаторКонтекстаОтладки", 0);
		УстановитьЗначениеВКонтексте(
			"ТекущийИдентификаторКонтекстаОтладки", СледующийИд);
		Возврат СледующийИд;
	КонецЕсли;
	Возврат 0;
КонецФункции


#КонецОбласти


#КонецОбласти


#Область НеЭкспортныеФункцииЛогирования


Процедура ИнициализироватьПодсистемуЛогирования(УровеньФормированияЛога)
	УстановитьЗначениеВКонтексте(
		"УровеньФормированияЛога", УровеньФормированияЛога);
	ОчиститьЛог();
КонецПроцедуры

Функция ПолучитьПустуюЗаписьЛога()
	Возврат Новый Структура("ДатаВремя,Уровень,ИмяУровня,Текст,ДопДанные,Отступ");
КонецФункции

Процедура ДобавитьВЛогОшибку(Текст, ДопДанные=Неопределено, Отступ=0)
	ДобавитьВЛог(УровеньЛогаОшибка(), Текст, ДопДанные);
КонецПроцедуры

Процедура ДобавитьВЛогПредупреждение(Текст, ДопДанные=Неопределено, Отступ=0)
	ДобавитьВЛог(УровеньЛогаПредупреждение(), Текст, ДопДанные);
КонецПроцедуры

Процедура ДобавитьВЛогОтладку(Текст, ДопДанные=Неопределено, Отступ=0)
	ДобавитьВЛог(УровеньЛогаОтладка(), Текст, ДопДанные);
КонецПроцедуры

Процедура ДобавитьВЛогИнформацию(Текст, ДопДанные=Неопределено, Отступ=0)
	ДобавитьВЛог(УровеньЛогаИнформация(), Текст, ДопДанные);
КонецПроцедуры

// Процедура - Добавить в лог
//
// Параметры:
//  Уровень - Число - уровень события.
//  Текст - Строка - текст описания события.
//  ДопДанные - Произвольный - любые доп. данные.
//	Отступ - Число - размер смещения текста в логе.
//
Процедура ДобавитьВЛог(Уровень, Текст, ДопДанные=Неопределено, Отступ=0)
	МинУровеньЛогирования = ПолучитьУровеньФормированияЛогаКонвертации();
	Если Уровень >= 0 И Уровень <= МинУровеньЛогирования Тогда
		мУровниЛогирования = ПолучитьМассивУровнейЛогирования();
		ИмяУровня = ?(мУровниЛогирования.Количество() > Уровень,
			мУровниЛогирования[Уровень],
			"Неопределен");
		Запись = ПолучитьПустуюЗаписьЛога();
		Запись.ДатаВремя = ТекущаяУниверсальнаяДата();
		Запись.Уровень = Уровень;
		Запись.ИмяУровня = ИмяУровня;
		Запись.Текст = Текст;
		Запись.ДопДанные = ДопДанные;
		Запись.Отступ = Отступ;
		ПолучитьЛогКонвертации().Добавить(Запись);
	КонецЕсли;
КонецПроцедуры

Функция ЗаписьЛогаВСтроку(Запись)
	Результат = "";
	Для Ном=0 По Запись.Отступ Цикл
		Результат = Результат + "    ";
	КонецЦикла;
	Результат = Результат
		+ Формат(Запись.ДатаВремя, "")
		+ "; " + Запись.ИмяУровня
		+ "; " + Запись.Текст
		+ ?(Запись.ДопДанные = Неопределено, "", "; " + Запись.ДопДанные)
		+ ".";
	Возврат Результат;
КонецФункции


#КонецОбласти


#Область НеЭкспортныеРаботаСМетаданнымиXSD


// Возвращает префикс записанный в описании с ':' на конце.
//
// Параметры:
//  Пакет - ПакетXDTO - пакет из которого будет производится чтение.
//  ОписаниеПространстваИмен - СтрокаТабличнойЧасти ПространстваИменXSD
//		- описание пространства имен.
//
Функция ПолучитьПрефиксПространстваИмен(ОписаниеПространстваИмен)
	Если ОписаниеПространстваИмен = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	Возврат ОписаниеПространстваИмен.Код;
КонецФункции

// Возвращает имя типа XSD с префиксом.
//
//	ИмяТипаXSD - Строка - имя типа XSD без префикса пространства имен.
//  ОписаниеПространстваИмен - СтрокаТабличнойЧасти ПространстваИменXSD
//		- описание пространства имен.
//
Функция ДобавитьПрефиксКИмениТипаXSD(Префикс, ИмяТипаXSD)
	Если ПустаяСтрока(Префикс) ИЛИ ПустаяСтрока(ИмяТипаXSD) Тогда
		Возврат ИмяТипаXSD;
	КонецЕсли;
	Возврат Префикс + ":" + ИмяТипаXSD;
КонецФункции

// Возвращает соответствие, где ключи - это имена пространств имен,
// а значения - это пакеты XDTO.
// Для быстрого получения пакета по имени пространства имен.
//
Функция ПолучитьСоответствиеПакетовПространствамИмен(Фабрика)
	СоответствиеПакетов = Новый Соответствие;
	Для Каждого Пакет Из Фабрика.Пакеты Цикл
		СоответствиеПакетов.Вставить(Пакет.URIПространстваИмен, Пакет);
	КонецЦикла;
	Возврат СоответствиеПакетов;
КонецФункции

Функция ДобавитьВМетаданныеОписаниеТипаЗначенияXDTO(ТипЗначенияXDTO,
												ИмяТипа,
												ОписаниеПространстваИмен)
	НоваяСтрока = ЗаполнитьБазовоеОписаниеТипаXDTO(
		ЭтотОбъект.МетаТипыЗначенийXSD.Добавить(),
		ТипЗначенияXDTO,
		ИмяТипа,
		ОписаниеПространстваИмен);
	НоваяСтрока.ИмяТипаЭлементаСписка =
		ПолучитьИмяСПрефиксомИзТипаXSD(ТипЗначенияXDTO.ТипЭлементаСписка);
	НоваяСтрока.ЭтоОбъединение = 
		(ТипЗначенияXDTO.ТипыЧленовОбъединения <> Неопределено);
	НоваяСтрока.ЭтоПеречисление =
		ДобавитьПеречислениеЗначенийДляТипаXSD(
			НоваяСтрока.ИмяТипа, ТипЗначенияXDTO);
	Возврат НоваяСтрока;
КонецФункции

Функция ДобавитьВМетаданныеОписаниеТипаОбъектаXDTO(ТипОбъектаXDTO,
													ИмяТипа,
													ОписаниеПространстваИмен)
	НоваяСтрока = ЗаполнитьБазовоеОписаниеТипаXDTO(
		ЭтотОбъект.МетаТипыОбъектовXSD.Добавить(),
		ТипОбъектаXDTO,
		ИмяТипа,
		ОписаниеПространстваИмен);
	ДобавитьСвойстваТипаОбъектаXSDВМетаданные(
		НоваяСтрока.ИмяТипа,
		ТипОбъектаXDTO.Свойства,
		ОписаниеПространстваИмен);
	Возврат НоваяСтрока;
КонецФункции

// Заполняет одинковые поля для таблиц МетаТипыЗначенийXSD
// и МетаТипыОбъектовXSD.
Функция ЗаполнитьБазовоеОписаниеТипаXDTO(МетаданныеТипа,
										ТипТипаXDTO,
										ИмяТипа,
										ОписаниеПространстваИмен)
	ЗаполнитьЗначенияСвойств(МетаданныеТипа, ТипТипаXDTO);
	МетаданныеТипа.ИмяТипа = ИмяТипа;
	МетаданныеТипа.ИмяБазовогоТипа =
		ПолучитьИмяСПрефиксомИзТипаXSD(ТипТипаXDTO.БазовыйТип);
	МетаданныеТипа.ЭтоСтандартныйТип = ОписаниеПространстваИмен.ЭтоСтандартныйТип;
	МетаданныеТипа.БезОбъявления = ПустаяСтрока(ТипТипаXDTO.Имя);
	Возврат МетаданныеТипа;
КонецФункции

Процедура ДобавитьВМетаданныеОписаниеКорневыхСвойствПакетаXDTO(Пакет,
											ОписаниеПространстваИмен)
	Префикс = ПолучитьПрефиксПространстваИмен(ОписаниеПространстваИмен);
	Если Пакет.КорневыеСвойства.Количество() > 0 Тогда
		ИмяПакетаКакОбъектаXSD =
			ДобавитьПрефиксКИмениТипаXSD(Префикс, "Пакет");
		ДобавитьСвойстваТипаОбъектаXSDВМетаданные(
			ИмяПакетаКакОбъектаXSD,
			Пакет.КорневыеСвойства,
			ОписаниеПространстваИмен);
		ДобавитьОписаниеТиповКорневыхСвойствПакетаXSD(
			Пакет, ИмяПакетаКакОбъектаXSD, ОписаниеПространстваИмен);
	КонецЕсли;
КонецПроцедуры

Функция ДобавитьВМетаданныеОписаниеТипаXSD(ТипXSD,
											ИмяТипа,
											ОписаниеПространстваИмен,
											ПроверитьУникальность=Ложь)
	ТипСущности = ТипЗнч(ТипXSD);
	Если ТипСущности = Тип("ТипЗначенияXDTO") Тогда
		Если НЕ ПроверитьУникальность
				ИЛИ ПолучитьОписаниеТипаЗначенияXSDПоИмени(ИмяТипа)
													= Неопределено Тогда
			Возврат ДобавитьВМетаданныеОписаниеТипаЗначенияXDTO(
					ТипXSD, ИмяТипа, ОписаниеПространстваИмен);
		КонецЕсли;
	ИначеЕсли ТипСущности = Тип("ТипОбъектаXDTO") Тогда
		Если НЕ ПроверитьУникальность
				ИЛИ ПолучитьОписаниеТипаОбъектаXSDПоИмени(ИмяТипа)
													= Неопределено Тогда
			Возврат ДобавитьВМетаданныеОписаниеТипаОбъектаXDTO(
					ТипXSD, ИмяТипа, ОписаниеПространстваИмен);
		КонецЕсли;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Добавляет в метаданные xsd описание возможных значений типа.
//
// Параметры:
//  ИмяТипа - Строка - имя типа с префиксом.
//  ТипЗначенияXDTO - ТипЗначенияXDTO - тип значения.
// 
// Возвращаемое значение:
//  - Истина - если есть перечисление значений.
//  - Ложь - если нет.
//
Функция ДобавитьПеречислениеЗначенийДляТипаXSD(ИмяТипа, ТипЗначенияXDTO)
	Результат = Ложь;
	Если ТипЗначенияXDTO.Фасеты <> Неопределено Тогда
		Для Каждого Фасет Из ТипЗначенияXDTO.Фасеты Цикл
			Если Фасет.Вид = ВидФасетаXDTO.Перечисление Тогда
				Результат = Истина;
				НоваяСтрока = ЭтотОбъект.МетаПеречисленияЗначенийXSD.Добавить();
				НоваяСтрока.ИмяТипа = ИмяТипа;
				НоваяСтрока.Значение = Фасет.Значение;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Добавляет в метаданные xsd описание типа
Процедура ДобавитьОписаниеТиповКорневыхСвойствПакетаXSD(Пакет,
												ИмяПакетаКакОбъекта,
												ОписаниеПространстваИмен)
	Если Пакет <> Неопределено Тогда
		Для Каждого Свойство Из Пакет.КорневыеСвойства Цикл
			ИмяТипаСвойства = ИмяПакетаКакОбъекта + "." + Свойство.Имя;
			ДобавитьВМетаданныеОписаниеТипаXSD(
				Свойство.Тип,
				ИмяТипаСвойства,
				ОписаниеПространстваИмен,
				Истина);
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

// Добавляет в метаданные xsd описание возможных свойств объекта.
//
// Параметры:
//  ИмяТипаОбъекта - Строка - имя типа объекта с префиксом.
//  СвойстваОбъекта - КоллекцияСвойствоXDTO - множество свойств объекта.
// 
Процедура ДобавитьСвойстваТипаОбъектаXSDВМетаданные(ИмяТипаОбъекта,
										СвойстваОбъекта,
										ОписаниеПространстваИмен)
	Если СвойстваОбъекта <> Неопределено Тогда
		НомерСвойства = 0;
		Для Каждого Свойство Из СвойстваОбъекта Цикл
			НомерСвойства = НомерСвойства + 1;
			НоваяСтрока = ДобавитьСвойствоТипаОбъектаXSDВМетаданные(
				ИмяТипаОбъекта, Свойство, НомерСвойства);
			Если НоваяСтрока.БезОбъявления Тогда
				ДобавитьВМетаданныеОписаниеТипаXSD(
					Свойство.Тип,
					НоваяСтрока.ИмяТипаСвойства,
					ОписаниеПространстваИмен);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры

Функция ДобавитьСвойствоТипаОбъектаXSDВМетаданные(ИмяТипаОбъекта,
													Свойство, 
													НомерСвойства)
	ИмяТипаСвойства = ПолучитьИмяСПрефиксомИзТипаXSD(Свойство.Тип);
	НетИмениТипа = ПустаяСтрока(ИмяТипаСвойства);
	НоваяСтрока = ЭтотОбъект.МетаСвойстваОбъектовXSD.Добавить();
	ЗаполнитьЗначенияСвойств(НоваяСтрока, Свойство);
	НоваяСтрока.ПорядковыйНомер = НомерСвойства;
	НоваяСтрока.ИмяТипаОбъекта = ИмяТипаОбъекта;
	НоваяСтрока.ИмяСвойства = Свойство.Имя;
	НоваяСтрока.ИмяТипаСвойства = ?(НетИмениТипа,
		ИмяТипаОбъекта + "." + Свойство.Имя, ИмяТипаСвойства);
	Если Свойство.ЗначениеПоУмолчанию <> Неопределено Тогда
		НоваяСтрока.ЗначениеПоУмолчанию =
			Свойство.ЗначениеПоУмолчанию.Значение;
	КонецЕсли;
	НоваяСтрока.БезОбъявления = НетИмениТипа;
	Возврат НоваяСтрока;
КонецФункции

Функция СоответствиеПространствИменXSDВФабрикуXDTO()
	НовыйНаборСхемXML = Новый НаборСхемXML;
	Для Каждого Строка Из ПространстваИменXSD Цикл
		ТекстXSD = Строка.ТекстXSD;
		Если НЕ Строка.ЭтоСтандартныйТип
				ИЛИ НЕ ПустаяСтрока(ТекстXSD) Тогда
			НовыйНаборСхемXML.Добавить(ПолучитьСхемуXML(ТекстXSD));
		КонецЕсли;
	КонецЦикла;
	Возврат Новый ФабрикаXDTO(НовыйНаборСхемXML);
КонецФункции

Функция ПолучитьОписаниеТипаЗначенияXSDПоИмени(ИмяТипа)
	Возврат ЭтотОбъект.МетаТипыЗначенийXSD.Найти(ИмяТипа, "ИмяТипа");
КонецФункции

Функция ПолучитьОписаниеТипаОбъектаXSDПоИмени(ИмяТипа)
	Возврат ЭтотОбъект.МетаТипыОбъектовXSD.Найти(ИмяТипа, "ИмяТипа");
КонецФункции

Процедура ПереименоватьПространствоИменВПолеТаблицы(Таблица,
													ИмяПоля,
													СтарыйПрефикс,
													НовыйПрефикс)
	флНетСтарогоПрефикса = ПустаяСтрока(СтарыйПрефикс);
	Для Каждого Строка Из Таблица Цикл
		мПсевдонимТипа = СтрРазделить(Строка[ИмяПоля], ":");
		Если мПсевдонимТипа.Количество() = 1 И флНетСтарогоПрефикса Тогда
			Строка[ИмяПоля] = ДобавитьПрефиксКИмениТипаXSD(
				НовыйПрефикс, мПсевдонимТипа[0]);
		ИначеЕсли мПсевдонимТипа[0] = СтарыйПрефикс Тогда
			Строка[ИмяПоля] = ДобавитьПрефиксКИмениТипаXSD(
				НовыйПрефикс, мПсевдонимТипа[1]);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

	
#КонецОбласти


#Область НеЭкспортныеДляРаботыСПравиламиКонвертации


// Ищет вначале в правилах объектов, затем в правилах значений.
// Возвращает упакованный результат.
//
Функция НайтиПравилоПоУмолчаниюОбъект1СВОбъектXDTO(Объект1С,
													Тип1С=Неопределено,
													ТипXSD="",
													ИмяГруппы="",
													ЕстьДопПараметры=Ложь)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"НайтиПравилоПоУмолчаниюОбъект1СВОбъектXDTO",
		АргументыВМассив5(
			Объект1С, Тип1С, ТипXSD, ИмяГруппы, ЕстьДопПараметры));
	Попытка
		Если Тип1С = Неопределено Тогда
			ИмяТипа1С = Обработки.КонвертерОбъектовXDTOУХ.ПолучитьИмяТипа1С(
				Объект1С);
		Иначе
			ИмяТипа1С = Обработки.КонвертерОбъектовXDTOУХ.ПолучитьТипСтрокой(
				Тип1С);
		КонецЕсли;
		ПсевдонимТипаXSD = ПолучитьПсевдонимТипаXSD(ТипXSD);
		// Приоритет правилам преобразования объектов.
		Результат = НайтиПравилоПреобразованияОбъекта1СПоТипу1С(
			ИмяТипа1С, ПсевдонимТипаXSD, ИмяГруппы, ЕстьДопПараметры);
		Если Результат = Неопределено Тогда
			Результат = НайтиПравилоПреобразованияЗначения1С(
				Объект1С, ПсевдонимТипаXSD, ИмяГруппы, ЕстьДопПараметры);
		КонецЕсли;
	Исключение
		Инфо = ИнформацияОбОшибке();
		КонтекстОшибки = Новый Структура;
		КонтекстОшибки.Вставить("Объект1С", Строка(Объект1С));
		КонтекстОшибки.Вставить("Тип1С", Строка(Тип1С));
		КонтекстОшибки.Вставить("ТипXSD", Строка(ТипXSD));
		КонтекстОшибки.Вставить("ИмяГруппы", Строка(ИмяГруппы));
		КонтекстОшибки.Вставить("ЕстьДопПараметры", Строка(ЕстьДопПараметры));
		КонтекстОшибки.Вставить("Пояснение",
			НСтр("ru='Не удалось найти правило преобразования объекта 1С!"));
		ТекстОшибки = ПолучитьСтрокуОписанияОшибкиИзИсключения(
			Инфо, КонтекстОшибки);
		ОтладкаЗафиксироватьИсключение(КонтекстОтладки, Инфо);
		Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(ТекстОшибки);
	КонецПопытки;
	Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Результат);
КонецФункции

// Возвращает строку таблицы преобразований объектов 1С
// с описанием правила преобразования объекта требуемого типа.
//
Функция НайтиПравилоПреобразованияОбъекта1СПоТипу1С(ИмяТипа1С,
											ИмяТипаXSD="",
											ИмяГруппы=Неопределено,
											ЕстьДопПараметры=Ложь) 
	Результат = Неопределено;
	Отбор = Новый Структура;
	Отбор.Вставить("Отключить", Ложь);
	Отбор.Вставить("ИмяТипаИсточника", ИмяТипа1С);
	Отбор.Вставить("ЕстьДопПараметры", ЕстьДопПараметры);
	Если НЕ ПустаяСтрока(ИмяГруппы) Тогда
			Отбор.Вставить("ИмяГруппы", ИмяГруппы);
	КонецЕсли;
	Если НЕ ПустаяСтрока(ИмяТипаXSD) Тогда
		Отбор.Вставить("ИмяТипаПриемника", ИмяТипаXSD);
	КонецЕсли;
	мСтрок = ЭтотОбъект.Объекты1СВXDTO.НайтиСтроки(Отбор);
	Если мСтрок.Количество() = 1 Тогда
		Результат = мСтрок[0];
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Возвращает строку таблицы преобразований объектов 1С
// с описанием правила преобразования объекта.
// Поиск выполняется по имени (ключу) правила.
//
Функция ПолучитьПравилоПреобразованияОбъекта1СПоИмени(ИмяГруппы)
	Результат = Неопределено;
	Отбор = Новый Структура;
	Отбор.Вставить("Отключить", Ложь);
	Отбор.Вставить("ИмяГруппы", ИмяГруппы);
	мСтрок = ЭтотОбъект.Объекты1СВXDTO.НайтиСтроки(Отбор);
	Если мСтрок.Количество() = 1 Тогда
		Результат = мСтрок[0];
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Возвращает строку таблицы преобразований значений 1С
// с описанием правила преобразования значения требуемого типа.
//
Функция НайтиПравилоПреобразованияЗначения1С(Значение1С,
											ИмяТипаXSD=Неопределено,
											ИмяГруппы=Неопределено,
											ЕстьДопПараметры=Ложь)
	Результат = Неопределено;
	Если Значение1С <> Неопределено Тогда
		Отбор = Новый Структура;
		Отбор.Вставить("Значение1С", Значение1С);
		Отбор.Вставить("Отключить", Ложь);
		Отбор.Вставить("ЕстьДопПараметры", ЕстьДопПараметры);
		Если НЕ ПустаяСтрока(ИмяТипаXSD) Тогда
			Отбор.Вставить("ИмяТипаПриемника", ИмяТипаXSD);
		КонецЕсли;
		Если НЕ ПустаяСтрока(ИмяГруппы) Тогда
			Отбор.Вставить("ИмяГруппы", ИмяГруппы);
		КонецЕсли;
		мСтрок = ЭтотОбъект.Значения1СВXDTO.НайтиСтроки(Отбор);
		Если мСтрок.Количество() = 1 Тогда
			Результат = мСтрок[0];
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Возвращает массив активных правил преобразования реквизитов
// для выполнения преобразования.
//
Функция ПолучитьРабочиеПравилаПреобразованияРеквизитовОбъекта1СВXDTO(
									ПравилоПреобразованияОбъекта)
	Возврат ЭтотОбъект.ПравилаПреобразованияРеквизитов1СВXDTO.НайтиСтроки(
		Новый Структура("Отключить, Ключ",
			Ложь,
			ПравилоПреобразованияОбъекта.КлючПравилРеквизитов));
КонецФункции

// Преобразует строку таблицы правил в строку описывающую значения
// колонок в виде: "{%1} = {%2}, ",
// где %1 - заголовок колонки,
//     %2 - значение в правиле,
//	   запятая - это РазделительЗначений.
//
Функция ПравилоВСтроку(Правило,
						Знач ШаблонЗначения="",
						Знач РазделительЗначений=", ")
	Если Правило = Неопределено
			ИЛИ ТипЗнч(Правило) <> Тип("СтрокаТаблицыЗначений") Тогда
		Возврат "";
	КонецЕсли;
	Если ПустаяСтрока(ШаблонЗначения) Тогда
		ШаблонЗначения = "{%1} = {%2}";
	КонецЕсли;
	Если ПустаяСтрока(РазделительЗначений) Тогда
		РазделительЗначений = ", ";
	КонецЕсли;
	мРезультат = Новый Массив;
	ТЗ = Правило.Владелец();
	Для Каждого Колонка Из ТЗ.Колонки Цикл
		мРезультат.Добавить(СтрШаблон(ШаблонЗначения,
			Колонка.Заголовок,
			Правило.Получить[Колонка.Имя]));
	КонецЦикла;
	Возврат СтрСоединить(мРезультат, РазделительЗначений);
КонецФункции

Функция ПолучитьСоответствиеИменОбъектовИЗначенийXDTO()
	СоответствиеИменПравилам = Новый Соответствие;
	ДобавитьВСоответствиеИменИзТаблицы(СоответствиеИменПравилам,
		"Объекты1СВXDTO", "ИмяТипаПриемника");
	ДобавитьВСоответствиеИменИзТаблицы(СоответствиеИменПравилам,
		"Значения1СВXDTO", "ИмяТипаПриемника");
	Возврат СоответствиеИменПравилам;
КонецФункции

Функция ПолучитьСоответствиеИменМетаданнымXSD()
	СоответствиеИменМетаданным = Новый Соответствие;
	ДобавитьВСоответствиеИменИзТаблицы(СоответствиеИменМетаданным,
		"МетаТипыОбъектовXSD", "ИмяТипа");
	ДобавитьВСоответствиеИменИзТаблицы(СоответствиеИменМетаданным,
		"МетаТипыЗначенийXSD", "ИмяТипа");
	Возврат СоответствиеИменМетаданным;	
КонецФункции

Процедура ДобавитьВСоответствиеИменИзТаблицы(СоответствиеИменПравилам,
											ИмяТаблицы,
											ИмяРеквизитаИмя)
	Для Каждого СтрокаОбъекта Из ЭтотОбъект[ИмяТаблицы] Цикл
		Имя = СтрокаОбъекта[ИмяРеквизитаИмя];
		Если СоответствиеИменПравилам[Имя] = Неопределено Тогда
			СоответствиеИменПравилам[Имя] = СтрокаОбъекта;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Функция рекурсивна относительно параметров БылиТипыXSD и мИменаТиповXSD.
//
Процедура ДобавитьОбновитьПравилаДляИменТиповXSDРекурсивно(
													СоответствиеИменПравилам,
													СоответствиеИменМетаданным,
													БылиТипыXSD,
													мИменаТиповXSD)
	Пока мИменаТиповXSD.Количество() > 0 Цикл
		ИмяТипаXSD = ВыдавитьПервыйИзМассива(мИменаТиповXSD);
		Если БылиТипыXSD[ИмяТипаXSD] = Неопределено Тогда
			БылиТипыXSD.Вставить(ИмяТипаXSD, Истина);
			МетаданныеXSD = СоответствиеИменМетаданным[ИмяТипаXSD];
			Если МетаданныеXSD = Неопределено Тогда
					Сообщение = Новый СообщениеПользователю;
					Сообщение.Текст = "Не найдено описание типа: " + ИмяТипаXSD;
					Сообщение.Сообщить();
			ИначеЕсли НЕ МетаданныеXSD.ЭтоСтандартныйТип Тогда
				ДобавитьОбновитьПравилаДляПодчиненныхТиповXSD(
					СоответствиеИменПравилам,
					СоответствиеИменМетаданным,
					мИменаТиповXSD,
					МетаданныеXSD);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// В процедуре могут быть добавлены значения в мИменаТиповXSD, СоответствиеИменПравилам.
//
Процедура ДобавитьОбновитьПравилаДляПодчиненныхТиповXSD(
												СоответствиеИменПравилам,
												СоответствиеИменМетаданным,
												мИменаТиповXSD,
												МетаданныеТипаXSD)
	Если ТипXSDПодходитДляСозданияПравилаОбъектаИлиЗначения(
													МетаданныеТипаXSD) Тогда
		СтрокаПравилаДляТипаXSD = ПолучитьСоздатьПравилоДляТипаXSD(
				СоответствиеИменПравилам, МетаданныеТипаXSD);
		Если ЭтоМетаданныеОбъектаXSD(МетаданныеТипаXSD) Тогда
			мСвойствОбъектаXSD =
				ПолучитьМассивСвойствОбъектаXSDДляСозданияПравилРеквизитов(
					МетаданныеТипаXSD.ИмяТипа);
			ДобавитьСообщитьИменаТиповИзСвойствОбъектаXSDДляОбработки(
				СоответствиеИменМетаданным,
				МетаданныеТипаXSD.ИмяТипа,
				мСвойствОбъектаXSD,
				мИменаТиповXSD);
			Если ЭтоСтрокаПравилаОбъектаXSD(СтрокаПравилаДляТипаXSD)
					И СтрокаПравилаДляТипаXSD.СпособПолучения
											= "МассивПравил" Тогда
				ОбновитьПравилаПреобразованияРеквизитовОбъектаXSDДляМассиваСвойств(
					СтрокаПравилаДляТипаXSD, мСвойствОбъектаXSD);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

// Проверяем, что на основании данного типа XSD можно создать правило
// заполнения объекта XSD или значения XSD.
//
Функция ТипXSDПодходитДляСозданияПравилаОбъектаИлиЗначения(МетаданныеТипаXSD)
	Если МетаданныеТипаXSD <> Неопределено Тогда
		ЭтоОбъектXSD = ЭтоМетаданныеОбъектаXSD(МетаданныеТипаXSD);
		Возврат НЕ МетаданныеТипаXSD.ЭтоСтандартныйТип
			И (ЭтоОбъектXSD ИЛИ МетаданныеТипаXSD.ЭтоПеречисление);
	КонецЕсли;
	Возврат Ложь;
КонецФункции

Функция ПолучитьМассивСвойствОбъектаXSDДляСозданияПравилРеквизитов(ИмяТипаОбъектаXSD)
	мОтобраныСвойства = Новый Массив;
	мСвойствОбъектаXSD = ЭтотОбъект.МетаСвойстваОбъектовXSD.НайтиСтроки(
		Новый Структура("ИмяТипаОбъекта", ИмяТипаОбъектаXSD));
	Для Каждого Свойство Из мСвойствОбъектаXSD Цикл
		ИмяСвойства = Свойство.ИмяСвойства;
		Если НЕ ПустаяСтрока(ИмяСвойства) И НРег(ИмяСвойства) <> "all" Тогда
			мОтобраныСвойства.Добавить(Свойство);
		КонецЕсли;
	КонецЦикла;
	Возврат мОтобраныСвойства;
КонецФункции

Функция ЭтоСтрокаПравилаОбъектаXSD(СтрокаПравила)
	Возврат СтрокаПравила <> Неопределено
		И ЭтотОбъект.Объекты1СВXDTO.Индекс(СтрокаПравила) >= 0;
КонецФункции

Функция ПолучитьСоздатьПравилоДляТипаXSD(СоответствиеИменПравилам,
											МетаданныеТипаXSD)
	ИмяТипаXSD = МетаданныеТипаXSD.ИмяТипа;
	СтрокаПравила = СоответствиеИменПравилам[ИмяТипаXSD];
	Если СтрокаПравила = Неопределено Тогда
		Если ЭтоМетаданныеОбъектаXSD(МетаданныеТипаXSD) Тогда
			СтрокаПравила = ДобавитьПравилоОбъектаСТипомXSD(МетаданныеТипаXSD);
		Иначе
			СтрокаПравила = ДобавитьСтрокиЗначенийДляТипаXSD(МетаданныеТипаXSD);
		КонецЕсли;
		Если СтрокаПравила <> Неопределено Тогда
			СоответствиеИменПравилам[ИмяТипаXSD] = СтрокаПравила;
		КонецЕсли;
	КонецЕсли;
	Возврат СтрокаПравила;
КонецФункции

// Здесь мы точно знаем, что нет правил преобразования значений указанного
// типа (МетаданныеXSD.ИмяТипа).
Функция ДобавитьСтрокиЗначенийДляТипаXSD(МетаданныеXSD)
	ИмяТипа = МетаданныеXSD.ИмяТипа;
	Если МетаданныеXSD.ЭтоПеречисление Тогда
		Отбор = Новый Структура("ИмяТипа", ИмяТипа);
		мЗначенияПеречисленияXSD =
			ЭтотОбъект.МетаПеречисленияЗначенийXSD.НайтиСтроки(Отбор);
		Для Каждого СтрокаПеречисления Из мЗначенияПеречисленияXSD Цикл
			ДобавитьСтрокуЗначенияСТипомXSD(
				ИмяТипа, СтрокаПеречисления.Значение);
		КонецЦикла;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ДобавитьСтрокуЗначенияСТипомXSD(ИмяТипа, Значение)
	Возврат ДобавитьПравилоПреобразованияЗначения1СВXDTO(
		"Значение(Строка) -> " + ИмяТипа,
		"",
		ИмяТипа,
		"Значение",
		Ложь,
		Значение);
КонецФункции

Функция ДобавитьПравилоОбъектаСТипомXSD(МетаданныеXSD)
	ИмяТипа = МетаданныеXSD.ИмяТипа;
	ПравилоОбъекта = ДобавитьПравилоПреобразованияОбъекта1СВXDTO(
		"МассивПравил() -> " + ИмяТипа,
		"",
		ИмяТипа,
		"МассивПравил",
		Ложь,
		Неопределено);
	Возврат ПравилоОбъекта;
КонецФункции

Процедура ДобавитьСообщитьИменаТиповИзСвойствОбъектаXSDДляОбработки(
											СоответствиеИменМетаданным,
											ИмяТипаОбъекта,
											МассивСвойствОбъектаXSD,
											мИменаТиповXSD)
	Для Каждого Свойство Из МассивСвойствОбъектаXSD Цикл
		ИмяТипаСвойства = Свойство.ИмяТипаСвойства;
		МетаданныеТипаXSD = СоответствиеИменМетаданным[ИмяТипаСвойства];
		Если МетаданныеТипаXSD = Неопределено Тогда
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = СтрШаблон(НСтр(
				"ru='Не найдено описание типа %1 для реквизита %2 объекта %3!'"),
				ИмяТипаСвойства,
				Свойство.ИмяСвойства,
				ИмяТипаОбъекта);
			Сообщение.Сообщить();
		Иначе
			// Добавляем все возможные имена типов.
			// Проверка необходимости создания правила объекта
			// или значения будет выполнена в основной функции.
			мИменаТиповXSD.Добавить(ИмяТипаСвойства);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ОбновитьПравилаПреобразованияРеквизитовОбъектаXSDДляМассиваСвойств(
													ПравилоОбъектаXSD,
													МассивСвойствОбъектаXSD)
	мПравилРеквизитов =
		ЭтотОбъект.ПравилаПреобразованияРеквизитов1СВXDTO.НайтиСтроки(
			Новый Структура("Ключ", ПравилоОбъектаXSD.КлючПравилРеквизитов));
	мСвойствНетВПравилах = ПолучитьСвойстваБезПравилРеквизитов(
		мПравилРеквизитов, МассивСвойствОбъектаXSD);
	мНовыеПравила = СоздатьПравилаРеквизитовДляСвойствОбъектаXSD(
		ПравилоОбъектаXSD, мСвойствНетВПравилах);
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(
		мПравилРеквизитов, мНовыеПравила);
	НовыйПорядокПравил =
		ПолучитьНовыйПорядокПравилПреобразованияРеквизитовОбъектаXSD(
			мПравилРеквизитов, МассивСвойствОбъектаXSD);	
	УпорядочитьПравилаПреобразованияРеквизитовОбъектаXSD(
		мПравилРеквизитов, НовыйПорядокПравил);
КонецПроцедуры

// Возвращает:
//		- Массив - строки таблицы МетаСвойстваОбъектовXSD из массива
//				мПравилРеквизитов, для которых нет правил в массиве
//				мСвойствОбъектаXSD.
Функция ПолучитьСвойстваБезПравилРеквизитов(мПравилРеквизитов, мСвойствОбъектаXSD)
	СвойстваНетВПравилах = Новый Массив;
	РеквизитыПравилСИндексами =
		ПреобразоватьМассивОбъектовВСоответствиеИменИИндексов(
			мПравилРеквизитов, "Приемник");
	Для Каждого Свойство Из мСвойствОбъектаXSD Цикл
		ИмяСвойства = Свойство.ИмяСвойства;
		ИндексПравила = РеквизитыПравилСИндексами[ИмяСвойства];
		Если ИндексПравила = Неопределено Тогда
			СвойстваНетВПравилах.Добавить(Свойство);
		КонецЕсли;
	КонецЦикла;
	Возврат СвойстваНетВПравилах;
КонецФункции

// Возвращает массив созданных правил.
//
Функция СоздатьПравилаРеквизитовДляСвойствОбъектаXSD(ПравилоОбъектаXSD,
														мСвойствНетВПравилах)
	мНовыеПравила = Новый Массив;
	Для Каждого Свойство Из мСвойствНетВПравилах Цикл
		ПравилоРеквизита = ДобавитьЧерновоеПравилоРеквизитаДляСвойстваОбъектаXSD(
			ПравилоОбъектаXSD,
			Свойство.ПорядковыйНомер,
			Свойство.ИмяСвойства,
			Свойство.ИмяТипаСвойства,
			"ПоТипу");
		мНовыеПравила.Добавить(ПравилоРеквизита);
	КонецЦикла;
	Возврат мНовыеПравила;
КонецФункции

Функция ДобавитьЧерновоеПравилоРеквизитаДляСвойстваОбъектаXSD(
												ПравилоОбъектаXSD,
												ПорядковыйНомер,
												ИмяСвойства,
												ИмяТипаСвойства,
												СпособПреобразования)
	ПравилоРеквизита = ДобавитьПравилоПреобразованияРеквизитВРеквизит(
		ПравилоОбъектаXSD, "", ИмяСвойства);
	ПравилоРеквизита.ПорядковыйНомер = ПорядковыйНомер;
	УстановитьПравилоПреобразованияДанных1С(
		ПравилоРеквизита, СпособПреобразования, ИмяТипаСвойства, "", Ложь);
	Возврат ПравилоРеквизита;
КонецФункции

// Возвращает:
//		- Массив - строки таблицы ПравилаПреобразованияРеквизитов1СВXDTO.
//			Значения в массиве упорядочены в соответствии с порядком
//			установленным порядком соответствующих свойств
//			в мСвойствОбъектаXSD.
//
Функция ПолучитьНовыйПорядокПравилПреобразованияРеквизитовОбъектаXSD(
													мПравилРеквизитов,
													мСвойствОбъектаXSD)
	МаксИндексПравила = мПравилРеквизитов.Количество()-1;
	НовыйПорядокПравил = Новый Массив(МаксИндексПравила+1);
	РеквизитыПравилСИндексами =
		ПреобразоватьМассивОбъектовВСоответствиеИменИИндексов(
			мПравилРеквизитов, "Приемник");
	ИндексПеремещения = -1;
	Для Каждого Свойство Из мСвойствОбъектаXSD Цикл
		ИмяСвойства = Свойство.ИмяСвойства;
		ИндексПравила = РеквизитыПравилСИндексами[ИмяСвойства];
		Если ИндексПравила <> Неопределено Тогда
			ИндексПеремещения = ИндексПеремещения + 1;
			НовыйПорядокПравил[ИндексПравила] = ИндексПеремещения;
		КонецЕсли;
	КонецЦикла;
	// Правила не связанные с реквизитами объекта поставим ниже
	// того места, куда переместиться ближайший "верхним" сосед
	// в текущем расположении.
	Для Индекс = 0 По МаксИндексПравила Цикл
		Если НовыйПорядокПравил[Индекс] = Неопределено Тогда
			ИндексПеремещения = 
				?(Индекс = 0, 0, НовыйПорядокПравил[Индекс-1]+1);
			ДобавитьЕдиницуКоВсемПозицииНачинаяСоЗначения(
				НовыйПорядокПравил, ИндексПеремещения);
			НовыйПорядокПравил[Индекс] = ИндексПеремещения;
		КонецЕсли;
	КонецЦикла;
	Возврат НовыйПорядокПравил;
КонецФункции

Процедура ДобавитьЕдиницуКоВсемПозицииНачинаяСоЗначения(НовыйПорядокПравил,
														ПорогСдвига)
	МаксИндекс = НовыйПорядокПравил.Количество()-1;
	Для Индекс = 0 По МаксИндекс Цикл
		Значение = НовыйПорядокПравил[Индекс];
		Если Значение <> Неопределено И Значение >= ПорогСдвига Тогда
			НовыйПорядокПравил[Индекс] = Значение + 1;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Переупорядочивает строки в ТЧ ПравилаПреобразованияРеквизитов1СВXDTO
// из массива мПравилРеквизитов в соответствии с перестановками
// из массива НовыйПорядокПравил.
// 
Процедура УпорядочитьПравилаПреобразованияРеквизитовОбъектаXSD(
												мПравилРеквизитов,
												НовыйПорядокПравил)
	УстановитьПорядковыйНомерПравилРеквизитовОбъектаXSD(
		мПравилРеквизитов, НовыйПорядокПравил);
	Если НЕ ЭтоЕдиничнаяПерестановка(НовыйПорядокПравил) Тогда
		ПереместитьВКонецСтрокиТЧПоПерестановке(
			мПравилРеквизитов,
			НовыйПорядокПравил,
			ЭтотОбъект.ПравилаПреобразованияРеквизитов1СВXDTO);
	КонецЕсли;
КонецПроцедуры
	 
Процедура УстановитьПорядковыйНомерПравилРеквизитовОбъектаXSD(
											МассивСтрок,
											МассивПерестановки)
	МаксИндекс = МассивСтрок.Количество()-1;
	Для Индекс = 0 По МаксИндекс Цикл
		Правило = МассивСтрок[Индекс];
		Правило.ПорядковыйНомер = МассивПерестановки[Индекс] + 1;
	КонецЦикла;
КонецПроцедуры

Функция ПолучитьПравилоОбъектаПоПравилуРеквизита(ПравилоРеквизита)
	мСтрокиПравил = ЭтотОбъект.Объекты1СВXDTO.НайтиСтроки(
		Новый Структура("КлючПравилРеквизитов", ПравилоРеквизита.Ключ));
	Если мСтрокиПравил.Количество() > 0 Тогда
		Возврат мСтрокиПравил[0];
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ПолучитьОписаниеПравилаПреобразованияОбъекта(Правило)
	Если Правило = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Описание = Новый Структура;
	Описание.Вставить("Тип",
		НСтр("ru='Правило преобразования объекта'"));
	Описание.Вставить("НомерПравила", Правило.НомерСтроки);
	Описание.Вставить("ИмяГруппы", Правило.ИмяГруппы);
	Описание.Вставить("ИмяТипаИсточника", Правило.ИмяТипаИсточника);
	Описание.Вставить("ЕстьДопПараметры", Правило.ЕстьДопПараметры);
	Описание.Вставить("ИмяТипаПриемника", Правило.ИмяТипаПриемника);
	Описание.Вставить("СпособПолучения", Правило.СпособПолучения);
	Возврат Описание;
КонецФункции

Функция ПолучитьОписаниеПравилаПреобразованияЗначения(Правило)
	Если Правило = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Описание = Новый Структура;
	Описание.Вставить("Тип",
		НСтр("ru='Правило преобразования значения'"));
	Описание.Вставить("НомерПравила", Правило.НомерСтроки);
	Описание.Вставить("ИмяГруппы", Правило.ИмяГруппы);
	Описание.Вставить("ИмяЗначения1С", Правило.ИмяЗначения);
	Описание.Вставить("ИмяТипаИсточника", Правило.ИмяТипаИсточника);
	Описание.Вставить("ЕстьДопПараметры", Правило.ЕстьДопПараметры);
	Описание.Вставить("ИмяТипаПриемника", Правило.ИмяТипаПриемника);
	Описание.Вставить("СпособПолучения", Правило.СпособПолучения);
	Возврат Описание;
КонецФункции

Функция ПолучитьОписаниеПравилаПреобразованияРеквизитаОбъекта(Правило)
	Если Правило = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Описание = Новый Структура;
	Описание.Вставить("Тип",
		НСтр("ru='Правило преобразования реквизита объекта'"));
	Описание.Вставить("НомерПравила", Правило.ПорядковыйНомер);
	Описание.Вставить("СпособПолучения", Правило.СпособПолучения);
	Если Правило.СпособПолучения = "Реквизит" Тогда
		Описание.Вставить("ИмяРеквизитаИсточника", Правило.ИсточникПолучения);
	КонецЕсли;
	Описание.Вставить("ЕстьДопПараметры", Правило.ЕстьДопПараметры);
	Описание.Вставить("ИмяТипаXSD", Правило.ИмяТипаXSD);
	Описание.Вставить("СпособЗаполнения", Правило.СпособЗаполнения);
	Если Правило.СпособЗаполнения = "Реквизит" Тогда
		Описание.Вставить("ИмяРеквизитаПриемника", Правило.Приемник);
	КонецЕсли;
	Возврат Описание;
КонецФункции

	
#КонецОбласти


#Область НеЭкспортныеПреобразованияЗначений1СвXDTO


// Возвращает тип XDTO для указанного правила.
//
Функция ПолучитьТипXDTOИзПравила(ПравилоПреобразованияОбъекта)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьТипXDTOИзПравила",
		АргументыВМассив1(ПравилоПреобразованияОбъекта));
	ПсевдонимТипаXSD = ПравилоПреобразованияОбъекта.ИмяТипаПриемника;
	Результат = ПолучитьТипXDTOПоПсевдонимуИмениТипа(ПсевдонимТипаXSD);
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

// Псевдонимом может быть:
//	- Имя типа без префикса пространства имен (для типа
//			из основного пространства имен).
//	- Имя типа с префиксом пространства имен, например, xs:string.
//	- Путь к свойству, тип которого нужно получить, например,
//			attachements.fileName.
//	- Путь к свойству с префиксом "Пакет." вначале. Возвращает
//			тип из свойства описанного в корневых свойствах пакета.
//
Функция ПолучитьТипXDTOПоПсевдонимуИмениТипа(ПсевдонимТипаXSD)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьТипXDTOПоПсевдонимуИмениТипа",
		АргументыВМассив1(ПсевдонимТипаXSD));
	Префикс = "";
	URIТипаXSD = ПолучитьURIПространстваИменИзПсевдонимаТипа(
		ПсевдонимТипаXSD, Префикс);
	Если ПустаяСтрока(Префикс) Тогда
		ИмяТипаXSDБезПрефикса = ПсевдонимТипаXSD;
	Иначе
		ИмяТипаXSDБезПрефикса = Сред(ПсевдонимТипаXSD, СтрДлина(Префикс)+2);
	КонецЕсли;
	Если СтрНайти(ИмяТипаXSDБезПрефикса, ".") > 0 Тогда
		Результат = ПолучитьТипДляВложенныхСвойств(
			URIТипаXSD, ИмяТипаXSDБезПрефикса);
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Результат;
	КонецЕсли;
	ФабрикаXDTO_ = ПолучитьФабрикуXDTO();
	Результат = ФабрикаXDTO_.Тип(URIТипаXSD, ИмяТипаXSDБезПрефикса);
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

// Для пути к свойству объекта XDTO возвращает тип свойства.
//
// Параметры:
//  URIТипаXSD - Строка - URI пространства имен.
//  ПутьКСвойствуXSD - Строка - последовательность имен свойств объека XDTO
//		разделенные точками. Путь должен начинаться, либо с объявленного
//		пространстве имен типа объекта XSD, либо с префикса "Пакет.",
//		что означает, что 
// 
// Возвращаемое значение:
//   - 
//
Функция ПолучитьТипДляВложенныхСвойств(URIТипаXSD, ПутьКСвойствуXSD)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьТипДляВложенныхСвойств",
		АргументыВМассив2(URIТипаXSD, ПутьКСвойствуXSD));
	мИменСвойств = СтрРазделить(ПутьКСвойствуXSD, ".", Ложь);
	МаксИндекс = мИменСвойств.Количество() - 1;
	Если МаксИндекс < 0 Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Неопределено;
	КонецЕсли;
	Если НРег(мИменСвойств[0]) = "пакет" Тогда
		СтартовыйИндекс = 2;
		ТекущийТип = ПолучитьКорневоеСвойствоПакетаXDTO(
			URIТипаXSD, мИменСвойств[1]).Тип;
	Иначе
		СтартовыйИндекс = 1;
		ФабрикаXDTO_ = ПолучитьФабрикуXDTO();
		ТекущийТип = ФабрикаXDTO_.Тип(URIТипаXSD, мИменСвойств[0]);
	КонецЕсли;
	Для Индекс = СтартовыйИндекс По МаксИндекс Цикл
		ТекущийТип = ТекущийТип.Свойства.Получить(мИменСвойств[Индекс]).Тип;
	КонецЦикла;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат ТекущийТип;
КонецФункции

Функция ПолучитьКорневоеСвойствоПакетаXDTO(URIПакета, ИмяСвойства)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьКорневоеСвойствоПакетаXDTO",
		АргументыВМассив2(URIПакета, ИмяСвойства));
	Пакет = ПолучитьПакетXDTOПоURI(URIПакета);
	Если Пакет = Неопределено Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Неопределено;
	КонецЕсли;
	Результат = Пакет.КорневыеСвойства.Получить(ИмяСвойства);
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

Функция ПолучитьЛокальноеИмяТипаОбъектаXDTO(ОбъектXDTO)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьЛокальноеИмяТипаОбъектаXDTO",
		АргументыВМассив1("ОбъектXDTO"));
	Если ОбъектXDTO = Неопределено 
				ИЛИ ТипЗнч(ОбъектXDTO) <> Тип("ОбъектXDTO") Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Неопределено;
	КонецЕсли;
	ТипXSD = ОбъектXDTO.Тип();
	ОтладкаПриОкончанииФункции(КонтекстОтладки);	
	Возврат ТипXSD.Имя;
КонецФункции

Функция УдалитьПрефиксПакетаИзПсевдонимаТипаXSD(ПсевдонимТипаXSD)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"УдалитьПрефиксПакетаИзПсевдонимаТипаXSD",
		АргументыВМассив1(ПсевдонимТипаXSD));
	ПозПрефикса = СтрНайти(ПсевдонимТипаXSD, ".");
	Если ПозПрефикса < 1 Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат ПсевдонимТипаXSD;
	КонецЕсли;
	Результат = Сред(ПсевдонимТипаXSD, ПозПрефикса+1);
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

Функция ПолучитьПакетXDTOПоURI(URIПакета)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьПакетXDTOПоURI", АргументыВМассив1(URIПакета));
	ФабрикаXDTO_ = ПолучитьФабрикуXDTO();
	Для Каждого Пакет Из ФабрикаXDTO_.Пакеты Цикл
		Если НРег(Пакет.URIПространстваИмен) = НРег(URIПакета) Тогда
			ОтладкаПриОкончанииФункции(КонтекстОтладки);
			Возврат Пакет;
		КонецЕсли;
	КонецЦикла;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Неопределено;
КонецФункции

// По правилу преобразовывает объект 1С в объект XDTO.
//
Функция ВыполнитьПравилоПреобразованияОбъекта1С(
										ПравилоПреобразованияОбъекта,
										Объект1С,
										ДопПараметры)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ВыполнитьПравилоПреобразованияОбъекта1С",
		АргументыВМассив3(
			ПравилоПреобразованияОбъекта, Объект1С, ДопПараметры));
	Результат = Неопределено;
	СпособПолучения = ПравилоПреобразованияОбъекта.СпособПолучения;
	Если СпособПолучения = "Значение" Тогда
		Результат =  ПравилоПреобразованияОбъекта.ПростоеЗначение;
	ИначеЕсли СпособПолучения = "XML" Тогда
		Результат =  ОбщегоНазначения.ОбъектXDTOИзСтрокиXML(
			ПравилоПреобразованияОбъекта.БольшаяСтрока,
			ПолучитьФабрикуXDTO());
	ИначеЕсли СпособПолучения = "Функция" Тогда
		Результат =  ВычислитьОбъектXDTOИзФункции(
			ПравилоПреобразованияОбъекта, Объект1С, ДопПараметры);
	ИначеЕсли СпособПолучения = "МассивПравил" Тогда
		Результат = СоздатьОбъектXDTOПоТипу(
			ПолучитьТипXDTOИзПравила(ПравилоПреобразованияОбъекта));
		Результат = ЗаполнитьРеквизитыОбъектаXDTOПоПравилу(
			ПравилоПреобразованияОбъекта, Объект1С, Результат, ДопПараметры);
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

// Выполняет функцию записанную в правиле и возвращает ее результат
// как объект XDTO. В переменную ДопПарметры принимает доп. параметры
// и в нее же возвращает доп. параметры для последующих функций.
//
// Контекст функции:
//	- Объект1С - объект, который нужно преобразовать в XDTO;
//	- ФабрикаXDTO - фабрика;
//	- ПравилоПреобразования - правило преобразования объекта;
//	- Вход - Структура | Неопределено - дополнительные параметры
//			переданные в правило из вызывающего правила.
//
Функция ВычислитьОбъектXDTOИзФункции(ПравилоПреобразования,
									Объект1С,
									ДопПараметры)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ВычислитьОбъектXDTOИзФункции",
		АргументыВМассив3(
			ПравилоПреобразования, Объект1С, ДопПараметры));
	ТекстФункции = ПравилоПреобразования.БольшаяСтрока;
	Если ТекстФункции = "" Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Неопределено;
	КонецЕсли;								
	ПараметрыФункции = Новый Структура;
	ПараметрыФункции.Вставить("Объект1С", Объект1С);
	ПараметрыФункции.Вставить("ФабрикаXDTO", ПолучитьФабрикуXDTO());
	ПараметрыФункции.Вставить("ПравилоПреобразования", ПравилоПреобразования);
	ПараметрыФункции.Вставить("Вход", ДопПараметры);
	Результат = ВыполнитьАлгоритм(ТекстФункции, ПараметрыФункции);
	Если Результат.ЕстьОшибка Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		ВызватьИсключение ПолучитьСтрокуОписанияОшибки(
			Результат.Ошибка,
			ПолучитьКонтекстОшибкиДляПравилаОбъекта(
				ПравилоПреобразования, Объект1С));
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат.Результат;
КонецФункции

// По правилу преобразовывает объект или значение 1С
// в значение или объект XDTO.
//
Функция ВыполнитьПравилоПреобразованияЗначения1С(
											ПравилоПреобразованияЗначения,
											Объект1С,
											ДопПараметры)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ВыполнитьПравилоПреобразованияЗначения1С",
		АргументыВМассив3(
			"ПравилоПреобразованияЗначения", Объект1С, ДопПараметры));
	Результат = Неопределено;
	СпособПолучения = ПравилоПреобразованияЗначения.СпособПолучения;
	Если СпособПолучения = "XML" Тогда
		Результат = ОбщегоНазначения.ОбъектXDTOИзСтрокиXML(
			ПравилоПреобразованияЗначения.БольшаяСтрока,
			ПолучитьФабрикуXDTO());
	ИначеЕсли СпособПолучения = "Функция" Тогда
		Результат = ВычислитьОбъектXDTOИзФункции(
			ПравилоПреобразованияЗначения, Объект1С, ДопПараметры);
	ИначеЕсли СпособПолучения = "Значение" Тогда
		Результат = ПравилоПреобразованияЗначения.ПростоеЗначение;
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

// По правилу заполняет реквизиты объекта XDTO из объекта 1С.
//
Функция ЗаполнитьРеквизитыОбъектаXDTOПоПравилу(
										ПравилоПреобразованияОбъекта,
										Объект1С,
										ОбъектXDTO,
										ДопПараметры)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ЗаполнитьРеквизитыОбъектаXDTOПоПравилу",
		АргументыВМассив4(ПравилоПреобразованияОбъекта, Объект1С, ОбъектXDTO, ДопПараметры));
	Если ПравилоПреобразованияОбъекта = Неопределено
			ИЛИ ОбъектXDTO = Неопределено 
			ИЛИ Объект1С = Неопределено Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Неопределено;
	КонецЕсли;
	мПравилРеквизитов =
		ПолучитьРабочиеПравилаПреобразованияРеквизитовОбъекта1СВXDTO(
			ПравилоПреобразованияОбъекта);
	Если мПравилРеквизитов.Количество() > 0 Тогда
		КонтекстПреобразованияРеквизита =
			СоздатьКонтекстПреобразованияРеквизита(
				ПравилоПреобразованияОбъекта, Объект1С, ОбъектXDTO, ДопПараметры);
		Если НЕ ПустаяСтрока(
					ПравилоПреобразованияОбъекта.ФункцияПередЗаполнением) Тогда
			УпакованныйРезультат = ВыполнитьАлгоритм(
				ПравилоПреобразованияОбъекта.ФункцияПередЗаполнением,
				КонтекстПреобразованияРеквизита);
			Если УпакованныйРезультат.ЕстьОшибка Тогда
				ОтладкаПриОкончанииФункции(КонтекстОтладки);
				ВызватьИсключение ПолучитьСтрокуОписанияОшибки(
					УпакованныйРезультат.Ошибка,
					ПолучитьКонтекстОшибкиДляПравилаОбъекта(
						ПравилоПреобразованияОбъекта, Объект1С))
			КонецЕсли;	
		КонецЕсли;
		Если КонтекстПреобразованияРеквизита.ОбъектXDTO <> Неопределено Тогда
			ОбработатьПравилаЗаполненияРеквизитовОбъектаXDTO(
				КонтекстПреобразованияРеквизита, мПравилРеквизитов);
		КонецЕсли;
	КонецЕсли;
	Результат = КонтекстПреобразованияРеквизита.ОбъектXDTO;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;	
КонецФункции

Процедура ОбработатьПравилаЗаполненияРеквизитовОбъектаXDTO(
										КонтекстПреобразованияРеквизита,
										мПравилРеквизитов)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ОбработатьПравилаЗаполненияРеквизитовОбъектаXDTO",
		АргументыВМассив2(
			КонтекстПреобразованияРеквизита, мПравилРеквизитов));
	Для Каждого ПравилоПреобразованияРеквизита Из мПравилРеквизитов Цикл
		УстановитьВКонтекстеПравилоПреобразованияРеквизита(
			КонтекстПреобразованияРеквизита,
			ПравилоПреобразованияРеквизита);
		ЗаполнитьРеквизитОбъектаXDTOПоПравилу(
			КонтекстПреобразованияРеквизита);
	КонецЦикла;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
КонецПроцедуры
		
// По правилу заполняет реквизиты объекта XDTO из объекта 1С.
//
Процедура ЗаполнитьРеквизитОбъектаXDTOПоПравилу(КонтекстПреобразования)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ЗаполнитьРеквизитОбъектаXDTOПоПравилу",
		АргументыВМассив1(КонтекстПреобразования));
	ЗначениеРеквизита = ПолучитьЗначениеРеквизитаОбъекта1С(
		КонтекстПреобразования);
	ЗначениеДляЗаписи = ПреобразоватьЗначениеРеквизита1СВXDTO(
		КонтекстПреобразования, ЗначениеРеквизита);
	Если ПроверитьЗаписываемСписокЗначений(КонтекстПреобразования, ЗначениеДляЗаписи) Тогда
		ЗаписатьМассивЗначенийРеквизитаВОбъектXDTO(
			КонтекстПреобразования, ЗначениеДляЗаписи);
	Иначе
		ЗаписатьЗначениеРеквизитаВОбъектXDTO(
			КонтекстПреобразования, ЗначениеДляЗаписи);
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
КонецПроцедуры

// Структура параметров для выполнения функций заполнения реквизита.
//
Функция СоздатьКонтекстПреобразованияРеквизита(
										ПравилоПреобразованияОбъекта,
										Объект1С,
										ОбъектXDTO,
										ДопПараметры)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"СоздатьКонтекстПреобразованияРеквизита",
		АргументыВМассив4(
			ПравилоПреобразованияОбъекта, Объект1С, ОбъектXDTO, ДопПараметры));
	КонтекстПреобразования = Новый Структура;
	КонтекстПреобразования.Вставить("Обработка", ЭтотОбъект);
	КонтекстПреобразования.Вставить("ФабрикаXDTO", ПолучитьФабрикуXDTO());
	КонтекстПреобразования.Вставить("ПравилоПреобразованияОбъекта",
		ПравилоПреобразованияОбъекта);
	КонтекстПреобразования.Вставить("Объект1С", Объект1С);
	КонтекстПреобразования.Вставить("ОбъектXDTO", ОбъектXDTO);
	КонтекстПреобразования.Вставить("Результат", Неопределено);
	КонтекстПреобразования.Вставить("ПравилоРеквизита", Неопределено);
	КонтекстПреобразования.Вставить("ЗначениеРеквизита", Неопределено);
	КонтекстПреобразования.Вставить("ЗначениеДляЗаписи", Неопределено);
	КонтекстПреобразования.Вставить("Вход", 
		?(ПравилоПреобразованияОбъекта.ЕстьДопПараметры,
			ДопПараметры, 
			Неопределено));
	КонтекстПреобразования.Вставить("Выход", Новый Структура);
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат КонтекстПреобразования;
КонецФункции

Процедура УстановитьВКонтекстеПравилоПреобразованияРеквизита(
										КонтекстПреобразования,
										ПравилоПреобразованияРеквизита)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"УстановитьВКонтекстеПравилоПреобразованияРеквизита",
		АргументыВМассив2(
			КонтекстПреобразования, ПравилоПреобразованияРеквизита));
	КонтекстПреобразования.ПравилоРеквизита =
		ПравилоПреобразованияРеквизита;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
КонецПроцедуры

Процедура УстановитьВКонтекстеЗначениеРеквизита(КонтекстПреобразования,
												ЗначениеРеквизита)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"УстановитьВКонтекстеЗначениеРеквизита",
		АргументыВМассив2(КонтекстПреобразования, ЗначениеРеквизита));
	КонтекстПреобразования.ЗначениеРеквизита = ЗначениеРеквизита;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
КонецПроцедуры

Процедура УстановитьВКонтекстеЗначениеДляЗаписи(КонтекстПреобразования,
												ЗначениеДляЗаписи)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"УстановитьВКонтекстеЗначениеДляЗаписи",
		АргументыВМассив2(КонтекстПреобразования, ЗначениеДляЗаписи));
	КонтекстПреобразования.ЗначениеДляЗаписи = ЗначениеДляЗаписи;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
КонецПроцедуры

Функция ПолучитьЗначениеРеквизитаОбъекта1С(КонтекстПреобразования)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьЗначениеРеквизитаОбъекта1С",
		АргументыВМассив1(КонтекстПреобразования));
	ПравилоПолучения = КонтекстПреобразования.ПравилоРеквизита;
	Если ПравилоПолучения <> Неопределено Тогда
		Если ПравилоПолучения.СпособПолучения = "Реквизит" Тогда
			Объект1С = КонтекстПреобразования.Объект1С;
			Если Обработки.КонвертерОбъектовXDTOУХ.ЭтоСсылочныйТип(
											ТипЗнч(Объект1С)) Тогда
				ОтладкаПриОкончанииФункции(КонтекстОтладки);
				ЧастиИмениТипа = 
					СтрРазделить(ПравилоПолучения.ИсточникПолучения, ".");
				Если ЧастиИмениТипа.Количество() = 2
							И ЧастиИмениТипа[0] = "ТабличнаяЧасть" Тогда
					Возврат Объект1С[ЧастиИмениТипа[1]];
				Иначе
					Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(
						Объект1С, ПравилоПолучения.ИсточникПолучения);
				КонецЕсли;
			Иначе
				ОтладкаПриОкончанииФункции(КонтекстОтладки);
				Возврат Объект1С[ПравилоПолучения.ИсточникПолучения];
			КонецЕсли;
		ИначеЕсли ПравилоПолучения.СпособПолучения = "Функция" Тогда
			УпакованРезультат = ВыполнитьАлгоритм(
				ПравилоПолучения.ИсточникПолучения, КонтекстПреобразования);
			Если УпакованРезультат.ЕстьОшибка Тогда
				ОтладкаПриОкончанииФункции(КонтекстОтладки);
				ВызватьИсключение ПолучитьСтрокуОписанияОшибки(
					УпакованРезультат.Ошибка,
					ПолучитьКонтекстОшибкиДляКонтекстаПреобразованияРеквизита(
						КонтекстПреобразования));
			КонецЕсли;
			ОтладкаПриОкончанииФункции(КонтекстОтладки);
			Возврат УпакованРезультат.Результат;
		КонецЕсли;
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат КонтекстПреобразования.Объект1С;
КонецФункции

Функция ПреобразоватьЗначениеРеквизита1СВXDTO(КонтекстПреобразования,
											ЗначениеРеквизита)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПреобразоватьЗначениеРеквизита1СВXDTO",
		АргументыВМассив2(КонтекстПреобразования, ЗначениеРеквизита));
	Если ЗначениеРеквизита = Неопределено Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Неопределено;
	КонецЕсли;
	СпособПреобразования =
		КонтекстПреобразования.ПравилоРеквизита.СпособПреобразования;
	флПустоеПравилоПреобразования = ПустаяСтрока(СпособПреобразования);
	Если флПустоеПравилоПреобразования Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат ЗначениеРеквизита;
	ИначеЕсли КонтекстПреобразования.ПравилоРеквизита.ПолучаемСписок Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат ПреобразоватьСписокЗначенийРеквизита1СВXDTO(
			КонтекстПреобразования, ЗначениеРеквизита);
	КонецЕсли;
	Результат = ПреобразоватьОдноЗначениеРеквизита1СВXDTO(
		КонтекстПреобразования, ЗначениеРеквизита);
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

Функция ПреобразоватьСписокЗначенийРеквизита1СВXDTO(КонтекстПреобразования,
													мЗначенийРеквизита)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПреобразоватьСписокЗначенийРеквизита1СВXDTO",
		АргументыВМассив2(КонтекстПреобразования, мЗначенийРеквизита));
	Результат = мЗначенийРеквизита;
	ПравилоРеквизита = КонтекстПреобразования.ПравилоРеквизита;
	Если НЕ ПустаяСтрока(ПравилоРеквизита.СпособПреобразования)
				И мЗначенийРеквизита <> Неопределено Тогда
		Результат = Новый Массив;
		Для Каждого ЗначениеРеквизита Из мЗначенийРеквизита Цикл
			НовоеЗначение = ПреобразоватьОдноЗначениеРеквизита1СВXDTO(
				КонтекстПреобразования, ЗначениеРеквизита);
			Если НовоеЗначение <> Неопределено Тогда
				Если ПравилоРеквизита.ПреобразованиеВСписок 
						И ТипЗнч(НовоеЗначение) = Тип("Массив") Тогда
					ОбщегоНазначенияКлиентСервер.ДополнитьМассив(
						Результат, НовоеЗначение, Ложь);
				Иначе
					Результат.Добавить(НовоеЗначение);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		ОбщегоНазначенияКлиентСервер.СвернутьМассив(Результат);
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

Функция ПолучитьДопПараметрыИзКонтекстаПреобразования(КонтекстПреобразования)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПолучитьДопПараметрыИзКонтекстаПреобразования",
		АргументыВМассив1(КонтекстПреобразования));
	ПравилоРеквизита = КонтекстПреобразования.ПравилоРеквизита;
	Если ПравилоРеквизита = Неопределено
			ИЛИ НЕ ПравилоРеквизита.ЕстьДопПараметры Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Неопределено;
	КонецЕсли;
	Результат = КонтекстПреобразования.Выход;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

Функция ПреобразоватьОдноЗначениеРеквизита1СВXDTO(КонтекстПреобразования,
												ЗначениеРеквизита)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПреобразоватьОдноЗначениеРеквизита1СВXDTO",
		АргументыВМассив2(КонтекстПреобразования, ЗначениеРеквизита));
	ПравилоРеквизита = КонтекстПреобразования.ПравилоРеквизита;
	НовоеЗначение = ЗначениеРеквизита;
	Ошибка = Неопределено;
	СпособПреобразования = ПравилоРеквизита.СпособПреобразования;
	Если НЕ ПустаяСтрока(СпособПреобразования) Тогда
		Если СпособПреобразования = "ВСтроку" Тогда
			НовоеЗначение = Строка(ЗначениеРеквизита);
		ИначеЕсли СпособПреобразования = "ВЧисло" Тогда
			НовоеЗначение = Число(ЗначениеРеквизита);
		ИначеЕсли СпособПреобразования = "ВДату" Тогда
			НовоеЗначение = Дата(ЗначениеРеквизита);
		ИначеЕсли СпособПреобразования = "ВБулево" Тогда
			НовоеЗначение = Булево(ЗначениеРеквизита);
		ИначеЕсли СпособПреобразования = "ПредопределенноеЗначениеПоТипуXSD"
				ИЛИ  СпособПреобразования = "ПримитивноеЗначениеПоПравилу" Тогда
			НовоеЗначение = ПредопределенноеЗначение1СВXDTO(
				ЗначениеРеквизита,
				ПравилоРеквизита.ИмяТипаXSD,
				ПравилоРеквизита.ОписаниеПреобразования,
				ПолучитьДопПараметрыИзКонтекстаПреобразования(
						КонтекстПреобразования));
		ИначеЕсли СпособПреобразования = "ПоТипу" Тогда
			НовоеЗначение = Объект1СВОбъектXDTO(
				ЗначениеРеквизита,
				Неопределено,
				ПравилоРеквизита.ИмяТипаXSD,
				ПравилоРеквизита.ОписаниеПреобразования,
				ПолучитьДопПараметрыИзКонтекстаПреобразования(
						КонтекстПреобразования));
		ИначеЕсли СпособПреобразования = "Функция" Тогда
			УстановитьВКонтекстеЗначениеРеквизита(
				КонтекстПреобразования, ЗначениеРеквизита);
			НовоеЗначение = ВыполнитьАлгоритм(
				ПравилоРеквизита.ОписаниеПреобразования,
				КонтекстПреобразования);
		КонецЕсли;
	КонецЕсли;
	Если Обработки.КонвертерОбъектовXDTOУХ.ЭтоСтруктураРезультата(
												НовоеЗначение) Тогда
		Если НовоеЗначение.ЕстьОшибка Тогда
			ОтладкаПриОкончанииФункции(КонтекстОтладки);
			ВызватьИсключение ПолучитьСтрокуОписанияОшибки(
				НовоеЗначение.Ошибка,
				ПолучитьКонтекстОшибкиДляКонтекстаПреобразованияРеквизита(
					КонтекстПреобразования));
		Иначе
			ОтладкаПриОкончанииФункции(КонтекстОтладки);
			Возврат НовоеЗначение.Результат;
		КонецЕсли;
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат НовоеЗначение;
КонецФункции

Функция ПроверитьЗаписываемСписокЗначений(КонтекстПреобразования,
											ЗначениеДляЗаписи)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ПроверитьЗаписываемСписокЗначений",
		АргументыВМассив2(КонтекстПреобразования, ЗначениеДляЗаписи));
	Если ЗначениеДляЗаписи = Неопределено Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Ложь;
	ИначеЕсли ТипЗнч(ЗначениеДляЗаписи) = Тип("Массив") Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Истина;
	КонецЕсли;
	Если НЕ ПустаяСтрока(
			КонтекстПреобразования.ПравилоРеквизита.СпособПреобразования)
			И КонтекстПреобразования.ПравилоРеквизита.ПреобразованиеВСписок Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат Истина;
	КонецЕсли;
	Результат = КонтекстПреобразования.ПравилоРеквизита.ПолучаемСписок;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции

Процедура ЗаписатьЗначениеРеквизитаВОбъектXDTO(КонтекстПреобразования,
											ЗначениеДляЗаписи)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ЗаписатьЗначениеРеквизитаВОбъектXDTO",
		АргументыВМассив2(КонтекстПреобразования, ЗначениеДляЗаписи));
	Если ЗначениеДляЗаписи = Неопределено Тогда
		Возврат;
	КонецЕсли;
	ПравилоРеквизита = КонтекстПреобразования.ПравилоРеквизита;
	Если ПравилоРеквизита = Неопределено Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат;
	КонецЕсли;
	Если ПравилоРеквизита.СпособЗаполнения = "Реквизит" Тогда
		УстановитьСвойствоОбъектаXDTO(
			КонтекстПреобразования.ОбъектXDTO,
			ПравилоРеквизита.Приемник,
			ЗначениеДляЗаписи);
	ИначеЕсли ПравилоРеквизита.СпособЗаполнения = "Функция" Тогда
		УстановитьВКонтекстеЗначениеДляЗаписи(
			КонтекстПреобразования, ЗначениеДляЗаписи);
		РезультатУпакован = ВыполнитьАлгоритм(
			ПравилоРеквизита.Приемник, КонтекстПреобразования);
		Если РезультатУпакован.ЕстьОшибка Тогда
			ОтладкаПриОкончанииФункции(КонтекстОтладки);
			ВызватьИсключение ПолучитьСтрокуОписанияОшибки(
				РезультатУпакован.Ошибка,
				ПолучитьКонтекстОшибкиДляКонтекстаПреобразованияРеквизита(
					КонтекстПреобразования));
		КонецЕсли;
	КонецЕсли;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
КонецПроцедуры

Процедура ЗаписатьМассивЗначенийРеквизитаВОбъектXDTO(КонтекстПреобразования,
												мЗначенийДляЗаписи)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ЗаписатьМассивЗначенийРеквизитаВОбъектXDTO",
		АргументыВМассив2(КонтекстПреобразования, мЗначенийДляЗаписи));
	Если мЗначенийДляЗаписи = Неопределено
				ИЛИ мЗначенийДляЗаписи.Количество() = 0 Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат;
	КонецЕсли;
	ПравилоРеквизита = КонтекстПреобразования.ПравилоРеквизита;
	Если ПравилоРеквизита = Неопределено Тогда
		ОтладкаПриОкончанииФункции(КонтекстОтладки);
		Возврат;
	КонецЕсли;
	Приемник = ПравилоРеквизита.Приемник;
	Для Каждого ЗначениеДляЗаписи Из мЗначенийДляЗаписи Цикл
		Если ЗначениеДляЗаписи <> Неопределено Тогда
			ЗаписатьЗначениеРеквизитаВОбъектXDTO(
				КонтекстПреобразования, ЗначениеДляЗаписи);
		КонецЕсли;
	КонецЦикла;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
КонецПроцедуры

// Выполняет текст алгоритма. При необходимости, заменяет
//  ссылку на макрос #[ИмяМакроса] на его текст.
//
// Параметры:
//  Алгоритм - Строка - текст алгоритма.
//  Параметры - Любое значение - будет доступно во время
//		выполнения алгоритма.
// 
// Возвращаемое значение:
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка()
//		- при выполнении алгоритма возникла ошибка.
//	- Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех()
//		- алгоритм выполнен успешно, в Результат содержится:
//			- произвольное значение - если в алгоритме
//				заполнена переменная "Результат".
//			- Неопределено - если переменная "Результат"
//				не установлена в алгоритме.
//
Функция ВыполнитьАлгоритм(Алгоритм, Параметры)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ВыполнитьАлгоритм",
		АргументыВМассив2("Алгоритм", "Параметры"));
	ПолныйТекстАлгоритма__ = ЗаменитьСсылкиНаМакросыТекстомМакроса(Алгоритм);
	Результат = Обработки.КонвертерОбъектовXDTOУХ.ВыполнитьВБезопасномРежиме(
		ПолныйТекстАлгоритма__, Параметры);
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции
	
// Заменяет в тексте функции все последовательности символов
Функция ЗаменитьСсылкиНаМакросыТекстомМакроса(ТекстФункции)
	КонтекстОтладки = ОтладкаПриНачалеФункции(
		"ЗаменитьСсылкиНаМакросыТекстомМакроса",
		АргументыВМассив1("ТекстФункции"));
	Результат = ТекстФункции;
	ПозНач = 1;
	Пока Истина Цикл
		ПозНач = СтрНайти(Результат, "#[", , ПозНач);
		Если ПозНач = 0 Тогда
			Прервать;
		КонецЕсли;
		ПозКон = СтрНайти(Результат, "]", , ПозНач+2);
		Если ПозКон = 0 Тогда
			Прервать;
		КонецЕсли;
		ИмяФункции = ВРег(Сред(Результат, ПозНач+2, ПозКон-ПозНач-2));
		ОписаниеОбщейФункции = ЭтотОбъект.Макросы.Найти(ИмяФункции, "Имя");
		Если ОписаниеОбщейФункции <> Неопределено 
				И НЕ ПустаяСтрока(ОписаниеОбщейФункции.Текст) Тогда
			Результат = Лев(Результат, ПозНач-1)
				+ Символы.ПС
				+ ОписаниеОбщейФункции.Текст
				+ Символы.ПС
				+ Сред(Результат, ПозКон+1);
		КонецЕсли;
		ПозНач = ПозКон + 1;	
	КонецЦикла;
	ОтладкаПриОкончанииФункции(КонтекстОтладки);
	Возврат Результат;
КонецФункции


#КонецОбласти


#Область НеЭкспортныеФункцииПроверкиПравил


// Проверяет возможность заполнить объект XDTO из реквизитов
// объекта 1С (способ получения - "МассивПравил").
//
Функция ПроверитьПравилоПреобразованияОбъекта1С(ПравилоПреобразованияОбъекта,
												Объект1С,
												ДопПараметры)
	СпособПолучения = ПравилоПреобразованияОбъекта.СпособПолучения;
	Если СпособПолучения = "МассивПравил" Тогда
		ТипXSD = ПолучитьТипXDTOИзПравила(ПравилоПреобразованияОбъекта);
		Если ТипXSD = Неопределено Тогда
			Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
				СтрШаблон(НСтр(
					"ru='В правиле преобразования не найден тип XSD! Правило: %1'"),
					ПравилоВСтроку(ПравилоПреобразованияОбъекта)));
		КонецЕсли;
		ОбъектXDTO = СоздатьОбъектXDTOПоТипу(ТипXSD);
		Если ОбъектXDTO = Неопределено Тогда
			Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
				СтрШаблон(НСтр(
					"ru='Не удалось создать объект XDTO по правилу: %1'"),
					ПравилоВСтроку(ПравилоПреобразованияОбъекта)));
		КонецЕсли;
		Возврат Обработки.КонвертерОбъектовXDTOУХ.УпаковатьРезультат(
			ПроверитьРеквизитыОбъектаXDTOПоПравилу(
					ПравилоПреобразованияОбъекта,
					Объект1С, 
					ОбъектXDTO, 
					ДопПараметры),
			СтрШаблон(НСтр("ru='Ошибка в правиле заполнения реквизитов: %1'"),
					ПравилоВСтроку(ПравилоПреобразованияОбъекта)));
	КонецЕсли;
	Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Истина);
КонецФункции

// Проверяет возможность заполнить реквизиты объекта XDTO из объекта 1С.
//
Функция ПроверитьРеквизитыОбъектаXDTOПоПравилу(ПравилоПреобразованияОбъекта,
											   Объект1С,
											   ИмяТипаXSD,
											   ДопПараметры)
	РезультатПроверки = Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Истина);
	Если НЕ ПустаяСтрока(ИмяТипаXSD) И Объект1С <> Неопределено Тогда
		мПравилРеквизитов =
			ПолучитьРабочиеПравилаПреобразованияРеквизитовОбъекта1СВXDTO(
				ПравилоПреобразованияОбъекта);
		Если мПравилРеквизитов = Неопределено
				ИЛИ мПравилРеквизитов.Количество() = 0 Тогда
			Возврат Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
				СтрШаблон(НСтр(
					"ru='Не удалось получить правила преобразования реквизитов"
												+ " по правилу объекта: %1'"),
					ПравилоВСтроку(ПравилоПреобразованияОбъекта)));
		КонецЕсли;
		// Подменяем объект XDTO на ИмяТипаXDTO.
		КонтекстПреобразованияРеквизита = СоздатьКонтекстПреобразованияРеквизита(
			ПравилоПреобразованияОбъекта, Объект1С, ИмяТипаXSD, ДопПараметры);
		// Добавляем в контекст перечень обязательных реквизитов объекта XDTO.
		КонтекстПреобразованияРеквизита.Вставить("ОбязательныеРеквизитыXDTO",
			ПолучитьОбязательныеРеквизитыОбъектаXDTO(ИмяТипаXSD));
		Для Каждого ПравилоПреобразованияРеквизита Из мПравилРеквизитов Цикл
			УстановитьВКонтекстеПравилоПреобразованияРеквизита(
				КонтекстПреобразованияРеквизита, ПравилоПреобразованияРеквизита);
			РезультатПроверки = Обработки.КонвертерОбъектовXDTOУХ.ОбъединитьОшибки(
				РезультатПроверки,
				ПроверитьЗаполнениеРеквизитОбъектаXDTOПоПравилу(
					КонтекстПреобразованияРеквизита));
		КонецЦикла;
	КонецЕсли;
	Возврат РезультатПроверки;
КонецФункции

// Проверяет правило заполнения реквизита объекта XDTO из объекта 1С.
//
Функция ПроверитьЗаполнениеРеквизитОбъектаXDTOПоПравилу(КонтекстПреобразования)
	РезультатПроверки = ПроверитьПолучениеЗначениеРеквизитаОбъекта1С(
		КонтекстПреобразования);
	РезультатПроверки = Обработки.КонвертерОбъектовXDTOУХ.ОбъединитьОшибки(
		РезультатПроверки,
		ПроверитьПреобразованиеЗначенияРеквизита1СВXDTO(
			КонтекстПреобразования));
	РезультатПроверки = Обработки.КонвертерОбъектовXDTOУХ.ОбъединитьОшибки(
		РезультатПроверки,
		ПроверитьЗаполнениеЗначенияРеквизита1СВXDTO(КонтекстПреобразования));
	Возврат РезультатПроверки;
КонецФункции

Функция ПроверитьПолучениеЗначениеРеквизитаОбъекта1С(КонтекстПреобразования)
	РезультатПроверки =
		Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Истина);
	ПравилоПолучения = КонтекстПреобразования.ПравилоРеквизита;
	Если ПравилоПолучения = Неопределено Тогда
		Возврат  Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
			НСтр("ru='Правило получения значения из объекта 1С не заполнено.'"));
	КонецЕсли;
	Если ПравилоПолучения.СпособПолучения = "Реквизит" Тогда
		Если КонтекстПреобразования.ОбязательныеРеквизитыXDTO[
					ПравилоПолучения.ИсточникПолучения] <> Неопределено Тогда
			Объект1С = КонтекстПреобразования.Объект1С;
			ЗначениеРеквизита = Неопределено;
			Если Обработки.КонвертерОбъектовXDTOУХ.ЭтоСсылочныйТип(
											ТипЗнч(Объект1С)) Тогда
				ОбщегоНазначения.ЗначениеРеквизитаОбъекта(
					Объект1С, ПравилоПолучения.ИсточникПолучения);
			Иначе
				ЗначениеРеквизита = Объект1С[ПравилоПолучения.ИсточникПолучения];
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ПравилоПолучения.СпособПолучения = "Функция" Тогда
		Если ПустаяСтрока(ПравилоПолучения.ИсточникПолучения) Тогда
			Возврат  Обработки.КонвертерОбъектовXDTOУХ.РезультатОшибка(
				НСтр("ru='Не заполнена функция получения значения из объекта 1С.'"));
		КонецЕсли;
	КонецЕсли;
	Возврат РезультатПроверки;
КонецФункции

Функция ПроверитьПреобразованиеЗначенияРеквизита1СВXDTO(КонтекстПреобразования)
	//СпособПреобразования =
	//	КонтекстПреобразования.ПравилоРеквизита.СпособПреобразования;
	//флПустоеПравилоПреобразования = ПустаяСтрока(СпособПреобразования);
	//Если флПустоеПравилоПреобразования Тогда
	//	Возврат ЗначениеРеквизита;
	//ИначеЕсли КонтекстПреобразования.ПравилоРеквизита.ПолучаемСписок Тогда
	//	ЗначениеДляЗаписи = ПреобразоватьСписокЗначенийРеквизита1СВXDTO(
	//		КонтекстПреобразования, ЗначениеРеквизита);
	//КонецЕсли;
	//Возврат ПреобразоватьОдноЗначениеРеквизита1СВXDTO(
	//	КонтекстПреобразования, ЗначениеРеквизита);
	Возврат
		Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Истина);
КонецФункции

Функция ПроверитьЗаполнениеЗначенияРеквизита1СВXDTO(КонтекстПреобразования)
	Возврат
		Обработки.КонвертерОбъектовXDTOУХ.РезультатУспех(Истина);
КонецФункции

Функция ПолучитьОбязательныеРеквизитыОбъектаXDTO(ИмяТипаXSD)
	Результат = Новый Соответствие;
	мСтроки = ЭтотОбъект.МетаСвойстваОбъектовXSD.НайтиСтроки(Новый Структура(
		"ИмяТипаОбъекта, ВозможноПустое", ИмяТипаXSD, Ложь));
	Для Каждого Свойство Из мСтроки Цикл
		Результат.Вставить(Свойство.ИмяСвойства, Свойство);
	КонецЦикла;
	Возврат Результат;
КонецФункции


#КонецОбласти


#Область НеЭкспортныеФункцииРаботыСКонтекстомОбработки


Функция УстановитьЗначениеВКонтексте(ИмяКлюча, Значение)
	Контекст = ПолучитьКонтекстОбработки();
	Контекст.Вставить(ИмяКлюча, Значение);
	Возврат ЭтотОбъект;
КонецФункции

Функция ПолучитьЗначениеВКонтексте(ИмяКлюча, ЗначениеИнициализации=Неопределено)
	Контекст = ПолучитьКонтекстОбработки();
	ЗначениеКлюча = Неопределено;
	Если Контекст.Свойство(ИмяКлюча, ЗначениеКлюча) Тогда
		Возврат ЗначениеКлюча;
	КонецЕсли;
	Если ЗначениеИнициализации <> Неопределено Тогда
		УстановитьЗначениеВКонтексте(ИмяКлюча, ЗначениеИнициализации);
	КонецЕсли;
	Возврат ЗначениеИнициализации;
КонецФункции

Функция ЗавершитьПолучитьЗначениеВКонтексте(ИмяКлюча)
	Контекст = ПолучитьКонтекстОбработки();
	Результат = ПолучитьЗначениеВКонтексте(ИмяКлюча);
	Контекст[ИмяКлюча] = Неопределено;
	Возврат Результат;
КонецФункции

Функция НачатьЗаполнениеМассиваВКонтексте(ИмяМассива)
	УстановитьЗначениеВКонтексте(ИмяМассива, Новый Массив);
	Возврат ЭтотОбъект;
КонецФункции

Функция ДобавитьВМассивВКонтексте(ИмяМассива, Значение)
	Контекст = ПолучитьКонтекстОбработки();
	ЭтотМассив = ПолучитьЗначениеВКонтексте(ИмяМассива);
	ЭтотМассив.Добавить(Значение);
	Возврат ЭтотОбъект;
КонецФункции

Функция ЗавершитьПолучитьМассивИзКонтекста(ИмяМассива)
	Возврат ЗавершитьПолучитьЗначениеВКонтексте(ИмяМассива);
КонецФункции

// Возвращает контекст обработки. Если необходимо инициализирует его.
//
Функция ПолучитьКонтекстОбработки()
	Если КонтекстОбработкиГлобальнаяПеременная = Неопределено Тогда
		КонтекстОбработкиГлобальнаяПеременная = Новый Структура;
	КонецЕсли;
	Возврат КонтекстОбработкиГлобальнаяПеременная;
КонецФункции

Процедура ОчиститьКонтекстОбработки()
	Если КонтекстОбработкиГлобальнаяПеременная <> Неопределено Тогда
		КонтекстОбработкиГлобальнаяПеременная = Неопределено;
	КонецЕсли;
КонецПроцедуры

Функция ПолучитьНовыйКлючПравилРеквизитов()
	Результат = ПоследнийВыделенныйКлючПравилРеквизитов + 1;
	ПоследнийВыделенныйКлючПравилРеквизитов = Результат;
	Возврат Результат;
КонецФункции


#КонецОбласти


#Область НеЭкспортныеПреобразованиеОбработкиВПростыеОбъекты


Функция ПреобразоватьВСтруктуруДанных()
	Правила = Новый Структура("Реквизиты, ТабличныеЧасти",
							Новый Структура, Новый Структура);
	МетаданныеОбработки = ЭтотОбъект.Метаданные();
	Для Каждого МетаданныеРеквизита Из МетаданныеОбработки.Реквизиты Цикл
		ИмяРеквизита = МетаданныеРеквизита.Имя;
		Правила.Реквизиты.Вставить(ИмяРеквизита, ЭтотОбъект[ИмяРеквизита]);
	КонецЦикла;
	Правила.ТабличныеЧасти.Вставить("Объекты1СВXDTO",
		ЭтотОбъект.Объекты1СВXDTO.Выгрузить());
	Правила.ТабличныеЧасти.Вставить("Значения1СВXDTO",
		ЭтотОбъект.Значения1СВXDTO.Выгрузить(
			, ПолучитьИменаВыгружаемыхКолонокТЧЗначений()));
	Правила.ТабличныеЧасти.Вставить("ПравилаПреобразованияРеквизитов1СВXDTO",
		ЭтотОбъект.ПравилаПреобразованияРеквизитов1СВXDTO.Выгрузить());
	Правила.ТабличныеЧасти.Вставить("Макросы", ЭтотОбъект.Макросы.Выгрузить());
	Правила.ТабличныеЧасти.Вставить("ПространстваИменXSD",
		ЭтотОбъект.ПространстваИменXSD.Выгрузить());
	Возврат Правила;
КонецФункции

Процедура ПрочитатьИзСтруктурыДанных(СтруктураСДанными)
	ИнициализироватьОбработку();
	ЗаполнитьРеквизитыИзСтруктурыДанных(СтруктураСДанными.Реквизиты);
	ЗаполнитьТабличныеЧастиИзСтруктурыДанных(СтруктураСДанными.ТабличныеЧасти);
	ЗаполнитьЗначения1СТЧЗначений();
КонецПроцедуры

Процедура ЗаполнитьРеквизитыИзСтруктурыДанных(СтруктураСРеквизитами)
	МетаданныеРеквизитов = ЭтотОбъект.Метаданные().Реквизиты;
	Для Каждого ИмяЗначение Из СтруктураСРеквизитами Цикл
		ИмяРеквизита = ИмяЗначение.Ключ;
		Если МетаданныеРеквизитов.Найти(ИмяРеквизита) <> Неопределено Тогда
			ЭтотОбъект[ИмяРеквизита] = ИмяЗначение.Значение;
		Иначе
			Устарели.Добавить(ИмяЗначение.Значение, ИмяРеквизита);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаполнитьТабличныеЧастиИзСтруктурыДанных(СтруктураСТЧ)
	МетаданныеТЧ = ЭтотОбъект.Метаданные().ТабличныеЧасти;
	Для Каждого ИмяЗначение Из СтруктураСТЧ Цикл
		ИмяТЧ = ИмяЗначение.Ключ;
		Если МетаданныеТЧ.Найти(ИмяТЧ) <> Неопределено Тогда
			ЭтотОбъект[ИмяТЧ].Загрузить(ИмяЗначение.Значение);
		ИначеЕсли ИмяТЧ = "ОбщиеФункции" Тогда
			ЭтотОбъект.Макросы.Загрузить(ИмяЗначение.Значение);
		Иначе
			Устарели.Добавить(ИмяЗначение.Значение, ИмяТЧ);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаполнитьЗначения1СТЧЗначений()
	Для Каждого Строка Из Значения1СВXDTO Цикл
		ИмяТипаИсточника = Строка.ИмяТипаИсточника;
		ИмяЗначения = Строка.ИмяЗначения;
		Если ИмяТипаИсточника = "Строка"
				ИЛИ ИмяТипаИсточника = "Число"
				ИЛИ ИмяТипаИсточника = "Дата"
				ИЛИ ИмяТипаИсточника = "Булево" Тогда
			Строка.Значение1С =
				XMLЗначение(Тип(ИмяТипаИсточника), ИмяЗначения);
		Иначе
			Строка.Значение1С = 
				Обработки.КонвертерОбъектовXDTOУХ.ПолучитьПредопределенноеЗначение1С(
					ИмяТипаИсточника, ИмяЗначения);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция ПолучитьИменаВыгружаемыхКолонокТЧЗначений()
	Возврат "Отключить,
			|ИмяГруппы,
			|ЕстьДопПараметры,
			|ИмяТипаИсточника,
			|ИмяЗначения,
			|ИмяТипаПриемника,
			|СпособПолучения,
			|ПростоеЗначение,
			|БольшаяСтрока";
КонецФункции


#КонецОбласти


#Область НеЭкспортныеОбработкаОшибок


// Возвращает JSON представление структуры ошибки для указанного
// текста ошибки.
// В контексте ошибки можно передать структуру описывающую контекст.
//
Функция ПолучитьСтрокуОписанияОшибки(ТекстОшибки, КонтекстОшибки=Неопределено)
	ВложенноеОписаниеОшибки = ПопробоватьПолучитьОписаниеОшибкиИзСтрокиJSON(
		ТекстОшибки);
	Если ВложенноеОписаниеОшибки <> Неопределено Тогда
		ВнутреннийКонтекст = ВложенноеОписаниеОшибки.КонтекстОшибки;
		ТекстОшибки_ = ВложенноеОписаниеОшибки.ТекстОшибки;
		КонтекстОшибки_ = ОбъединитьКонтекстыОшибкиВДерево(
			КонтекстОшибки, ВнутреннийКонтекст);
	Иначе
		ТекстОшибки_ = ТекстОшибки;
		КонтекстОшибки_ = КонтекстОшибки;
	КонецЕсли;
	Возврат ОписаниеОшибкиВСтрокуJSON(
		ПолучитьСтруктуруОписанияОшибки(
			ТекстОшибки_, КонтекстОшибки_));
КонецФункции

// Возвращает JSON представление структуры ошибки.
// См. ПолучитьСтруктуруОписанияОшибки().
// Если ТекстОшибки - это строка описания ошибки в формате JSON,
// то переупаковывает текст ошибки, так, что он остается в поле
// ТекстОшибки, а реквизит КонтекстОшибки превращается в дерево
// с корнем в переданном контексте.
//
Функция ПолучитьСтрокуОписанияОшибкиИзИсключения(ИнформацияОбОшибке,
												КонтекстОшибки)
	ВложенноеОписаниеОшибки = ПопробоватьПолучитьОписаниеОшибкиИзСтрокиJSON(
		ИнформацияОбОшибке.Описание);
	Если ВложенноеОписаниеОшибки <> Неопределено Тогда
		ВнутреннийКонтекст = ВложенноеОписаниеОшибки.КонтекстОшибки;
		ТекстОшибки = ВложенноеОписаниеОшибки.ТекстОшибки;
	Иначе
		ВнутреннийКонтекст = ИнформацияОбОшибкеВСтруктуру(ИнформацияОбОшибке);
		ТекстОшибки = ИнформацияОбОшибке.Описание;
	КонецЕсли;
	Возврат ОписаниеОшибкиВСтрокуJSON(
		ПолучитьСтруктуруОписанияОшибки(
			ТекстОшибки,
			ОбъединитьКонтекстыОшибкиВДерево(
				КонтекстОшибки, ВнутреннийКонтекст)));
КонецФункции

Функция ПолучитьСтруктуруОписанияОшибки(ТекстОшибки,
										КонтекстОшибки=Неопределено)
	Описание = Новый Структура;
	Описание.Вставить("ТекстОшибки", ТекстОшибки);
	Описание.Вставить("КонтекстОшибки", КонтекстОшибки);
	Возврат Описание;
КонецФункции

Функция ИнформацияОбОшибкеВСтруктуру(ИнформацияОбОшибке)
	Описание = Новый Структура("ИмяМодуля,ИсходнаяСтрока,НомерСтроки,Причина");
	ЗаполнитьЗначенияСвойств(Описание, ИнформацияОбОшибке);
	Возврат Описание;
КонецФункции

// Если в строке записан объект JSON представляющий структуру
// описания ошибки, то возвращает ее. Иначе Неопределено.
//
Функция ПопробоватьПолучитьОписаниеОшибкиИзСтрокиJSON(Текст)
	Если Лев(СокрЛ(Текст), 1) = "{" Тогда
		Попытка
			СтруктураОшибки = РаспаковатьСтрокуJSONВСтруктуруОшибки(Текст);
			Возврат СтруктураОшибки;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ОбъединитьКонтекстыОшибкиВДерево(ВнешнийКонтекст, ВнутреннийКонтекст)
	Если ВнешнийКонтекст = Неопределено Тогда
		Возврат ВнутреннийКонтекст;
	КонецЕсли;
	Если ВнутреннийКонтекст <> Неопределено Тогда
		ВнешнийКонтекст.Вставить("ПодчиненныйКонтекст", ВнутреннийКонтекст);
	КонецЕсли;
	Возврат ВнешнийКонтекст;
КонецФункции

Функция ПолучитьОписаниеОшибкиДляПравилаЗначения(Правило,
												Объект1С,
												ТекстОшибки)
	Возврат ПолучитьКонтекстаОшибкиДляПравила(
		ПолучитьОписаниеПравилаПреобразованияЗначения(Правило),
			Строка(Объект1С));
КонецФункции
	
Функция ПолучитьКонтекстОшибкиДляПравилаОбъекта(Правило,
												Объект1С)
	Возврат ПолучитьКонтекстаОшибкиДляПравила(
		ПолучитьОписаниеПравилаПреобразованияОбъекта(Правило),
		Строка(Объект1С));
КонецФункции

Функция ПолучитьКонтекстОшибкиДляКонтекстаПреобразованияРеквизита(
											КонтекстПреобразованияРеквизита)
	Описание = Новый Структура;
	Описание.Вставить("Тип",
		НСтр("ru='Ошибка преобразования реквизита по правилу'"));
	Описание.Вставить("ПравилоОбъекта",
		ПолучитьОписаниеПравилаПреобразованияОбъекта(
			КонтекстПреобразованияРеквизита.ПравилоПреобразованияОбъекта));
	Описание.Вставить("ПравилоРеквизита",
		ПолучитьОписаниеПравилаПреобразованияРеквизитаОбъекта(
			КонтекстПреобразованияРеквизита.ПравилоРеквизита));
	Описание.Вставить("Объект1С", Строка(КонтекстПреобразованияРеквизита.Объект1С));
	Если КонтекстПреобразованияРеквизита.ЗначениеДляЗаписи <> Неопределено Тогда
		Описание.Вставить("ЗначениеДляЗаписи",
			Строка(КонтекстПреобразованияРеквизита.ЗначениеДляЗаписи));
	КонецЕсли;
	Возврат Описание;
КонецФункции
	
Функция ПолучитьКонтекстаОшибкиДляПравила(ОписаниеПравила,
										ПредставлениеОбъекта1С)
	Описание = Новый Структура;
	Описание.Вставить("Тип",
		НСтр("ru='Ошибка преобразования по правилу'"));
	Описание.Вставить("Правило", ОписаниеПравила);
	Описание.Вставить("Объект1С", ПредставлениеОбъекта1С);
	Возврат Описание;
КонецФункции

Функция ОписаниеОшибкиВСтрокуJSON(ОписаниеОшибки)
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(
		ПереносСтрокJSON.Авто, "  "));
	ЗаписатьJSON(ЗаписьJSON, ОписаниеОшибки);
	Результат = ЗаписьJSON.Закрыть();
	Возврат Результат;
КонецФункции

Функция РаспаковатьСтрокуJSONВСтруктуруОшибки(СтрокаJSON)
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	СтруктураОписанияОшибки = ПрочитатьJSON(ЧтениеJSON);
	ЧтениеJSON.Закрыть();
	Возврат СтруктураОписанияОшибки;
КонецФункции


#КонецОбласти


#Область ВспомогательныеНеЭкспортные


Функция ВыдавитьПервыйИзМассива(Массив)
	Если Массив.Количество() > 0 Тогда
		Значение = Массив[0];
		Массив.Удалить(0);
		Возврат Значение;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Массив произвольных объектов превращает в соответствие,
// где ключ - это имя объекта, получаемое из реквизита
// объекта ИмяРеквизита, а значение - это индекс объекта
// в массиве.
//
Функция ПреобразоватьМассивОбъектовВСоответствиеИменИИндексов(
													МассивОбъектов,
													ИмяРеквизита)
	Результат = Новый Соответствие;
	МаксИндекс = МассивОбъектов.Количество() - 1;
	Для Индекс = 0 По МаксИндекс Цикл
		Значение = МассивОбъектов[Индекс];
		Если Значение <> Неопределено Тогда
			Результат.Вставить(Значение[ИмяРеквизита], Индекс);
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Для массива перестановки возвращает переставленные значения:
// создает массив, где индексы - это значения перестановки
// (значения входящего массива), а значения - это индексы
// исходного массива.
//
Функция ВыполнитьПерестановкуМассива(МассивПерестановки)
	МаксИндекс = МассивПерестановки.Количество() - 1;
	Результат = Новый Массив(МаксИндекс+1);
	Для Индекс = 0 По МаксИндекс Цикл
		Результат[МассивПерестановки[Индекс]] = Индекс;
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Если перестановка не изменяет порядок элементов, то возвращает Истина.
// Иначе - Ложь.
//
Функция ЭтоЕдиничнаяПерестановка(МассивПерестановки)
	МаксИндекс = МассивПерестановки.Количество() - 1;
	Для Индекс = 0 По МаксИндекс Цикл
		Если Индекс <> МассивПерестановки[Индекс] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// Переместим указанные строки в соответствии с правилами.
// Перемещаем в конец, от первых к последним.
// Указанный порядок перестановки получается естественным путем.
//
Процедура ПереместитьВКонецСтрокиТЧПоПерестановке(МассивСтрокТЧ, 
											МассивПерестановки, 
											ТабличнаяЧасть)
	МаксИндексТЧ = ТабличнаяЧасть.Количество()-1;
	ПереставленныеИндексы = ВыполнитьПерестановкуМассива(МассивПерестановки);
	Для Каждого ИндексСтрокиТЧ Из ПереставленныеИндексы Цикл
		СтрокаТЧ = МассивСтрокТЧ[ИндексСтрокиТЧ];
		ИндексСтрокиВТЧ = ТабличнаяЧасть.Индекс(СтрокаТЧ);
		ТабличнаяЧасть.Сдвинуть(СтрокаТЧ, МаксИндексТЧ - ИндексСтрокиВТЧ);
	КонецЦикла;
КонецПроцедуры

Функция ЕстьДопПараметры(ДопПараметры)
	Возврат (ДопПараметры <> Неопределено) И ДопПараметры.Количество() > 0;
КонецФункции


#КонецОбласти


#КонецЕсли